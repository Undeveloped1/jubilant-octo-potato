<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zombies - Build 9.2 (Lore Update - FIXED)</title>
    <style>
        body { margin: 0; padding: 0; background-color: #000000; overflow: hidden; }
        canvas { display: block; margin: 0 auto; }
        #instructions {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            color: #444; font-family: sans-serif; pointer-events: none; opacity: 0.5;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>
<body>
<div id="instructions">WASD: Move | Mouse: Aim/Fire | TAB: Inventory | N: Night Vision | F: Interact | Q: Switch Weapon</div>
<script>

// --- CONSTANTS & LORE ---
const SAVE_KEY = 'zombie_save_v9_2';
const DEFAULT_STATS = { 
    hp: 10, maxHp: 10, stamina: 100, maxStamina: 100, ammo: 10, scrap: 0,
    hasFlashlight: false, hasShotgun: false, currentWeapon: 'pistol',
    armor: { head: null, body: null, arms: null, feet: null },
    logs: [], // New: Tracks collected lore IDs
    hideout: { 
        restAreaLvl: 0, 
        generatorLvl: 0, 
        hasSparkPlug: false,
        armory: { crafting: null, hasNVG: false } 
    }
};

const LORE_DATA = {
    1: { title: "THE EVICTION", text: "Management locked the courtyard gates at 6:00 PM. They said it was a curfew. But I hear screaming from the street. They aren't letting us out... they are keeping us in." },
    2: { title: "CONTAINMENT", text: "The military didn't come to save us. They firebombed the lower floors to seal the stairwells. We are trapped in the upper apartments. The gas lines are leaking." },
    3: { title: "SUBJECT ZERO", text: "It's not a virus. It's HIM. The big one on the roof. He absorbs the damage. As long as he stands, the horde keeps coming. We have to drop the extraction beacon to target him." }
};

// --- AUDIO MANAGER ---
class SoundManager {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.3; 
        this.masterGain.connect(this.ctx.destination);
    }
    resume() { if (this.ctx.state === 'suspended') this.ctx.resume(); }
    playTone(freq, type, duration, vol = 1) {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type; osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain); gain.connect(this.masterGain);
        osc.start(); osc.stop(this.ctx.currentTime + duration);
    }
    playNoise(duration, vol = 1) {
        const bufferSize = this.ctx.sampleRate * duration;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        noise.connect(gain); gain.connect(this.masterGain); noise.start();
    }
    shootPistol() { this.playTone(600, 'sawtooth', 0.1, 0.5); this.playNoise(0.1, 0.3); }
    shootShotgun() { this.playTone(200, 'square', 0.3, 0.6); this.playNoise(0.3, 0.6); }
    enemyHit() { this.playTone(100, 'sawtooth', 0.1, 0.5); }
    playerHurt() { this.playTone(50, 'sawtooth', 0.3, 0.8); }
    click() { this.playTone(800, 'sine', 0.05, 0.3); }
    loot() { this.playTone(1200, 'square', 0.1, 0.2); this.playTone(1600, 'square', 0.1, 0.2); }
    toggleNVG() { this.playTone(2000, 'sine', 0.2, 0.1); }
    reload() { this.playTone(400, 'triangle', 0.2, 0.4); }
    logFound() { this.playTone(400, 'sine', 0.1, 0.5); this.playTone(600, 'sine', 0.3, 0.5); } 
}
const sfx = new SoundManager();

// --- 1. MAIN MENU SCENE ---
class MainMenuScene extends Phaser.Scene {
    constructor() { super('MainMenuScene'); }
    create() {
        this.input.on('pointerdown', () => sfx.resume());
        this.add.rectangle(400, 300, 800, 600, 0x111111);
        this.add.grid(400, 300, 800, 600, 64, 64, 0x222222).setAlpha(0.2);
        this.add.text(400, 100, "ZOMBIE EXTRACTION", { fontSize: '64px', fill: '#00ff00', fontStyle: 'bold' }).setOrigin(0.5);
        this.add.text(400, 160, "BUILD 9.2 (LORE UPDATE)", { fontSize: '24px', fill: '#555' }).setOrigin(0.5);

        this.createButton(400, 250, "NEW RUN", 0x880000, () => {
            if(confirm("Start a new run? This overwrites current auto-save.")) {
                localStorage.removeItem(SAVE_KEY);
                this.scene.start('GameScene', { level: 1, stats: JSON.parse(JSON.stringify(DEFAULT_STATS)) });
            }
        });

        this.createButton(400, 320, "CONTINUE", 0x004488, () => {
            let saved = localStorage.getItem(SAVE_KEY);
            if (saved) {
                let stats = JSON.parse(saved);
                if(!stats.logs) stats.logs = []; 
                this.scene.start('HideoutScene', { stats: stats });
            } else { alert("No save found!"); }
        });

        this.createButton(400, 420, "EXPORT SAVE", 0x444444, () => {
            let saved = localStorage.getItem(SAVE_KEY);
            if (!saved) return;
            const blob = new Blob([saved], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = `zombie_save_v9.json`;
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
        });

        this.createButton(400, 490, "IMPORT SAVE", 0x444444, () => {
            const input = document.createElement('input');
            input.type = 'file'; input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const json = JSON.parse(event.target.result);
                        if (json.hp !== undefined) {
                            if(!json.logs) json.logs = [];
                            localStorage.setItem(SAVE_KEY, JSON.stringify(json));
                            alert("Imported!");
                        }
                    } catch (err) {}
                };
                reader.readAsText(file);
            };
            input.click();
        });

        const cheatBtn = this.add.text(10, 570, "[ CHEAT CODE ]", { fontSize: '16px', fill: '#444' }).setInteractive();
        cheatBtn.on('pointerdown', () => {
            sfx.click();
            if (prompt("CODE:") === 'god mode') {
                const god = JSON.parse(JSON.stringify(DEFAULT_STATS));
                god.hp=20; god.maxHp=20; god.ammo=999; god.scrap=999; god.hasShotgun=true; god.hasFlashlight=true; god.hideout.armory.hasNVG=true;
                god.logs = [1,2,3];
                localStorage.setItem(SAVE_KEY, JSON.stringify(god));
                this.scene.start('HideoutScene', { stats: god });
            }
        });
    }
    createButton(x, y, text, color, callback) {
        let btn = this.add.rectangle(x, y, 350, 50, color).setInteractive();
        this.add.text(x, y, text, { fontSize: '24px', fill: '#fff' }).setOrigin(0.5);
        btn.on('pointerdown', () => { sfx.click(); callback(); });
    }
}

// --- 2. GAME CLASSES ---
class Bullet extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y) { super(scene, x, y, 'bullet'); }
    fire(x, y, targetX, targetY, spreadAngle = 0, isEnemy = false) {
        this.body.reset(x, y); this.body.enable = true; 
        this.setActive(true); this.setVisible(true);
        this.hasHit = false; this.isEnemyBullet = isEnemy; 
        this.setTint(isEnemy ? 0xff0000 : 0xffff00);
        if(!isEnemy) { /* handled by input */ } else { sfx.shootPistol(); }
        let baseAngle = Phaser.Math.Angle.Between(x, y, targetX, targetY);
        let finalAngle = baseAngle + Phaser.Math.DegToRad(spreadAngle);
        this.scene.physics.velocityFromRotation(finalAngle, 500, this.body.velocity);
        this.setRotation(finalAngle);
    }
    preUpdate(time, delta) {
        super.preUpdate(time, delta);
        if (this.y < -50 || this.y > 650 || this.x < -50 || this.x > 850) { this.destroy(); }
    }
}

class Enemy extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y, target, type) {
        super(scene, x, y, type === 'leaper' ? 'leaper' : (type === 'bandit' ? 'bandit' : 'zombie'));
        scene.add.existing(this); scene.physics.add.existing(this);
        this.target = target; this.enemyType = type; this.canTakeDamage = true; this.lastFired = 0;
        this.healthBar = scene.add.graphics().setDepth(100).setVisible(false);
        if (type === 'boss') { this.setScale(3); this.setTint(0xff0000); this.hp=5; this.maxHp=5; this.speed=85; this.damage=10; }
        else if (type === 'leaper') { this.hp=1; this.maxHp=1; this.speed=110; this.damage=2; this.state='CHASE'; this.leapTimer=0; }
        else if (type === 'bandit') { this.hp=3; this.maxHp=3; this.speed=90; this.damage=1; this.ammo=10; this.state='CHASE'; }
        else { this.hp=2; this.maxHp=2; this.speed=60; this.damage=2; }
    }
    takeDamage(amount) {
        if (!this.active || !this.canTakeDamage) return;
        this.hp -= amount; sfx.enemyHit(); this.setTint(0xffffff);
        this.scene.time.delayedCall(50, () => { if (this.active) this.clearTint(); });
        this.updateHealthBar();
        if (this.enemyType === 'boss') { this.scene.updateBossBar(this.hp, this.maxHp); this.canTakeDamage = false; this.scene.time.delayedCall(500, ()=>{if(this.active)this.canTakeDamage=true;}); }
        if (this.hp <= 0) {
            if (this.enemyType === 'boss') this.scene.spawnSwitch(this.x, this.y);
            this.scene.spawnLootSkull(this.x, this.y, this.enemyType);
            this.destroy();
        }
    }
    updateHealthBar() {
        if (this.hp <= 0) { this.healthBar.setVisible(false); return; }
        this.healthBar.setVisible(true); this.healthBar.clear();
        this.healthBar.fillStyle(0xff0000); this.healthBar.fillRect(this.x-20, this.y-40, 40, 6);
        this.healthBar.fillStyle(0x00ff00); this.healthBar.fillRect(this.x-20, this.y-40, 40 * (this.hp / this.maxHp), 6);
    }
    knockBack() {
        if(this.enemyType==='leaper'){this.state='COOLDOWN'; this.leapTimer=2000;}
        const angle = Phaser.Math.Angle.Between(this.target.x, this.target.y, this.x, this.y);
        this.scene.physics.velocityFromRotation(angle, this.enemyType==='leaper'?250:100, this.body.velocity);
    }
    update(time, delta) {
        if (!this.active) return;
        if (this.healthBar) this.healthBar.setPosition(0,0);
        
        if (this.enemyType === 'bandit') {
            const dist = Phaser.Math.Distance.Between(this.x, this.y, this.target.x, this.target.y);
            if (this.ammo > 0) {
                if (dist < 350) {
                    this.setVelocity(0);
                    if (time - this.lastFired > 2000) {
                        const b = this.scene.bullets.get(this.x, this.y);
                        if(b) { b.fire(this.x, this.y, this.target.x, this.target.y, Phaser.Math.Between(-5,5), true); this.ammo--; this.lastFired=time; }
                    }
                } else { this.scene.physics.moveToObject(this, this.target, this.speed); }
            } else { this.scene.physics.moveToObject(this, this.target, 120); }
            return;
        }
        if (this.enemyType === 'leaper') {
            const dist = Phaser.Math.Distance.Between(this.x, this.y, this.target.x, this.target.y);
            if(this.state==='CHASE'){ this.scene.physics.moveToObject(this, this.target, 110); if(dist<180){this.state='PREPARE'; this.setVelocity(0); this.setTint(0xffaa00); this.leapTimer=500;} }
            else if(this.state==='PREPARE'){ this.leapTimer-=delta; if(this.leapTimer<=0){this.state='LEAP'; this.clearTint(); this.scene.physics.moveToObject(this, this.target, 450); this.leapTimer=600;} }
            else if(this.state==='LEAP'){ this.leapTimer-=delta; if(this.leapTimer<=0){this.state='COOLDOWN'; this.setVelocity(0); this.leapTimer=1500;} }
            else if(this.state==='COOLDOWN'){ this.leapTimer-=delta; if(this.leapTimer<=0) this.state='CHASE'; }
            return;
        }
        this.scene.physics.moveToObject(this, this.target, this.speed);
    }
    destroy(fromScene) { if (this.healthBar) this.healthBar.destroy(); super.destroy(fromScene); }
}

// --- 3. HIDEOUT SCENE ---
class HideoutScene extends Phaser.Scene {
    constructor() { super('HideoutScene'); }
    create(data) {
        this.stats = data.stats;
        localStorage.setItem(SAVE_KEY, JSON.stringify(this.stats));
        this.add.rectangle(400, 300, 800, 600, 0x1a1a1a);
        this.add.grid(400, 300, 800, 600, 32, 32, 0x222222).setAlpha(0.5);
        this.add.text(40, 40, "THE HIDEOUT", { fontSize: '48px', fill: '#00ff00', fontStyle: 'bold' });
        this.statText = this.add.text(40, 100, "", { fontSize: '18px', fill: '#cccccc' });
        this.updateStatText();
        
        // Cards
        this.createUpgradeCard(40, 200, "REST AREA", () => `LVL: ${this.stats.hideout.restAreaLvl}`, () => {
            if(this.stats.scrap >= (this.stats.hideout.restAreaLvl+1)*5) {
                this.stats.scrap -= (this.stats.hideout.restAreaLvl+1)*5; this.stats.hideout.restAreaLvl++;
                if(this.stats.hideout.restAreaLvl>0) this.stats.hp=this.stats.maxHp;
                if(this.stats.hideout.restAreaLvl>1) this.stats.maxHp+=2;
                this.updateStatText(); return true;
            } return false;
        }, () => `UPGRADE (${(this.stats.hideout.restAreaLvl+1)*5} S)`);

        this.createUpgradeCard(270, 200, "GENERATOR", () => this.stats.hideout.generatorLvl===0?"Offline":"Online", () => {
            if(this.stats.hideout.generatorLvl===0 && this.stats.scrap>=10 && this.stats.hideout.hasSparkPlug) {
                this.stats.scrap-=10; this.stats.hideout.generatorLvl=1; this.stats.hideout.hasSparkPlug=false; this.stats.hasFlashlight=true;
                this.updateStatText(); return true;
            } return false;
        }, () => this.stats.hideout.generatorLvl===0?"BUILD (10 S + PLUG)":"MAX");

        const ax = 500, ay = 200;
        this.add.rectangle(ax+100, ay+75, 220, 160, 0x333333).setStrokeStyle(2, 0x555555);
        this.add.text(ax+10, ay+10, "ARMORY", {fontSize:'20px', fill:'#ff00ff'});
        this.armoryDesc = this.add.text(ax+10, ay+40, "", {fontSize:'14px', fill:'#aaa'});
        this.armoryBtn = this.add.rectangle(ax+100, ay+130, 200, 30, 0x555555).setInteractive();
        this.armoryBtnText = this.add.text(ax+100, ay+130, "", {fontSize:'14px', fill:'#fff'}).setOrigin(0.5);
        this.updateArmoryUI();
        
        this.armoryBtn.on('pointerdown', () => {
            sfx.click();
            if(this.stats.hideout.armory.hasNVG) return;
            if(this.stats.hideout.armory.crafting && Date.now() >= this.stats.hideout.armory.crafting.finishTime) {
                this.stats.hideout.armory.hasNVG=true; this.stats.hideout.armory.crafting=null; this.updateArmoryUI();
            } else if(!this.stats.hideout.armory.crafting && this.stats.scrap >= 3) {
                this.stats.scrap-=3; this.stats.hideout.armory.crafting={finishTime: Date.now()+90000}; this.updateStatText(); this.updateArmoryUI();
            }
        });

        // Logs Display in Hideout (Simple list)
        this.add.text(40, 450, "DATA LOGS:", { fontSize: '24px', fill: '#00ccff' });
        let logY = 480;
        if(this.stats.logs.length === 0) this.add.text(40, logY, "No data collected.", {fontSize:'14px', fill:'#555'});
        else {
            this.stats.logs.forEach(id => {
                this.add.text(40, logY, `> ${LORE_DATA[id].title}`, {fontSize:'14px', fill:'#00ccff'});
                logY+=20;
            });
        }

        this.add.rectangle(650, 500, 200, 60, 0x008800).setInteractive().on('pointerdown', () => {
            sfx.click();
            if(this.stats.hideout.restAreaLvl>0) this.stats.hp = Math.min(this.stats.hp + (this.stats.hideout.restAreaLvl>=2?this.stats.maxHp:5), this.stats.maxHp);
            this.scene.start('GameScene', {level:1, stats:this.stats});
        });
        
        this.add.rectangle(100, 550, 150, 40, 0x444444).setInteractive().on('pointerdown', () => {
            sfx.click(); this.scene.start('MainMenuScene');
        });
    }
    update() {
        if(this.stats.hideout.armory.crafting && !this.stats.hideout.armory.hasNVG) {
            let rem = this.stats.hideout.armory.crafting.finishTime - Date.now();
            if(rem <= 0) { this.armoryDesc.setText("FINISHED!"); this.armoryBtnText.setText("CLAIM NVG"); }
            else { this.armoryDesc.setText(`Crafting... ${Math.ceil(rem/1000)}s`); this.armoryBtnText.setText("WAIT"); }
        }
    }
    updateArmoryUI() {
        if(this.stats.hideout.armory.hasNVG) { this.armoryDesc.setText("NVG UNLOCKED"); this.armoryBtnText.setText("EQUIPPED"); }
        else if(!this.stats.hideout.armory.crafting) { this.armoryDesc.setText("Craft NVG (3 Scrap)"); this.armoryBtnText.setText("CRAFT"); }
    }
    updateStatText() { this.statText.setText(`HP:${this.stats.hp}/${this.stats.maxHp} AMMO:${this.stats.ammo} SCRAP:${this.stats.scrap}`); }
    createUpgradeCard(x, y, title, descFn, actionFn, costFn) {
        this.add.rectangle(x+100, y+75, 220, 160, 0x333333).setStrokeStyle(2, 0x555555);
        this.add.text(x+10, y+10, title, {fontSize:'20px', fill:'#ffff00'});
        let d = this.add.text(x+10, y+40, descFn(), {fontSize:'14px', fill:'#aaa'});
        let b = this.add.rectangle(x+100, y+130, 200, 30, 0x555555).setInteractive();
        let bt = this.add.text(x+100, y+130, costFn(), {fontSize:'14px', fill:'#fff'}).setOrigin(0.5);
        b.on('pointerdown', () => { if(actionFn()) { sfx.click(); d.setText(descFn()); bt.setText(costFn()); } });
    }
}

// --- 4. GAME SCENE ---
class GameScene extends Phaser.Scene {
    constructor() { super('GameScene'); }
    preload() {
        const g = this.make.graphics({x:0, y:0, add:false});
        const gen = (c, w, h, k) => { g.clear(); g.fillStyle(c,1); g.fillRect(0,0,w,h); g.generateTexture(k,w,h); };
        gen(0x00ff00,32,32,'player'); gen(0x8B4513,32,32,'crate'); gen(0x663399,32,32,'zombie');
        gen(0xFF4500,32,32,'leaper'); gen(0x0000FF,32,32,'bandit'); gen(0xffff00,8,8,'bullet');
        gen(0xFFD700,40,60,'door'); gen(0x555555,32,32,'wall'); gen(0x333333,60,60,'debris'); gen(0x00ff00,30,30,'switch');
        
        // Items
        gen(0xff0000,20,20,'pickup_hp'); gen(0x0088ff,20,20,'pickup_stamina');
        // Lore Disk
        g.clear(); g.fillStyle(0x0088ff, 1); g.fillRect(0,0,24,24); g.fillStyle(0xffffff,1); g.fillRect(4,4,16,10); g.generateTexture('disk', 24, 24);

        g.clear(); g.fillStyle(0xEAEAEA, 1); g.fillCircle(16,14,11); g.fillRect(10,20,12,8); g.fillStyle(0,1); g.fillCircle(12,14,3.5); g.fillCircle(20,14,3.5); g.generateTexture('skull',32,32);
    }
    create(data) {
        this.currentLevel = data.level || 1;
        this.playerStats = data.stats || JSON.parse(JSON.stringify(DEFAULT_STATS));
        if(!this.playerStats.logs) this.playerStats.logs = [];
        this.checkpointStats = JSON.parse(JSON.stringify(this.playerStats));
        this.hasKey = false; this.hasMolotov = false; this.isPaused = false; this.isInventoryOpen = false; this.nvgOn = false;
        this.extractionTimer = 15; this.extractionActive = false;
        this.lastFired = 0; this.invMode = 'GEAR'; // 'GEAR' or 'LOGS'

        this.bullets = this.physics.add.group({ classType: Bullet, runChildUpdate: true });
        this.enemies = this.add.group();
        this.pickups = this.physics.add.staticGroup();
        this.crates = this.physics.add.staticGroup();
        this.walls = this.physics.add.staticGroup();
        this.debris = this.physics.add.staticGroup();
        this.skulls = this.physics.add.staticGroup();
        this.switches = this.physics.add.staticGroup();
        this.disks = this.physics.add.staticGroup(); // Lore Items

        this.add.tileSprite(400, 300, 800, 600, this.currentLevel===1?'floor_grass':(this.currentLevel===2?'floor_apt':'floor_roof')); 
        
        // --- FIX: PLAYER CREATED BEFORE ENTITIES ---
        this.player = this.physics.add.sprite(400, 550, 'player').setCollideWorldBounds(true).setDepth(10);
        // ------------------------------------------

        // Spawn Entities & Lore
        if(this.currentLevel===1) {
            this.door = this.physics.add.staticSprite(400, 50, 'door');
            this.walls.create(200, 200, 'wall').setScale(1, 4).refreshBody();
            this.walls.create(600, 200, 'wall').setScale(1, 4).refreshBody();
            this.spawnEnemy('walker', 100, 300); this.spawnEnemy('bandit', 700, 300); this.spawnEnemy('leaper', 200, 200);
            this.spawnCrates(['key','flashlight','shotgun','ammo','scrap']);
            if(!this.playerStats.logs.includes(1)) this.disks.create(100, 500, 'disk').setData('id', 1);
        } else if(this.currentLevel===2) {
            this.door = this.physics.add.staticSprite(400, 50, 'door').setTint(0x0000ff);
            this.debrisBlock = this.debris.create(400, 100, 'debris');
            this.walls.create(250, 300, 'wall').setScale(1, 15).refreshBody();
            this.walls.create(550, 300, 'wall').setScale(1, 15).refreshBody();
            this.spawnEnemy('bandit', 100, 100); this.spawnEnemy('bandit', 700, 100); this.spawnEnemy('leaper', 400, 450);
            this.spawnCrates(['molotov','ammo','meds','scrap','plug']);
            if(!this.playerStats.logs.includes(2)) this.disks.create(400, 300, 'disk').setData('id', 2);
        } else {
            this.spawnEnemy('boss', 400, 100); this.spawnEnemy('bandit', 100, 500); this.spawnEnemy('bandit', 700, 500);
            this.spawnCrates(['ammo','meds','scrap']);
            if(!this.playerStats.logs.includes(3)) this.disks.create(750, 500, 'disk').setData('id', 3);
        }

        // Collisions
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.player, this.crates);
        this.physics.add.collider(this.player, this.debris);
        this.physics.add.collider(this.enemies, this.walls);
        this.physics.add.collider(this.enemies, this.crates);
        this.physics.add.collider(this.bullets, this.walls, (b) => b.destroy());
        this.physics.add.collider(this.bullets, this.crates, (b) => b.destroy());
        this.physics.add.overlap(this.bullets, this.enemies, (b, e) => {
            if(b.active && e.active && !b.isEnemyBullet) { b.destroy(); e.takeDamage(1); }
        });
        this.physics.add.overlap(this.bullets, this.player, (p, b) => {
            if(b.active && b.isEnemyBullet) { b.destroy(); this.hitPlayer(1); }
        });
        this.physics.add.overlap(this.player, this.enemies, (p, e) => {
            if(!e.active) return;
            if(e.enemyType==='leaper' && e.state==='LEAP') this.triggerKnockdown(e);
            else if(e.enemyType!=='bandit') this.hitPlayer(e.damage);
        });
        
        this.cursors = this.input.keyboard.createCursorKeys();
        this.wasd = this.input.keyboard.addKeys({ up:87, down:83, left:65, right:68, shift:16 });
        this.keys = this.input.keyboard.addKeys({ interact:70, space:32, esc:27, switch:81, inv: 73, tab: 9, nvg: 78, melee:69 });
        this.input.on('pointerdown', (p) => this.fireBullet(p));
        
        // UI
        this.createInventoryUI();
        this.uiGraphics = this.add.graphics().setDepth(100);
        this.uiText = this.add.text(10, 65, '', { font: '16px Arial', fill: '#fff' }).setDepth(100);
        this.levelText = this.add.text(400, 300, `LEVEL ${this.currentLevel}`, {fontSize:'64px', fill:'#fff'}).setOrigin(0.5).setDepth(100).setAlpha(0);
        this.tweens.add({targets:this.levelText, alpha:1, yoyo:true, duration:2000});
        this.bossBar = this.add.graphics().setDepth(100);

        // Lighting
        this.lightShape = this.make.graphics({ x: 0, y: 0, add: false });
        this.darkness = this.add.rectangle(400, 300, 800, 600, 0x000000, 0.95).setDepth(90);
        this.darkness.setMask(this.lightShape.createGeometryMask().setInvertAlpha(true));
        this.nvgLayer = this.add.rectangle(400, 300, 800, 600, 0x00ff00, 0.2).setDepth(95).setVisible(false);
    }

    createInventoryUI() {
        this.invContainer = this.add.container(400, 300).setDepth(300).setVisible(false);
        this.invContainer.add(this.add.rectangle(0,0,600,450,0x111111,0.95).setStrokeStyle(4,0x444444));
        this.invTitle = this.add.text(0, -200, "INVENTORY", {fontSize:'32px'}).setOrigin(0.5);
        this.invContainer.add(this.invTitle);
        
        // Mode Switch Buttons
        const btnGear = this.add.rectangle(-150, -150, 200, 40, 0x333333).setInteractive();
        const txtGear = this.add.text(-150, -150, "GEAR", {fontSize:'18px'}).setOrigin(0.5);
        btnGear.on('pointerdown', ()=>{this.invMode='GEAR'; this.updateInventoryUI();});
        
        const btnLogs = this.add.rectangle(150, -150, 200, 40, 0x333333).setInteractive();
        const txtLogs = this.add.text(150, -150, "LOGS", {fontSize:'18px'}).setOrigin(0.5);
        btnLogs.on('pointerdown', ()=>{this.invMode='LOGS'; this.updateInventoryUI();});
        
        this.invContainer.add([btnGear, txtGear, btnLogs, txtLogs]);
        
        this.invContent = this.add.text(-280, -100, "", {fontSize:'16px', wordWrap:{width:560}}).setOrigin(0,0);
        this.invContainer.add(this.invContent);
    }

    updateInventoryUI() {
        if(this.invMode === 'GEAR') {
            this.invContent.setText(
                `HP: ${this.playerStats.hp}/${this.playerStats.maxHp}\nAMMO: ${this.playerStats.ammo}\nSCRAP: ${this.playerStats.scrap}\n\n` +
                `WEAPON: ${this.playerStats.currentWeapon.toUpperCase()}\n` +
                `FLASHLIGHT: ${this.playerStats.hasFlashlight ? "YES" : "NO"}\n` +
                `NVG: ${this.playerStats.hideout.armory.hasNVG ? "EQUIPPED" : "NO"}`
            );
        } else {
            let txt = "ENCRYPTED LOGS:\n\n";
            if(this.playerStats.logs.length === 0) txt += "No data found.";
            else {
                this.playerStats.logs.forEach(id => {
                    let entry = LORE_DATA[id];
                    txt += `[${entry.title}]\n${entry.text}\n\n`;
                });
            }
            this.invContent.setText(txt);
        }
    }

    toggleInventory() {
        this.isInventoryOpen = !this.isInventoryOpen;
        this.invContainer.setVisible(this.isInventoryOpen);
        if(this.isInventoryOpen) {
            this.physics.pause(); this.isPaused = true; this.updateInventoryUI(); sfx.click();
        } else { this.physics.resume(); this.isPaused = false; sfx.click(); }
    }

    update(time, delta) {
        if(Phaser.Input.Keyboard.JustDown(this.keys.tab) || Phaser.Input.Keyboard.JustDown(this.keys.inv)) this.toggleInventory();
        if(Phaser.Input.Keyboard.JustDown(this.keys.esc)) { if(this.isInventoryOpen) this.toggleInventory(); else this.isPaused=!this.isPaused; }
        if(this.isPaused || this.isInventoryOpen) return;
        
        // Input
        let speed = (this.cursors.shift.isDown || this.wasd.shift.isDown) ? 280 : 160;
        let vx=0, vy=0;
        if(this.cursors.left.isDown || this.wasd.left.isDown) vx=-1; else if(this.cursors.right.isDown || this.wasd.right.isDown) vx=1;
        if(this.cursors.up.isDown || this.wasd.up.isDown) vy=-1; else if(this.cursors.down.isDown || this.wasd.down.isDown) vy=1;
        if(vx||vy){ const m=Math.sqrt(vx*vx+vy*vy); this.player.setVelocity((vx/m)*speed, (vy/m)*speed); } else this.player.setVelocity(0);

        if(Phaser.Input.Keyboard.JustDown(this.keys.interact)) this.tryInteract();
        if(Phaser.Input.Keyboard.JustDown(this.keys.switch)) this.switchWeapon();
        if(Phaser.Input.Keyboard.JustDown(this.keys.nvg)) this.toggleNVG();
        if(Phaser.Input.Keyboard.JustDown(this.keys.melee)) this.meleeAttack();

        this.drawUI();
        this.enemies.getChildren().forEach(e => e.update(time, delta));
        
        // Light
        this.lightShape.clear(); this.lightShape.fillCircle(this.player.x, this.player.y, 60);
        if(this.playerStats.hasFlashlight) {
            const a = Phaser.Math.Angle.Between(this.player.x, this.player.y, this.input.activePointer.x, this.input.activePointer.y);
            this.lightShape.fillStyle(0xffffff); this.lightShape.slice(this.player.x, this.player.y, 300, a-0.5, a+0.5); this.lightShape.fill();
        }
    }

    spawnCrates(loot) {
        loot.forEach(l => {
            let x=Phaser.Math.Between(50,750), y=Phaser.Math.Between(50,550);
            this.crates.create(x, y, 'crate').setData('lootID', l);
        });
    }
    spawnEnemy(type, x, y) { this.enemies.add(new Enemy(this, x, y, this.player, type)); }
    spawnSwitch(x, y) { this.switches.create(x, y, 'switch'); this.switchDropped=true; }
    spawnLootSkull(x, y, type) { this.skulls.create(x, y, 'skull').setData('lootID', 'scrap'); }
    
    fireBullet(pointer) {
        if(this.playerStats.ammo<=0 || this.time.now - this.lastFired < (this.playerStats.currentWeapon==='shotgun'?1000:300)) return;
        if(this.isInventoryOpen || this.isPaused) return;
        this.lastFired = this.time.now; this.playerStats.ammo -= (this.playerStats.currentWeapon==='shotgun'?2:1);
        sfx[this.playerStats.currentWeapon==='shotgun'?'shootShotgun':'shootPistol']();
        for(let i=(this.playerStats.currentWeapon==='shotgun'?-10:0); i<=(this.playerStats.currentWeapon==='shotgun'?10:0); i+=5) {
            const b = this.bullets.get(this.player.x, this.player.y);
            if(b) b.fire(this.player.x, this.player.y, pointer.x, pointer.y, i);
        }
        this.cameras.main.shake(100, 0.005);
    }
    
    switchWeapon() { if(this.playerStats.hasShotgun) { this.playerStats.currentWeapon = this.playerStats.currentWeapon==='pistol'?'shotgun':'pistol'; sfx.reload(); } }
    toggleNVG() {
        if(this.playerStats.hideout.armory.hasNVG) {
            this.nvgOn = !this.nvgOn; sfx.toggleNVG();
            this.nvgLayer.setVisible(this.nvgOn); this.darkness.setVisible(!this.nvgOn);
        }
    }
    meleeAttack() {
        const slash = this.add.sprite(this.player.x, this.player.y, 'slash').setTint(0xffffff).setDepth(20);
        const angle = Phaser.Math.Angle.Between(this.player.x, this.player.y, this.input.activePointer.x, this.input.activePointer.y);
        slash.setRotation(angle);
        const vec = this.physics.velocityFromRotation(angle, 40);
        slash.setPosition(this.player.x + vec.x, this.player.y + vec.y);
        this.tweens.add({ targets: slash, alpha: 0, duration: 200, onComplete: () => slash.destroy() });
        this.enemies.getChildren().forEach(e => {
            if (e.active && Phaser.Math.Distance.Between(slash.x, slash.y, e.x, e.y) < 60) e.takeDamage(2);
        });
    }

    tryInteract() {
        if(this.currentLevel===2 && this.checkDebris()) return;
        if(this.currentLevel===3 && this.switchDropped && Phaser.Math.Distance.Between(this.player.x,this.player.y,this.switches.getFirstAlive().x,this.switches.getFirstAlive().y)<60) { this.winGame(); return; }
        if(Phaser.Math.Distance.Between(this.player.x, this.player.y, this.door.x, this.door.y)<60) { this.nextLevel(); return; }
        
        let item = null, minDst = 60;
        this.crates.getChildren().concat(this.skulls.getChildren(), this.disks.getChildren()).forEach(i => {
            let d = Phaser.Math.Distance.Between(this.player.x, this.player.y, i.x, i.y);
            if(i.active && d < minDst) { item=i; minDst=d; }
        });
        if(item) {
            if(item.texture.key === 'disk') {
                this.collectLog(item);
            } else {
                sfx.loot(); this.applyLoot(item.getData('lootID')); item.destroy();
            }
        }
    }

    collectLog(disk) {
        let id = disk.getData('id');
        disk.destroy();
        sfx.logFound();
        if(!this.playerStats.logs.includes(id)) {
            this.playerStats.logs.push(id);
            this.showFloatingText(this.player.x, this.player.y, "DATA LOG ACQUIRED", 0x00ccff);
        } else {
            this.showFloatingText(this.player.x, this.player.y, "ALREADY READ", 0x555555);
        }
    }

    checkDebris() {
        if(this.debrisBlock && this.debrisBlock.active && Phaser.Math.Distance.Between(this.player.x, this.player.y, this.debrisBlock.x, this.debrisBlock.y)<80) {
            if(this.hasMolotov) { this.debrisBlock.destroy(); return true; }
        } return false;
    }
    applyLoot(id) {
        if(id==='meds') this.playerStats.hp = Math.min(this.playerStats.hp+5, this.playerStats.maxHp);
        else if(id==='ammo') this.playerStats.ammo += 5;
        else if(id==='scrap') this.playerStats.scrap += 5;
        else if(id==='molotov') this.hasMolotov = true;
        else if(id==='shotgun') this.playerStats.hasShotgun = true;
        else if(id==='plug') this.playerStats.hideout.hasSparkPlug = true;
        this.showFloatingText(this.player.x, this.player.y-50, id.toUpperCase(), 0x00ff00);
    }
    showFloatingText(x, y, msg, color) { let t = this.add.text(x, y, msg, {font:'16px Arial', stroke:'#000', strokeThickness:3}).setTint(color).setOrigin(0.5).setDepth(101); this.tweens.add({ targets:t, y:y-50, alpha:0, duration:1500, onComplete:()=>t.destroy() }); }
    hitPlayer(damage) {
        this.playerStats.hp -= damage; sfx.playerHurt(); this.cameras.main.shake(100,0.01);
        if(this.playerStats.hp<=0) this.scene.restart({level:this.currentLevel, stats:this.checkpointStats});
    }
    nextLevel() { this.scene.restart({level:this.currentLevel+1, stats:this.playerStats}); }
    winGame() { this.scene.start('HideoutScene', {stats:this.playerStats}); }
    
    drawUI() {
        this.uiGraphics.clear();
        this.uiGraphics.fillStyle(0x000000, 0.5); this.uiGraphics.fillRect(10, 10, 204, 24);
        this.uiGraphics.fillStyle(0xff0000, 1); this.uiGraphics.fillRect(12, 12, 200 * (this.playerStats.hp/this.playerStats.maxHp), 20);
        let weaponName = this.playerStats.currentWeapon.toUpperCase();
        this.uiText.setText(`AMMO: ${this.playerStats.ammo} | SCRAP: ${this.playerStats.scrap} | ${weaponName}`);
    }
    triggerKnockdown(e) { this.hitPlayer(2); e.knockBack(); } // Simplified
}

const config = { type: Phaser.AUTO, width: 800, height: 600, backgroundColor: '#000000', parent: 'game-container', 
physics: { default: 'arcade', arcade: { gravity: { y: 0 } } }, scene: [MainMenuScene, GameScene, HideoutScene], 
scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH } };
const game = new Phaser.Game(config);
</script>
</body>
</html>
