<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zombies - Build 24.1 (Streamlined UI)</title>
    <style>
        body { margin: 0; padding: 0; background-color: #000000; overflow: hidden; }
        canvas { display: block; margin: 0 auto; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>
<body>
<script>

// =============================================================================
// CONFIGURATION - All magic numbers centralized here
// =============================================================================
const CONFIG = {
    // Save system
    SAVE_KEY: 'zombie_save_v17',
    SETTINGS_KEY: 'zombie_settings_v17',
    
    // Player settings
    PLAYER: {
        WALK_SPEED: 160,
        SPRINT_SPEED: 280,
        STAMINA_DRAIN: 0.5,
        STAMINA_REGEN: 0.2,
        INVULN_TIME: 1000,
        MELEE_COOLDOWN: 500,
        MELEE_RANGE: 60,
        MELEE_DAMAGE: 2,
        LIGHT_RADIUS: 60,
        FLASHLIGHT_RANGE: 300,
        FLASHLIGHT_ANGLE: 0.5,
        // Dodge roll settings
        DODGE_SPEED: 400,
        DODGE_DURATION: 200,
        DODGE_COOLDOWN: 800,
        DODGE_STAMINA_COST: 20,
        // Low HP threshold for vignette
        LOW_HP_THRESHOLD: 0.3
    },
    
    // Weapon settings
    WEAPONS: {
        PISTOL: {
            FIRE_RATE: 300,
            AMMO_COST: 1,
            SPREAD: 0,
            MAG_SIZE: 12,
            RELOAD_TIME: 1000
        },
        SHOTGUN: {
            FIRE_RATE: 1000,
            AMMO_COST: 2,
            PELLETS: 5,
            SPREAD_STEP: 5,
            MAG_SIZE: 6,
            RELOAD_TIME: 1500
        },
        SMG: {
            FIRE_RATE: 100,
            AMMO_COST: 1,
            SPREAD: 8,
            MAG_SIZE: 30,
            RELOAD_TIME: 1800
        },
        CROSSBOW: {
            FIRE_RATE: 1500,      // Slow reload between shots
            AMMO_COST: 1,
            DAMAGE: 3,            // High damage (one-shots walkers)
            MAG_SIZE: 1,          // Single bolt
            RELOAD_TIME: 2000,
            PIERCING: true,       // Passes through first target
            SILENT: true          // Doesn't alert nearby enemies
        },
        RIFLE: {
            FIRE_RATE: 200,       // Medium rate
            AMMO_COST: 1,
            DAMAGE: 1.5,          // Slightly higher than pistol
            SPREAD: 3,            // Tight spread
            MAG_SIZE: 25,
            RELOAD_TIME: 1500,
            FIRST_SHOT_BONUS: true // Extra accuracy when stationary
        },
        BULLET_SPEED: 500
    },
    
    // Enemy configurations
    ENEMIES: {
        WALKER: {
            HP: 2,
            SPEED: 60,
            DAMAGE: 2,
            AGGRO_RANGE: 300,
            TEXTURE: 'zombie'
        },
        LEAPER: {
            HP: 1,
            SPEED: 110,
            DAMAGE: 2,
            LEAP_RANGE: 180,
            LEAP_SPEED: 450,
            PREPARE_TIME: 500,
            LEAP_DURATION: 600,
            COOLDOWN_TIME: 1500,
            KNOCKBACK_SPEED: 250,
            TEXTURE: 'leaper_idle_0'
        },
        BANDIT: {
            HP: 3,
            SPEED: 90,
            DAMAGE: 1,
            AMMO: 10,
            FIRE_RANGE: 350,
            FIRE_RATE: 2000,
            MELEE_SPEED: 120,
            SPREAD: 5,
            TEXTURE: 'bandit'
        },
        BOSS: {
            HP: 5,
            SPEED: 85,
            DAMAGE: 10,
            SCALE: 3,
            INVULN_TIME: 500,
            TEXTURE: 'zombie'
        },
        SPITTER: {
            HP: 2,
            SPEED: 50,
            DAMAGE: 1,
            SPIT_RANGE: 280,
            SPIT_COOLDOWN: 2500,
            SPIT_SPEED: 200,
            TEXTURE: 'spitter'
        },
        EXPLODER: {
            HP: 2,
            SPEED: 100,           // Fast
            DAMAGE: 3,            // Explosion damage to player
            EXPLOSION_RADIUS: 80,
            ENEMY_DAMAGE: 5,      // Damage to other enemies (chain reactions!)
            TEXTURE: 'zombie'     // Reuse zombie texture with orange tint
        },
        NECROMANCER: {
            HP: 8,
            SPEED: 60,
            DAMAGE: 2,
            SUMMON_COUNT: 4,        // Zombies per summon
            VULNERABLE_TIME: 10000, // 10 sec window
            PROJECTILE_SPEED: 150,
            PROJECTILE_DAMAGE: 2,
            TELEPORT_COOLDOWN: 5000,
            TEXTURE: 'zombie'     // Will use custom tint
        },
        KNOCKBACK_SPEED: 100
    },
    
    // Grenade settings
    GRENADE: {
        THROW_SPEED: 350,
        FUSE_TIME: 1500,
        EXPLOSION_RADIUS: 100,
        DAMAGE: 5,
        MAX_CARRY: 3
    },
    
    // Interaction distances
    DISTANCES: {
        INTERACT: 60,
        DEBRIS: 80,
        DOOR: 60
    },
    
    // Timings (in ms)
    TIMINGS: {
        CRATE_OPEN: 1000,
        DEBRIS_BURN: 5000,
        EXTRACTION: 15000,
        DEATH_RESTART: 2000,
        LEVEL_TRANSITION: 1000,
        NVG_CRAFT: 90000
    },
    
    // UI settings
    UI: {
        HP_BAR_WIDTH: 200,
        HP_BAR_HEIGHT: 20,
        STAMINA_BAR_WIDTH: 150,
        STAMINA_BAR_HEIGHT: 10,
        ICON_RADIUS: 12,
        ICON_SPACING: 30,
        // Hit direction indicator settings
        HIT_INDICATOR_DURATION: 500,
        HIT_INDICATOR_SIZE: 60,
        HIT_INDICATOR_DISTANCE: 80
    },
    
    // Loot tables
    LOOT: {
        BANDIT: ['ammo', 'ammo', 'scrap', 'meds', 'helmet', 'vest', 'grenade'],
        ZOMBIE: ['ammo', 'scrap', 'meds', 'ammo'],
        SPITTER: ['ammo', 'scrap', 'meds', 'grenade'],
        EXPLODER: ['ammo', 'scrap', 'grenade'],
        NECROMANCER: ['materials', 'materials', 'grenade', 'meds']
    },
    
    // Achievements
    ACHIEVEMENTS: {
        FIRST_BLOOD: { id: 'first_blood', name: 'First Blood', desc: 'Kill your first enemy', icon: 'üíÄ' },
        EXTERMINATOR: { id: 'exterminator', name: 'Exterminator', desc: 'Kill 50 enemies total', icon: '‚ò†Ô∏è' },
        SHARPSHOOTER: { id: 'sharpshooter', name: 'Sharpshooter', desc: 'Achieve 50% accuracy in a run', icon: 'üéØ' },
        MELEE_MASTER: { id: 'melee_master', name: 'Melee Master', desc: 'Kill a boss with melee only', icon: 'üó°Ô∏è' },
        SURVIVOR: { id: 'survivor', name: 'Survivor', desc: 'Complete your first extraction', icon: 'üèÜ' },
        VETERAN: { id: 'veteran', name: 'Veteran', desc: 'Complete 5 extractions', icon: '‚≠ê' },
        GRENADIER: { id: 'grenadier', name: 'Grenadier', desc: 'Kill 3 enemies with one grenade', icon: 'üí£' },
        UNTOUCHABLE: { id: 'untouchable', name: 'Untouchable', desc: 'Complete a level without taking damage', icon: 'üõ°Ô∏è' },
        SCAVENGER: { id: 'scavenger', name: 'Scavenger', desc: 'Collect 100 scrap total', icon: 'üîß' },
        FULLY_LOADED: { id: 'fully_loaded', name: 'Fully Loaded', desc: 'Own all weapons at once', icon: 'üî´' },
        // Class unlock achievements
        SCOUT_UNLOCK: { id: 'scout_unlock', name: 'Ghost Runner', desc: 'Complete any level without being hit', icon: 'üèÉ' },
        MEDIC_UNLOCK: { id: 'medic_unlock', name: 'Field Medic', desc: 'Heal 50 total HP across all runs', icon: 'üíä' },
        SCAVENGER_UNLOCK: { id: 'scavenger_unlock', name: 'Pack Rat', desc: 'Collect 500 total scrap', icon: 'üéí' }
    },
    
    // Hideout upgrade costs
    HIDEOUT: {
        WORKBENCH_COST: 15,
        WORKBENCH_DAMAGE_BONUS: 0.25, // +25% damage
        REPAIR_STATION_COST: 20,
        REPAIR_COST_PER_POINT: 1 // 1 scrap per durability point
    },
    
    // Currency system
    CURRENCIES: {
        SCRAP: { name: 'Scrap', icon: 'üîß', color: 0xaaaaaa },
        CREDITS: { name: 'Credits', icon: 'üí∞', color: 0xffd700 },
        MATERIALS: { name: 'Materials', icon: '‚öôÔ∏è', color: 0x00aaff }
    },
    
    // Trader configuration
    TRADER: {
        HIDEOUT_STOCK: [
            { id: 'ammo_bundle', name: 'Ammo Bundle', type: 'ammo', amount: 50, cost: 15, currency: 'credits' },
            { id: 'med_kit', name: 'Med Kit', type: 'heal', amount: 5, cost: 20, currency: 'credits' },
            { id: 'grenade', name: 'Grenade', type: 'grenade', amount: 1, cost: 25, currency: 'credits' },
            { id: 'adrenaline', name: 'Adrenaline Shot', type: 'consumable', effect: 'speed', cost: 30, currency: 'credits' },
            { id: 'armor_patch', name: 'Armor Patch', type: 'consumable', effect: 'repair', cost: 25, currency: 'credits' },
            // Weapon Mods - purchased with materials
            { id: 'extended_mag', name: 'Extended Mag', type: 'mod', cost: 15, currency: 'materials' },
            { id: 'suppressor', name: 'Suppressor', type: 'mod', cost: 20, currency: 'materials' },
            { id: 'laser_sight', name: 'Laser Sight', type: 'mod', cost: 25, currency: 'materials' },
            { id: 'damage_barrel', name: 'Damage Barrel', type: 'mod', cost: 30, currency: 'materials' },
            { id: 'rapid_fire', name: 'Rapid Fire', type: 'mod', cost: 25, currency: 'materials' }
        ],
        SELL_RATE: 0.5
    },
    
    // Consumables configuration
    CONSUMABLES: {
        adrenaline: { name: 'Adrenaline', effect: 'speed', multiplier: 1.5, duration: 10000, icon: 'üíâ' },
        armor_patch: { name: 'Armor Patch', effect: 'repair', amount: 20, duration: 0, icon: 'ü©π' }
    },
    
    // Enemy drop configuration (currency auto-collects, items go to skull)
    ENEMY_DROPS: {
        WALKER: { currency: 'scrap', min: 1, max: 3, items: ['ammo', 'meds'] },
        SPITTER: { currency: 'scrap', min: 2, max: 4, items: ['ammo', 'meds', 'grenade'] },
        BANDIT: { currency: 'credits', min: 5, max: 15, items: ['ammo', 'helmet', 'vest'] },
        BOSS: { currency: 'materials', min: 5, max: 15, items: ['grenade', 'meds', 'extended_mag', 'suppressor'] },
        LEAPER: { currency: 'scrap', min: 1, max: 2, items: ['ammo'] },
        EXPLODER: { currency: 'scrap', min: 2, max: 5, items: ['ammo', 'grenade'] },
        NECROMANCER: { currency: 'materials', min: 10, max: 20, items: ['grenade', 'meds', 'crossbow', 'damage_barrel', 'rapid_fire', 'laser_sight'] }
    },
    
    // Character classes
    CLASSES: {
        SURVIVOR: { id: 'survivor', name: 'Survivor', desc: 'No passive ability', passive: null, icon: 'üßç' },
        SCOUT: { id: 'scout', name: 'Scout', desc: '+20% speed, silent footsteps', passive: 'speed', icon: 'üèÉ' },
        MEDIC: { id: 'medic', name: 'Medic', desc: 'Regen 1 HP every 30s', passive: 'regen', icon: 'üíâ' },
        SCAVENGER: { id: 'scavenger', name: 'Scavenger', desc: '+50% loot drops', passive: 'loot', icon: 'üéí' }
    },
    
    // Permanent upgrades (unlock based on persistent stats)
    UPGRADES: {
        // Starting Gear
        START_SHOTGUN: { id: 'start_shotgun', name: 'Shotgun Start', desc: 'Begin runs with Shotgun', 
                         category: 'gear', icon: 'üî´', requirement: { stat: 'runsCompleted', value: 10 } },
        START_GRENADE: { id: 'start_grenade', name: 'Grenade Start', desc: 'Begin runs with 1 Grenade',
                         category: 'gear', icon: 'üí£', requirement: { stat: 'totalGrenadeKills', value: 25 } },
        START_FLASHLIGHT: { id: 'start_flashlight', name: 'Flashlight Start', desc: 'Begin runs with Flashlight',
                            category: 'gear', icon: 'üî¶', requirement: { stat: 'highestLevelUnlocked', value: 5 } },
        START_AMMO: { id: 'start_ammo', name: 'Ammo Cache', desc: 'Begin runs with +20 Ammo',
                      category: 'gear', icon: 'üì¶', requirement: { stat: 'totalKills', value: 100 } },
        
        // Stat Boosts
        HP_BOOST_1: { id: 'hp_boost_1', name: 'Tough I', desc: '+1 Max HP',
                      category: 'stats', icon: '‚ù§Ô∏è', requirement: { stat: 'runsCompleted', value: 5 } },
        HP_BOOST_2: { id: 'hp_boost_2', name: 'Tough II', desc: '+2 Max HP',
                      category: 'stats', icon: 'üíñ', requirement: { stat: 'runsCompleted', value: 15 } },
        SPEED_BOOST: { id: 'speed_boost', name: 'Fleet Feet', desc: '+5% Movement Speed',
                       category: 'stats', icon: 'üëü', requirement: { stat: 'highestLevelUnlocked', value: 7 } },
        DAMAGE_BOOST: { id: 'damage_boost', name: 'Lethal', desc: '+10% Damage',
                        category: 'stats', icon: 'üíÄ', requirement: { stat: 'bossesKilled', value: 10 } },
        
        // Cosmetics - Player Skins (tints)
        SKIN_TACTICAL: { id: 'skin_tactical', name: 'Tactical', desc: 'Dark blue player skin',
                         category: 'skin', icon: 'üîµ', tint: 0x4466aa, requirement: { stat: 'runsStarted', value: 10 } },
        SKIN_SURVIVOR: { id: 'skin_survivor', name: 'Survivor', desc: 'Battle-worn red skin',
                         category: 'skin', icon: 'üî¥', tint: 0xaa4444, requirement: { stat: 'runsStarted', value: 25 } },
        SKIN_GHOST: { id: 'skin_ghost', name: 'Ghost', desc: 'Pale stealth skin',
                      category: 'skin', icon: 'üëª', tint: 0xaaaacc, requirement: { stat: 'meleeKills', value: 50 } },
        
        // Cosmetics - Muzzle Flash Colors
        MUZZLE_BLUE: { id: 'muzzle_blue', name: 'Blue Flash', desc: 'Blue muzzle flash',
                       category: 'muzzle', icon: 'üîµ', color: 0x00aaff, requirement: { stat: 'totalShotsFired', value: 1000 } },
        MUZZLE_RED: { id: 'muzzle_red', name: 'Red Flash', desc: 'Red muzzle flash',
                      category: 'muzzle', icon: 'üî¥', color: 0xff4444, requirement: { stat: 'bossesKilled', value: 5 } },
        MUZZLE_GREEN: { id: 'muzzle_green', name: 'Green Flash', desc: 'Green muzzle flash',
                        category: 'muzzle', icon: 'üü¢', color: 0x44ff44, requirement: { stat: 'totalScrapCollected', value: 300 } }
    },
    
    // Skill Tree - spend skill points to unlock abilities
    SKILLS: {
        // ===== SURVIVAL BRANCH =====
        THICK_SKIN: { 
            id: 'thick_skin', branch: 'survival', name: 'Thick Skin', 
            desc: '-10% damage taken', cost: 2, requires: null, row: 0,
            effect: { type: 'damage_reduction', value: 0.1 }
        },
        IRON_WILL: { 
            id: 'iron_will', branch: 'survival', name: 'Iron Will',
            desc: '-20% damage taken', cost: 4, requires: 'thick_skin', row: 1,
            effect: { type: 'damage_reduction', value: 0.2 }
        },
        SECOND_WIND: { 
            id: 'second_wind', branch: 'survival', name: 'Second Wind',
            desc: 'Survive one lethal hit per run (1 HP)', cost: 6, requires: 'iron_will', row: 2,
            effect: { type: 'cheat_death' }
        },
        REGENERATION: { 
            id: 'regeneration', branch: 'survival', name: 'Regeneration',
            desc: 'Heal 1 HP every 60 seconds', cost: 5, requires: null, row: 3,
            effect: { type: 'regen', interval: 60000 }
        },
        LAST_STAND: { 
            id: 'last_stand', branch: 'survival', name: 'Last Stand',
            desc: '+50% damage when below 25% HP', cost: 4, requires: null, row: 4,
            effect: { type: 'low_hp_damage', threshold: 0.25, bonus: 0.5 }
        },
        
        // ===== STEALTH BRANCH =====
        LIGHT_FEET: { 
            id: 'light_feet', branch: 'stealth', name: 'Light Feet',
            desc: 'Footstep sounds reduced', cost: 2, requires: null, row: 0,
            effect: { type: 'quiet_footsteps', value: 0.3 }
        },
        SHADOW_STEP: { 
            id: 'shadow_step', branch: 'stealth', name: 'Shadow Step',
            desc: '-25% enemy detection range', cost: 4, requires: 'light_feet', row: 1,
            effect: { type: 'detection_reduction', value: 0.25 }
        },
        SILENT_KILLER: { 
            id: 'silent_killer', branch: 'stealth', name: 'Silent Killer',
            desc: 'Melee kills do not alert nearby enemies', cost: 5, requires: 'shadow_step', row: 2,
            effect: { type: 'silent_melee' }
        },
        AMBUSH: { 
            id: 'ambush', branch: 'stealth', name: 'Ambush',
            desc: '+50% damage to unaware enemies', cost: 6, requires: 'silent_killer', row: 3,
            effect: { type: 'ambush_damage', bonus: 0.5 }
        },
        GHOST: { 
            id: 'ghost', branch: 'stealth', name: 'Ghost',
            desc: 'Enemies lose track of you faster', cost: 3, requires: null, row: 4,
            effect: { type: 'detection_decay', value: 2.0 }
        },
        
        // ===== UTILITY BRANCH =====
        QUICK_HANDS: { 
            id: 'quick_hands', branch: 'utility', name: 'Quick Hands',
            desc: '+25% interact speed', cost: 2, requires: null, row: 0,
            effect: { type: 'interact_speed', value: 0.25 }
        },
        HAGGLER: { 
            id: 'haggler', branch: 'utility', name: 'Haggler',
            desc: '15% discount at trader', cost: 4, requires: 'quick_hands', row: 1,
            effect: { type: 'trader_discount', value: 0.15 }
        },
        SCRAPPER: { 
            id: 'scrapper', branch: 'utility', name: 'Scrapper',
            desc: '+25% scrap from all sources', cost: 5, requires: 'haggler', row: 2,
            effect: { type: 'scrap_bonus', value: 0.25 }
        },
        SWIFT_RELOAD: { 
            id: 'swift_reload', branch: 'utility', name: 'Swift Reload',
            desc: '-15% reload time', cost: 4, requires: null, row: 3,
            effect: { type: 'reload_speed', value: 0.15 }
        },
        PACK_MULE: { 
            id: 'pack_mule', branch: 'utility', name: 'Pack Mule',
            desc: '+1 consumable slot', cost: 3, requires: null, row: 4,
            effect: { type: 'extra_consumable' }
        }
    },
    
    // Challenge System - daily/weekly/permanent challenges with skill point rewards
    CHALLENGES: {
        DAILY: [
            { id: 'daily_melee_10', name: 'Melee Mayhem', desc: 'Kill 10 enemies with melee', 
              target: 10, stat: 'runMeleeKills', reward: 2 },
            { id: 'daily_kills_20', name: 'Exterminator', desc: 'Kill 20 enemies in a single run', 
              target: 20, stat: 'runKills', reward: 1 },
            { id: 'daily_no_damage', name: 'Untouchable', desc: 'Complete a level without taking damage', 
              target: 1, stat: 'levelNoDamage', reward: 2 },
            { id: 'daily_headshots', name: 'Sharpshooter', desc: 'Achieve 60%+ accuracy in a run (min 20 shots)', 
              target: 1, stat: 'highAccuracy', reward: 2 },
            { id: 'daily_grenades_5', name: 'Bombardier', desc: 'Kill 5 enemies with grenades', 
              target: 5, stat: 'runGrenadeKills', reward: 2 },
            { id: 'daily_scrap_50', name: 'Scavenger Run', desc: 'Collect 50 scrap in a single run', 
              target: 50, stat: 'runScrapCollected', reward: 1 },
            { id: 'daily_speed_run', name: 'Speed Demon', desc: 'Complete any level in under 2 minutes', 
              target: 1, stat: 'speedRun', reward: 2 },
            { id: 'daily_pistol_only', name: 'Old Faithful', desc: 'Complete a level using only the pistol', 
              target: 1, stat: 'pistolOnly', reward: 2 }
        ],
        WEEKLY: [
            { id: 'weekly_kills_100', name: 'Genocide', desc: 'Kill 100 enemies this week', 
              target: 100, stat: 'weeklyKills', reward: 4 },
            { id: 'weekly_extract_5', name: 'Survivor', desc: 'Extract 5 times this week', 
              target: 5, stat: 'weeklyExtractions', reward: 3 },
            { id: 'weekly_bosses_3', name: 'Boss Hunter', desc: 'Kill 3 bosses this week', 
              target: 3, stat: 'weeklyBossKills', reward: 5 },
            { id: 'weekly_scrap_200', name: 'Hoarder', desc: 'Collect 200 scrap this week', 
              target: 200, stat: 'weeklyScrap', reward: 3 },
            { id: 'weekly_levels_all', name: 'Globetrotter', desc: 'Extract from 5 different levels this week', 
              target: 5, stat: 'weeklyUniqueLevels', reward: 4 }
        ],
        PERMANENT: [
            { id: 'perm_crossbow_100', name: 'Bolt Action', desc: 'Kill 100 enemies with the crossbow', 
              target: 100, stat: 'crossbowKills', reward: { type: 'skin', id: 'skin_hunter', tint: 0x665544 } },
            { id: 'perm_melee_200', name: 'Bladedancer', desc: 'Kill 200 enemies with melee', 
              target: 200, stat: 'meleeKills', reward: { type: 'skin', id: 'skin_assassin', tint: 0x332233 } },
            { id: 'perm_extractions_50', name: 'Veteran', desc: 'Complete 50 extractions', 
              target: 50, stat: 'runsCompleted', reward: { type: 'muzzle', id: 'muzzle_gold', color: 0xffd700 } },
            { id: 'perm_no_damage_5', name: 'Perfection', desc: 'Complete 5 levels without taking any damage', 
              target: 5, stat: 'perfectLevels', reward: { type: 'skin', id: 'skin_ethereal', tint: 0xaaddff } }
        ]
    },
    
    // Weapon Mods - attachments that modify weapon stats
    MODS: {
        EXTENDED_MAG: { 
            id: 'extended_mag', name: 'Extended Mag', 
            desc: '+50% magazine size', icon: 'M',
            compatible: ['pistol', 'shotgun', 'smg', 'crossbow', 'rifle'],
            effect: { type: 'mag_size', value: 0.5 },
            cost: { currency: 'materials', amount: 15 },
            rarity: 'common'
        },
        SUPPRESSOR: { 
            id: 'suppressor', name: 'Suppressor', 
            desc: 'Silent shots, -10% damage', icon: 'S',
            compatible: ['pistol', 'smg', 'rifle'],
            effect: { type: 'suppressor', damageReduction: 0.1 },
            cost: { currency: 'materials', amount: 20 },
            rarity: 'uncommon'
        },
        LASER_SIGHT: { 
            id: 'laser_sight', name: 'Laser Sight', 
            desc: 'Shows bullet trajectory', icon: 'L',
            compatible: ['pistol', 'shotgun', 'smg', 'crossbow', 'rifle'],
            effect: { type: 'laser_sight' },
            cost: { currency: 'materials', amount: 25 },
            rarity: 'uncommon'
        },
        DAMAGE_BARREL: { 
            id: 'damage_barrel', name: 'Damage Barrel', 
            desc: '+20% damage, -15% fire rate', icon: 'D',
            compatible: ['shotgun', 'rifle'],
            effect: { type: 'damage_barrel', damage: 0.2, fireRate: -0.15 },
            cost: { currency: 'materials', amount: 30 },
            rarity: 'rare'
        },
        RAPID_FIRE: { 
            id: 'rapid_fire', name: 'Rapid Fire', 
            desc: '+25% fire rate, +20% spread', icon: 'R',
            compatible: ['smg', 'pistol'],
            effect: { type: 'rapid_fire', fireRate: 0.25, spread: 0.2 },
            cost: { currency: 'materials', amount: 25 },
            rarity: 'rare'
        }
    },
    
    // Roguelike Room System - Level grid dimensions
    LEVEL_GRIDS: {
        1: { cols: 2, rows: 2, theme: 'STREET' },      // Street - 4 rooms
        2: { cols: 2, rows: 2, theme: 'APARTMENT' },   // Apartment - 4 rooms
        3: { cols: 2, rows: 2, theme: 'ROOFTOP' },     // Rooftop - 4 rooms
        4: { cols: 3, rows: 2, theme: 'SEWERS' },      // Sewers - 6 rooms (maze-like)
        5: { cols: 2, rows: 1, theme: 'HOSPITAL' },    // Hospital - 2 rooms (boss level)
        6: { cols: 3, rows: 2, theme: 'MALL' },        // Mall - 6 rooms
        7: { cols: 2, rows: 1, theme: 'CEMETERY' }     // Cemetery - 2 rooms (boss level)
    },
    
    // Risk room configuration
    RISK_ROOM: {
        SPAWN_CHANCE: 0.25,        // 25% chance per eligible room
        ENEMY_MULTIPLIER: 1.5,     // 1.5x enemies
        LOOT_MULTIPLIER: 2.0,      // 2x currency drops
        GUARANTEED_DROPS: ['extended_mag', 'suppressor', 'laser_sight', 'damage_barrel', 'rapid_fire'],
        ENEMY_UPGRADES: {
            walker: 'leaper',      // Walkers become leapers
            leaper: 'bandit',      // Leapers become bandits
            spitter: 'exploder'    // Spitters become exploders
        }
    },
    
    // Room chunk templates for procedural generation
    // Each chunk has: walls (relative positions), spawnPoints, crateSlots, doorPositions
    // Coordinates are relative to 800x600 room (0,0 is top-left)
    ROOM_CHUNKS: {
        STREET: [
            {
                id: 'street_open',
                floor: 'floor_grass',
                walls: [
                    { x: 200, y: 200, scaleX: 1, scaleY: 3 },
                    { x: 600, y: 400, scaleX: 1, scaleY: 3 }
                ],
                spawnPoints: [
                    { x: 100, y: 150 }, { x: 700, y: 150 },
                    { x: 100, y: 450 }, { x: 700, y: 450 },
                    { x: 400, y: 300 }
                ],
                crateSlots: [
                    { x: 100, y: 100 }, { x: 700, y: 100 },
                    { x: 100, y: 500 }, { x: 700, y: 500 },
                    { x: 300, y: 300 }, { x: 500, y: 300 }
                ],
                doorPositions: { north: true, south: true, east: true, west: true }
            },
            {
                id: 'street_alley',
                floor: 'floor_grass',
                walls: [
                    { x: 300, y: 150, scaleX: 8, scaleY: 1 },
                    { x: 300, y: 450, scaleX: 8, scaleY: 1 },
                    { x: 150, y: 300, scaleX: 1, scaleY: 4 }
                ],
                spawnPoints: [
                    { x: 500, y: 300 }, { x: 650, y: 200 },
                    { x: 650, y: 400 }, { x: 250, y: 300 }
                ],
                crateSlots: [
                    { x: 400, y: 250 }, { x: 400, y: 350 },
                    { x: 600, y: 250 }, { x: 600, y: 350 },
                    { x: 700, y: 300 }
                ],
                doorPositions: { north: false, south: false, east: true, west: true }
            },
            {
                id: 'street_corner',
                floor: 'floor_grass',
                walls: [
                    { x: 200, y: 200, scaleX: 1, scaleY: 6 },
                    { x: 350, y: 100, scaleX: 6, scaleY: 1 },
                    { x: 600, y: 350, scaleX: 1, scaleY: 4 }
                ],
                spawnPoints: [
                    { x: 400, y: 300 }, { x: 500, y: 200 },
                    { x: 300, y: 400 }, { x: 700, y: 500 }
                ],
                crateSlots: [
                    { x: 350, y: 250 }, { x: 500, y: 350 },
                    { x: 650, y: 200 }, { x: 100, y: 500 },
                    { x: 750, y: 550 }
                ],
                doorPositions: { north: true, south: true, east: true, west: false }
            }
        ],
        APARTMENT: [
            {
                id: 'apt_hallway',
                floor: 'floor_apt',
                walls: [
                    { x: 200, y: 200, scaleX: 1, scaleY: 8 },
                    { x: 600, y: 200, scaleX: 1, scaleY: 8 }
                ],
                spawnPoints: [
                    { x: 400, y: 150 }, { x: 400, y: 300 },
                    { x: 400, y: 450 }, { x: 100, y: 300 },
                    { x: 700, y: 300 }
                ],
                crateSlots: [
                    { x: 300, y: 200 }, { x: 500, y: 200 },
                    { x: 300, y: 400 }, { x: 500, y: 400 },
                    { x: 100, y: 150 }, { x: 700, y: 150 }
                ],
                doorPositions: { north: true, south: true, east: true, west: true }
            },
            {
                id: 'apt_rooms',
                floor: 'floor_apt',
                walls: [
                    { x: 250, y: 300, scaleX: 1, scaleY: 10 },
                    { x: 550, y: 300, scaleX: 1, scaleY: 10 },
                    { x: 400, y: 250, scaleX: 4, scaleY: 1 }
                ],
                spawnPoints: [
                    { x: 100, y: 150 }, { x: 100, y: 450 },
                    { x: 700, y: 150 }, { x: 700, y: 450 },
                    { x: 400, y: 450 }
                ],
                crateSlots: [
                    { x: 100, y: 250 }, { x: 100, y: 350 },
                    { x: 700, y: 250 }, { x: 700, y: 350 },
                    { x: 400, y: 500 }
                ],
                doorPositions: { north: true, south: true, east: false, west: false }
            },
            {
                id: 'apt_lobby',
                floor: 'floor_apt',
                walls: [
                    { x: 200, y: 150, scaleX: 4, scaleY: 1 },
                    { x: 600, y: 150, scaleX: 4, scaleY: 1 },
                    { x: 150, y: 350, scaleX: 1, scaleY: 4 },
                    { x: 650, y: 350, scaleX: 1, scaleY: 4 }
                ],
                spawnPoints: [
                    { x: 400, y: 100 }, { x: 200, y: 450 },
                    { x: 600, y: 450 }, { x: 400, y: 350 }
                ],
                crateSlots: [
                    { x: 100, y: 100 }, { x: 700, y: 100 },
                    { x: 300, y: 300 }, { x: 500, y: 300 },
                    { x: 400, y: 550 }
                ],
                doorPositions: { north: true, south: true, east: true, west: true }
            }
        ],
        ROOFTOP: [
            {
                id: 'roof_open',
                floor: 'floor_roof',
                walls: [
                    { x: 100, y: 300, scaleX: 1, scaleY: 2 },
                    { x: 700, y: 300, scaleX: 1, scaleY: 2 }
                ],
                spawnPoints: [
                    { x: 200, y: 150 }, { x: 600, y: 150 },
                    { x: 200, y: 450 }, { x: 600, y: 450 },
                    { x: 400, y: 300 }
                ],
                crateSlots: [
                    { x: 150, y: 200 }, { x: 650, y: 200 },
                    { x: 150, y: 400 }, { x: 650, y: 400 },
                    { x: 400, y: 200 }, { x: 400, y: 400 }
                ],
                doorPositions: { north: true, south: true, east: true, west: true }
            },
            {
                id: 'roof_vents',
                floor: 'floor_roof',
                walls: [
                    { x: 200, y: 200, scaleX: 2, scaleY: 2 },
                    { x: 600, y: 200, scaleX: 2, scaleY: 2 },
                    { x: 400, y: 400, scaleX: 2, scaleY: 2 }
                ],
                spawnPoints: [
                    { x: 100, y: 100 }, { x: 700, y: 100 },
                    { x: 100, y: 500 }, { x: 700, y: 500 },
                    { x: 400, y: 250 }
                ],
                crateSlots: [
                    { x: 350, y: 150 }, { x: 450, y: 150 },
                    { x: 200, y: 450 }, { x: 600, y: 450 },
                    { x: 100, y: 300 }, { x: 700, y: 300 }
                ],
                doorPositions: { north: true, south: true, east: true, west: true }
            }
        ],
        SEWERS: [
            {
                id: 'sewer_junction',
                floor: 'floor_sewer',
                walls: [
                    { x: 200, y: 150, scaleX: 6, scaleY: 1 },
                    { x: 200, y: 450, scaleX: 6, scaleY: 1 },
                    { x: 600, y: 150, scaleX: 3, scaleY: 1 },
                    { x: 600, y: 450, scaleX: 3, scaleY: 1 }
                ],
                spawnPoints: [
                    { x: 400, y: 300 }, { x: 200, y: 300 },
                    { x: 600, y: 300 }, { x: 400, y: 200 },
                    { x: 400, y: 400 }
                ],
                crateSlots: [
                    { x: 100, y: 250 }, { x: 100, y: 350 },
                    { x: 700, y: 250 }, { x: 700, y: 350 },
                    { x: 350, y: 300 }, { x: 450, y: 300 }
                ],
                doorPositions: { north: true, south: true, east: true, west: true }
            },
            {
                id: 'sewer_pipe',
                floor: 'floor_sewer',
                walls: [
                    { x: 100, y: 200, scaleX: 1, scaleY: 3 },
                    { x: 100, y: 500, scaleX: 1, scaleY: 2 },
                    { x: 400, y: 300, scaleX: 1, scaleY: 6 },
                    { x: 700, y: 200, scaleX: 1, scaleY: 3 },
                    { x: 700, y: 500, scaleX: 1, scaleY: 2 }
                ],
                spawnPoints: [
                    { x: 250, y: 150 }, { x: 250, y: 450 },
                    { x: 550, y: 150 }, { x: 550, y: 450 }
                ],
                crateSlots: [
                    { x: 200, y: 200 }, { x: 200, y: 400 },
                    { x: 500, y: 200 }, { x: 500, y: 400 }
                ],
                doorPositions: { north: true, south: true, east: false, west: false }
            },
            {
                id: 'sewer_chamber',
                floor: 'floor_sewer',
                walls: [
                    { x: 200, y: 200, scaleX: 2, scaleY: 1 },
                    { x: 600, y: 200, scaleX: 2, scaleY: 1 },
                    { x: 200, y: 400, scaleX: 2, scaleY: 1 },
                    { x: 600, y: 400, scaleX: 2, scaleY: 1 }
                ],
                spawnPoints: [
                    { x: 400, y: 100 }, { x: 400, y: 500 },
                    { x: 100, y: 300 }, { x: 700, y: 300 },
                    { x: 400, y: 300 }
                ],
                crateSlots: [
                    { x: 300, y: 300 }, { x: 500, y: 300 },
                    { x: 100, y: 150 }, { x: 700, y: 150 },
                    { x: 100, y: 450 }, { x: 700, y: 450 }
                ],
                doorPositions: { north: true, south: true, east: true, west: true }
            }
        ],
        HOSPITAL: [
            {
                id: 'hospital_ward',
                floor: 'floor_hospital',
                walls: [
                    { x: 150, y: 200, scaleX: 1, scaleY: 6 },
                    { x: 650, y: 200, scaleX: 1, scaleY: 6 },
                    { x: 300, y: 100, scaleX: 3, scaleY: 1 },
                    { x: 500, y: 100, scaleX: 3, scaleY: 1 },
                    { x: 400, y: 350, scaleX: 6, scaleY: 1 }
                ],
                spawnPoints: [
                    { x: 400, y: 200 }, { x: 250, y: 450 },
                    { x: 550, y: 450 }, { x: 100, y: 300 },
                    { x: 700, y: 300 }
                ],
                crateSlots: [
                    { x: 250, y: 250 }, { x: 550, y: 250 },
                    { x: 100, y: 450 }, { x: 700, y: 450 },
                    { x: 400, y: 500 }
                ],
                doorPositions: { north: true, south: true, east: true, west: true }
            },
            {
                id: 'hospital_boss',
                floor: 'floor_hospital',
                walls: [
                    { x: 100, y: 200, scaleX: 1, scaleY: 4 },
                    { x: 700, y: 200, scaleX: 1, scaleY: 4 },
                    { x: 200, y: 450, scaleX: 3, scaleY: 1 },
                    { x: 600, y: 450, scaleX: 3, scaleY: 1 }
                ],
                spawnPoints: [
                    { x: 400, y: 150 }, { x: 200, y: 300 },
                    { x: 600, y: 300 }, { x: 300, y: 500 },
                    { x: 500, y: 500 }
                ],
                crateSlots: [
                    { x: 150, y: 450 }, { x: 650, y: 450 },
                    { x: 250, y: 200 }, { x: 550, y: 200 },
                    { x: 400, y: 350 }
                ],
                doorPositions: { north: false, south: true, east: true, west: true },
                isBossRoom: true
            }
        ],
        MALL: [
            {
                id: 'mall_atrium',
                floor: 'floor_apt',
                walls: [
                    { x: 100, y: 450, scaleX: 3, scaleY: 3 },
                    { x: 700, y: 450, scaleX: 3, scaleY: 3 },
                    { x: 300, y: 250, scaleX: 1, scaleY: 2 },
                    { x: 500, y: 250, scaleX: 1, scaleY: 2 }
                ],
                spawnPoints: [
                    { x: 400, y: 150 }, { x: 200, y: 250 },
                    { x: 600, y: 250 }, { x: 400, y: 400 },
                    { x: 200, y: 550 }, { x: 600, y: 550 }
                ],
                crateSlots: [
                    { x: 350, y: 350 }, { x: 450, y: 350 },
                    { x: 100, y: 200 }, { x: 700, y: 200 },
                    { x: 400, y: 500 }
                ],
                doorPositions: { north: true, south: true, east: true, west: true }
            },
            {
                id: 'mall_store',
                floor: 'floor_apt',
                walls: [
                    { x: 150, y: 150, scaleX: 1, scaleY: 4 },
                    { x: 650, y: 150, scaleX: 1, scaleY: 4 },
                    { x: 150, y: 450, scaleX: 1, scaleY: 4 },
                    { x: 650, y: 450, scaleX: 1, scaleY: 4 },
                    { x: 400, y: 300, scaleX: 4, scaleY: 1 }
                ],
                spawnPoints: [
                    { x: 300, y: 150 }, { x: 500, y: 150 },
                    { x: 300, y: 450 }, { x: 500, y: 450 },
                    { x: 100, y: 300 }, { x: 700, y: 300 }
                ],
                crateSlots: [
                    { x: 250, y: 200 }, { x: 550, y: 200 },
                    { x: 250, y: 400 }, { x: 550, y: 400 },
                    { x: 400, y: 150 }, { x: 400, y: 450 }
                ],
                doorPositions: { north: true, south: true, east: false, west: false }
            },
            {
                id: 'mall_food_court',
                floor: 'floor_apt',
                walls: [
                    { x: 200, y: 200, scaleX: 2, scaleY: 2 },
                    { x: 400, y: 200, scaleX: 2, scaleY: 2 },
                    { x: 600, y: 200, scaleX: 2, scaleY: 2 },
                    { x: 300, y: 450, scaleX: 2, scaleY: 2 },
                    { x: 500, y: 450, scaleX: 2, scaleY: 2 }
                ],
                spawnPoints: [
                    { x: 100, y: 300 }, { x: 700, y: 300 },
                    { x: 100, y: 500 }, { x: 700, y: 500 },
                    { x: 400, y: 350 }
                ],
                crateSlots: [
                    { x: 100, y: 150 }, { x: 700, y: 150 },
                    { x: 150, y: 400 }, { x: 650, y: 400 },
                    { x: 400, y: 550 }
                ],
                doorPositions: { north: true, south: true, east: true, west: true }
            }
        ],
        CEMETERY: [
            {
                id: 'cemetery_graveyard',
                floor: 'floor_grass',
                floorOverlay: { color: 0x001100, alpha: 0.5 },
                walls: [
                    { x: 150, y: 450, scaleX: 0.5, scaleY: 1, tint: 0x555555 },
                    { x: 250, y: 400, scaleX: 0.5, scaleY: 1, tint: 0x555555 },
                    { x: 350, y: 480, scaleX: 0.5, scaleY: 1, tint: 0x555555 },
                    { x: 450, y: 420, scaleX: 0.5, scaleY: 1, tint: 0x555555 },
                    { x: 550, y: 460, scaleX: 0.5, scaleY: 1, tint: 0x555555 },
                    { x: 650, y: 400, scaleX: 0.5, scaleY: 1, tint: 0x555555 }
                ],
                spawnPoints: [
                    { x: 200, y: 350 }, { x: 400, y: 350 },
                    { x: 600, y: 350 }, { x: 300, y: 250 },
                    { x: 500, y: 250 }
                ],
                crateSlots: [
                    { x: 100, y: 300 }, { x: 700, y: 300 },
                    { x: 200, y: 500 }, { x: 600, y: 500 },
                    { x: 400, y: 550 }
                ],
                doorPositions: { north: true, south: true, east: true, west: true }
            },
            {
                id: 'cemetery_church',
                floor: 'floor_grass',
                floorOverlay: { color: 0x001100, alpha: 0.5 },
                walls: [
                    { x: 200, y: 100, scaleX: 4, scaleY: 1 },
                    { x: 600, y: 100, scaleX: 4, scaleY: 1 },
                    { x: 100, y: 150, scaleX: 1, scaleY: 3 },
                    { x: 700, y: 150, scaleX: 1, scaleY: 3 }
                ],
                spawnPoints: [
                    { x: 400, y: 150 }, { x: 200, y: 300 },
                    { x: 600, y: 300 }, { x: 300, y: 450 },
                    { x: 500, y: 450 }
                ],
                crateSlots: [
                    { x: 150, y: 250 }, { x: 650, y: 250 },
                    { x: 200, y: 500 }, { x: 600, y: 500 },
                    { x: 400, y: 400 }
                ],
                doorPositions: { north: false, south: true, east: true, west: true },
                isBossRoom: true,
                churchVisual: true
            }
        ]
    }
};

const DEFAULT_STATS = { 
    hp: 10, maxHp: 10, stamina: 100, maxStamina: 100, ammo: 30, scrap: 0,
    credits: 0,
    materials: 0,
    grenades: 0,
    nextLevel: 1,  // Track which level to start on after extraction
    highestLevelUnlocked: 1,  // Track progression (1-7) for mission map
    consumables: [null, null, null],  // 3 slots for hotkeys 1, 2, 3
    hasFlashlight: false, hasShotgun: false, hasSMG: false, hasCrossbow: false, hasRifle: false, currentWeapon: 'pistol',
    // Magazine tracking - current rounds in each weapon's magazine
    magazines: {
        pistol: CONFIG.WEAPONS.PISTOL.MAG_SIZE,
        shotgun: CONFIG.WEAPONS.SHOTGUN.MAG_SIZE,
        smg: CONFIG.WEAPONS.SMG.MAG_SIZE,
        crossbow: CONFIG.WEAPONS.CROSSBOW.MAG_SIZE,
        rifle: CONFIG.WEAPONS.RIFLE.MAG_SIZE
    },
    armor: { head: null, body: null, arms: null, feet: null },
    hideout: { 
        restAreaLvl: 0, 
        generatorLvl: 0, 
        hasSparkPlug: false,
        armory: { crafting: null, hasNVG: false },
        workbenchLvl: 0,  // Weapon damage upgrade
        repairStationLvl: 0  // Armor repair
    },
    // Equipped weapon mods (per-run, 2 slots per weapon)
    equippedMods: {
        pistol: [null, null],
        shotgun: [null, null],
        smg: [null, null],
        crossbow: [null, null],
        rifle: [null, null]
    }
};

// Persistent stats that survive across all runs (stored separately)
const DEFAULT_PERSISTENT = {
    // Lifetime stats
    totalKills: 0,
    totalDeaths: 0,
    runsCompleted: 0,
    runsStarted: 0,
    totalShotsFired: 0,
    totalShotsHit: 0,
    totalScrapCollected: 0,
    totalCreditsEarned: 0,
    totalMaterialsCollected: 0,
    totalGrenadeKills: 0,
    bossesKilled: 0,
    meleeKills: 0,
    itemsSold: 0,
    itemsBought: 0,
    // Current run stats (reset each run)
    runKills: 0,
    runShotsFired: 0,
    runShotsHit: 0,
    runDamageTaken: 0,
    runGrenadeKills: 0,
    runMeleeKills: 0,
    bossHitWithGun: false, // For melee master achievement
    // Achievements unlocked
    achievements: [],
    // Class system
    totalHPHealed: 0,               // For Medic class unlock
    unlockedClasses: ['survivor'],  // Classes available to play
    selectedClass: 'survivor',      // Current class selection
    // Permanent upgrades system
    unlockedUpgrades: [],           // Permanently unlocked upgrades
    equippedSkin: null,             // null = default green
    equippedMuzzle: null,           // null = default yellow/orange
    highestLevelUnlocked: 1,        // Mirror from stats for upgrade tracking
    bestLevelTimes: {},             // Future: { 1: ms, 2: ms, ... }
    
    // Skill Tree system
    skillPoints: 0,                 // Spendable skill points
    totalSkillPoints: 0,            // Lifetime skill points earned (for stats)
    unlockedSkills: [],             // Array of skill IDs player has purchased
    secondWindUsed: false,          // Tracks if Second Wind was used this run
    
    // Challenge System
    activeDailies: [],              // 3 active daily challenges with progress { id, progress }
    activeWeeklies: [],             // 5 active weekly challenges with progress { id, progress }
    completedPermanents: [],        // IDs of completed permanent challenges
    dailyResetTime: 0,              // Unix timestamp for next daily reset
    weeklyResetTime: 0,             // Unix timestamp for next weekly reset
    // Weekly tracking stats (reset each week)
    weeklyKills: 0,
    weeklyExtractions: 0,
    weeklyBossKills: 0,
    weeklyScrap: 0,
    weeklyUniqueLevels: [],         // Array of level numbers extracted from this week
    // Lifetime stats for permanent challenges
    crossbowKills: 0,
    perfectLevels: 0,               // Levels completed with 0 damage
    // Run-specific tracking (extended)
    runScrapCollected: 0,
    runLevelStartTime: 0,           // For speed run tracking
    runWeaponUsed: null,            // For pistol-only challenge
    
    // Weapon Mods System
    modInventory: []                // Array of mod IDs owned (stored permanently)
};

const PERSISTENT_KEY = 'zombie_persistent_v17';

// Default settings
const DEFAULT_SETTINGS = {
    masterVolume: 0.3,
    sfxVolume: 1.0,
    musicVolume: 0.5,
    screenShake: true,
    hitIndicators: true
};

// =============================================================================
// SETTINGS MANAGER
// =============================================================================
function loadSettings() {
    const saved = localStorage.getItem(CONFIG.SETTINGS_KEY);
    if (saved) {
        return { ...JSON.parse(JSON.stringify(DEFAULT_SETTINGS)), ...JSON.parse(saved) };
    }
    return JSON.parse(JSON.stringify(DEFAULT_SETTINGS));
}

function saveSettings(settings) {
    localStorage.setItem(CONFIG.SETTINGS_KEY, JSON.stringify(settings));
}

// =============================================================================
// AUDIO MANAGER (PROCEDURAL SOUNDS WITH VOLUME CONTROL)
// =============================================================================
class SoundManager {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.settings = loadSettings();
        
        // Create gain nodes for volume control
        this.masterGain = this.ctx.createGain();
        this.sfxGain = this.ctx.createGain();
        this.musicGain = this.ctx.createGain();
        
        // Connect gain chain
        this.sfxGain.connect(this.masterGain);
        this.musicGain.connect(this.masterGain);
        this.masterGain.connect(this.ctx.destination);
        
        this.updateVolumes();
        
        // Footstep timing
        this.lastFootstep = 0;
        this.footstepInterval = 250; // ms between footsteps
    }
    
    updateVolumes() {
        this.masterGain.gain.value = this.settings.masterVolume;
        this.sfxGain.gain.value = this.settings.sfxVolume;
        this.musicGain.gain.value = this.settings.musicVolume;
    }
    
    setMasterVolume(vol) {
        this.settings.masterVolume = vol;
        this.updateVolumes();
        saveSettings(this.settings);
    }
    
    setSfxVolume(vol) {
        this.settings.sfxVolume = vol;
        this.updateVolumes();
        saveSettings(this.settings);
    }
    
    setMusicVolume(vol) {
        this.settings.musicVolume = vol;
        this.updateVolumes();
        saveSettings(this.settings);
    }
    
    reloadSettings() {
        this.settings = loadSettings();
        this.updateVolumes();
    }

    resume() { if (this.ctx.state === 'suspended') this.ctx.resume(); }

    playTone(freq, type, duration, vol = 1) {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.sfxGain);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }
    
    // Pitch variation helper
    playToneVaried(freq, type, duration, vol = 1, variance = 0.1) {
        const variedFreq = freq * (1 + (Math.random() - 0.5) * variance * 2);
        this.playTone(variedFreq, type, duration, vol);
    }

    playNoise(duration, vol = 1) {
        const bufferSize = this.ctx.sampleRate * duration;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        noise.connect(gain);
        gain.connect(this.sfxGain);
        noise.start();
    }
    
    // Filtered noise for variety
    playFilteredNoise(duration, vol = 1, filterFreq = 1000, filterType = 'lowpass') {
        const bufferSize = this.ctx.sampleRate * duration;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        
        const filter = this.ctx.createBiquadFilter();
        filter.type = filterType;
        filter.frequency.value = filterFreq;
        
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.sfxGain);
        noise.start();
    }

    // ==================== WEAPON SOUNDS (with variation) ====================
    shootPistol() { 
        this.playToneVaried(600, 'sawtooth', 0.1, 0.5, 0.1); 
        this.playNoise(0.1, 0.3); 
    }
    
    shootShotgun() { 
        this.playToneVaried(200, 'square', 0.3, 0.6, 0.05); 
        this.playNoise(0.3, 0.6); 
        this.playTone(100, 'sawtooth', 0.15, 0.3); // Extra bass
    }
    
    shootSMG() { 
        this.playToneVaried(800, 'sawtooth', 0.05, 0.4, 0.15); 
        this.playNoise(0.05, 0.2); 
    }
    
    // Crossbow - quiet twang
    shootCrossbow() {
        this.playToneVaried(300, 'triangle', 0.15, 0.2, 0.1);
        this.playToneVaried(150, 'sine', 0.1, 0.15, 0.1);
    }
    
    // Assault Rifle - medium crack
    shootRifle() {
        this.playToneVaried(400, 'sawtooth', 0.15, 0.5, 0.08);
        this.playNoise(0.15, 0.4);
        this.playTone(150, 'square', 0.1, 0.25);
    }
    
    // ==================== EXPLODER SOUNDS ====================
    exploderWarning() {
        // Ticking/bubbling sound as it charges
        this.playTone(200, 'sine', 0.1, 0.2);
        this.playTone(250, 'sine', 0.08, 0.15);
    }
    
    exploderExplode() {
        // Meaty explosion
        this.playTone(80, 'sawtooth', 0.4, 0.7);
        this.playNoise(0.35, 0.6);
        this.playTone(40, 'square', 0.3, 0.4);
    }
    
    // ==================== STEALTH SOUNDS ====================
    detectionPing() {
        // Soft ping when detection rises
        this.playTone(600, 'sine', 0.1, 0.2);
    }
    
    detectionMax() {
        // Alarm sound when fully detected
        this.playTone(800, 'square', 0.3, 0.5);
        this.playTone(600, 'square', 0.2, 0.4);
        this.playTone(800, 'square', 0.3, 0.5);
    }
    
    stealthKill() {
        // Satisfying quiet kill
        this.playTone(100, 'triangle', 0.15, 0.3);
        this.playFilteredNoise(0.1, 0.2, 800, 'lowpass');
    }
    
    // ==================== NECROMANCER SOUNDS ====================
    necroSummon() {
        // Ethereal chanting
        this.playTone(150, 'sine', 0.5, 0.3);
        this.playTone(200, 'sine', 0.4, 0.25);
        this.playTone(175, 'triangle', 0.3, 0.2);
    }
    
    necroVulnerable() {
        // Shield break sound
        this.playTone(400, 'sawtooth', 0.2, 0.4);
        this.playNoise(0.15, 0.3);
        this.playTone(200, 'square', 0.3, 0.3);
    }
    
    necroTeleport() {
        // Whoosh
        this.playFilteredNoise(0.2, 0.3, 2000, 'highpass');
        this.playTone(500, 'sine', 0.15, 0.2);
    }
    
    necroProjectile() {
        // Ghostly whistle
        this.playTone(600, 'sine', 0.2, 0.25);
        this.playTone(650, 'sine', 0.15, 0.2);
    }
    
    necroDeath() {
        // Dramatic echo fade
        this.playTone(200, 'sawtooth', 0.5, 0.5);
        this.playTone(150, 'sawtooth', 0.6, 0.4);
        this.playTone(100, 'sawtooth', 0.7, 0.3);
        this.playFilteredNoise(0.4, 0.4, 500, 'lowpass');
    }
    
    // ==================== HIT/DAMAGE SOUNDS ====================
    enemyHit() { 
        const pitch = 80 + Math.random() * 40;
        this.playTone(pitch, 'sawtooth', 0.1, 0.5); 
    }
    
    enemyDeath() {
        this.playTone(60, 'sawtooth', 0.2, 0.4);
        this.playFilteredNoise(0.3, 0.3, 500, 'lowpass');
    }
    
    playerHurt() { 
        this.playTone(50, 'sawtooth', 0.3, 0.8);
        this.playTone(70, 'square', 0.2, 0.4);
    }
    
    playerDeath() {
        this.playTone(40, 'sawtooth', 0.5, 0.6);
        this.playTone(30, 'square', 0.6, 0.4);
        this.playFilteredNoise(0.4, 0.5, 300, 'lowpass');
    }
    
    // ==================== UI SOUNDS ====================
    click() { 
        this.playTone(800, 'sine', 0.05, 0.3); 
    }
    
    menuOpen() {
        this.playTone(600, 'sine', 0.08, 0.2);
        this.playTone(800, 'sine', 0.08, 0.15);
    }
    
    menuClose() {
        this.playTone(800, 'sine', 0.08, 0.2);
        this.playTone(600, 'sine', 0.08, 0.15);
    }
    
    error() {
        this.playTone(200, 'square', 0.1, 0.4);
        this.playTone(150, 'square', 0.15, 0.3);
    }
    
    success() {
        this.playTone(800, 'sine', 0.1, 0.3);
        this.playTone(1000, 'sine', 0.1, 0.25);
        this.playTone(1200, 'sine', 0.15, 0.2);
    }
    
    // ==================== PICKUP SOUNDS ====================
    loot() { 
        this.playTone(1200, 'square', 0.1, 0.2); 
        this.playTone(1600, 'square', 0.1, 0.2); 
    }
    
    lootHealth() {
        this.playTone(600, 'sine', 0.1, 0.3);
        this.playTone(800, 'sine', 0.15, 0.25);
        this.playTone(1000, 'sine', 0.1, 0.2);
    }
    
    lootAmmo() {
        this.playTone(400, 'triangle', 0.08, 0.3);
        this.playFilteredNoise(0.1, 0.2, 2000, 'highpass');
    }
    
    lootWeapon() {
        this.playTone(500, 'square', 0.1, 0.3);
        this.playTone(700, 'square', 0.1, 0.25);
        this.playTone(900, 'square', 0.15, 0.3);
        this.playNoise(0.1, 0.2);
    }
    
    lootKey() {
        this.playTone(1000, 'sine', 0.15, 0.3);
        this.playTone(1500, 'sine', 0.2, 0.25);
        this.playTone(2000, 'sine', 0.1, 0.2);
    }
    
    // ==================== EQUIPMENT SOUNDS ====================
    toggleNVG() { 
        this.playTone(2000, 'sine', 0.2, 0.1); 
        this.playFilteredNoise(0.1, 0.1, 4000, 'highpass');
    }
    
    reload() { 
        this.playTone(400, 'triangle', 0.2, 0.4); 
        this.playFilteredNoise(0.1, 0.2, 1500, 'lowpass');
    }
    
    reloadFinish() { 
        this.playTone(600, 'triangle', 0.1, 0.5); 
        this.playTone(800, 'triangle', 0.1, 0.3); 
        this.playFilteredNoise(0.08, 0.15, 2000, 'highpass');
    }
    
    // ==================== MOVEMENT SOUNDS ====================
    dodge() { 
        this.playNoise(0.15, 0.3); 
        this.playTone(300, 'sine', 0.1, 0.2); 
    }
    
    footstep(time, isRunning = false) {
        if (time - this.lastFootstep < this.footstepInterval / (isRunning ? 1.5 : 1)) return;
        this.lastFootstep = time;
        
        const vol = isRunning ? 0.15 : 0.1;
        const pitch = 100 + Math.random() * 50;
        this.playFilteredNoise(0.05, vol, pitch * 10, 'lowpass');
    }
    
    // ==================== COMBAT SOUNDS ====================
    empty() { 
        this.playTone(200, 'square', 0.05, 0.3); 
    }
    
    melee() {
        this.playNoise(0.1, 0.4);
        this.playTone(250, 'sawtooth', 0.08, 0.3);
    }
    
    spit() { 
        this.playTone(150, 'sawtooth', 0.2, 0.4); 
        this.playNoise(0.15, 0.2); 
    }
    
    grenadeThrow() { 
        this.playTone(400, 'sine', 0.1, 0.3); 
        this.playNoise(0.08, 0.15);
    }
    
    explosion() { 
        this.playNoise(0.4, 0.8); 
        this.playTone(60, 'square', 0.3, 0.6); 
        this.playTone(40, 'sawtooth', 0.4, 0.5); 
        this.playFilteredNoise(0.5, 0.4, 200, 'lowpass');
    }
    
    // ==================== ENEMY SOUNDS ====================
    zombieGrowl() {
        const pitch = 80 + Math.random() * 40;
        this.playTone(pitch, 'sawtooth', 0.3, 0.2);
        this.playFilteredNoise(0.2, 0.15, 300, 'lowpass');
    }
    
    leaperPrepare() {
        this.playTone(200, 'sawtooth', 0.2, 0.3);
        this.playTone(300, 'square', 0.15, 0.2);
    }
    
    leaperLeap() {
        this.playTone(400, 'sawtooth', 0.15, 0.4);
        this.playNoise(0.2, 0.3);
    }
    
    banditShout() {
        this.playTone(150, 'square', 0.2, 0.25);
        this.playFilteredNoise(0.15, 0.2, 800, 'bandpass');
    }
    
    bossRoar() {
        this.playTone(50, 'sawtooth', 0.5, 0.5);
        this.playTone(70, 'square', 0.4, 0.4);
        this.playFilteredNoise(0.5, 0.4, 200, 'lowpass');
    }
    
    // ==================== LEVEL SOUNDS ====================
    levelStart() {
        this.playTone(400, 'sine', 0.2, 0.25);
        this.playTone(600, 'sine', 0.2, 0.2);
        this.playTone(800, 'sine', 0.3, 0.15);
    }
    
    levelComplete() {
        this.playTone(600, 'sine', 0.15, 0.3);
        this.playTone(800, 'sine', 0.15, 0.25);
        this.playTone(1000, 'sine', 0.15, 0.2);
        this.playTone(1200, 'sine', 0.3, 0.25);
    }
    
    extractionStart() {
        this.playTone(800, 'square', 0.3, 0.3);
        this.playTone(1000, 'square', 0.3, 0.25);
    }
    
    extractionTick() {
        this.playTone(600, 'sine', 0.1, 0.2);
    }
    
    achievement() {
        this.playTone(800, 'sine', 0.1, 0.3);
        this.playTone(1000, 'sine', 0.1, 0.25);
        this.playTone(1200, 'sine', 0.1, 0.2);
        this.playTone(1600, 'sine', 0.2, 0.3);
    }
    
    // ==================== DOOR/INTERACT SOUNDS ====================
    doorOpen() {
        this.playFilteredNoise(0.3, 0.3, 500, 'lowpass');
        this.playTone(200, 'triangle', 0.2, 0.2);
    }
    
    crateOpen() {
        this.playFilteredNoise(0.2, 0.25, 800, 'lowpass');
        this.playTone(300, 'triangle', 0.15, 0.2);
    }
    
    // ==================== TRADER SOUNDS ====================
    purchase() {
        this.playTone(800, 'sine', 0.1, 0.3);
        this.playTone(1000, 'sine', 0.15, 0.25);
        this.playTone(1200, 'sine', 0.1, 0.2);
    }
    
    sell() {
        this.playTone(600, 'sine', 0.1, 0.25);
        this.playTone(400, 'sine', 0.1, 0.2);
        this.playFilteredNoise(0.1, 0.15, 1000, 'highpass');
    }
    
    useConsumable() {
        this.playTone(1200, 'sine', 0.1, 0.3);
        this.playTone(1400, 'sine', 0.08, 0.25);
        this.playNoise(0.05, 0.15);
    }
}

const sfx = new SoundManager();

// =============================================================================
// PERSISTENT STATS & ACHIEVEMENTS MANAGER
// =============================================================================
function loadPersistent() {
    let saved = localStorage.getItem(PERSISTENT_KEY);
    
    // Migration: Check for old v16 data if v17 doesn't exist
    if (!saved) {
        const oldSaved = localStorage.getItem('zombie_persistent_v16');
        if (oldSaved) {
            saved = oldSaved;
            // Migrate to new key
            localStorage.setItem(PERSISTENT_KEY, saved);
            console.log('Migrated persistent data from v16 to v17');
        }
    }
    
    if (saved) {
        const data = JSON.parse(saved);
        // Merge with defaults to handle new fields (including class system)
        const merged = { ...JSON.parse(JSON.stringify(DEFAULT_PERSISTENT)), ...data };
        // Ensure class fields are properly initialized
        if (!merged.unlockedClasses || !Array.isArray(merged.unlockedClasses)) {
            merged.unlockedClasses = ['survivor'];
        }
        if (!merged.selectedClass) {
            merged.selectedClass = 'survivor';
        }
        if (merged.totalHPHealed === undefined) {
            merged.totalHPHealed = 0;
        }
        // Ensure upgrade fields are properly initialized
        if (!merged.unlockedUpgrades || !Array.isArray(merged.unlockedUpgrades)) {
            merged.unlockedUpgrades = [];
        }
        if (merged.highestLevelUnlocked === undefined) {
            merged.highestLevelUnlocked = 1;
        }
        // Ensure skill tree fields are properly initialized
        if (merged.skillPoints === undefined) {
            merged.skillPoints = 0;
        }
        if (merged.totalSkillPoints === undefined) {
            merged.totalSkillPoints = 0;
        }
        if (!merged.unlockedSkills || !Array.isArray(merged.unlockedSkills)) {
            merged.unlockedSkills = [];
        }
        if (merged.secondWindUsed === undefined) {
            merged.secondWindUsed = false;
        }
        // Ensure challenge fields are properly initialized
        if (!merged.activeDailies || !Array.isArray(merged.activeDailies)) {
            merged.activeDailies = [];
        }
        if (!merged.activeWeeklies || !Array.isArray(merged.activeWeeklies)) {
            merged.activeWeeklies = [];
        }
        if (!merged.completedPermanents || !Array.isArray(merged.completedPermanents)) {
            merged.completedPermanents = [];
        }
        if (!merged.weeklyUniqueLevels || !Array.isArray(merged.weeklyUniqueLevels)) {
            merged.weeklyUniqueLevels = [];
        }
        if (merged.dailyResetTime === undefined) merged.dailyResetTime = 0;
        if (merged.weeklyResetTime === undefined) merged.weeklyResetTime = 0;
        if (merged.weeklyKills === undefined) merged.weeklyKills = 0;
        if (merged.weeklyExtractions === undefined) merged.weeklyExtractions = 0;
        if (merged.weeklyBossKills === undefined) merged.weeklyBossKills = 0;
        if (merged.weeklyScrap === undefined) merged.weeklyScrap = 0;
        if (merged.crossbowKills === undefined) merged.crossbowKills = 0;
        if (merged.perfectLevels === undefined) merged.perfectLevels = 0;
        if (merged.runScrapCollected === undefined) merged.runScrapCollected = 0;
        // Ensure weapon mods fields are properly initialized
        if (!merged.modInventory || !Array.isArray(merged.modInventory)) {
            merged.modInventory = [];
        }
        return merged;
    }
    return JSON.parse(JSON.stringify(DEFAULT_PERSISTENT));
}

function savePersistent(data) {
    localStorage.setItem(PERSISTENT_KEY, JSON.stringify(data));
}

function resetRunStats(persistent) {
    persistent.runKills = 0;
    persistent.runShotsFired = 0;
    persistent.runShotsHit = 0;
    persistent.runDamageTaken = 0;
    persistent.runGrenadeKills = 0;
    persistent.runMeleeKills = 0;
    persistent.bossHitWithGun = false;
    persistent.secondWindUsed = false; // Reset Second Wind skill for new run
    // Challenge tracking resets
    persistent.runScrapCollected = 0;
    persistent.runLevelStartTime = Date.now();
    persistent.runWeaponUsed = null;
    return persistent;
}

// =============================================================================
// CHALLENGE SYSTEM - Daily/Weekly rotation and tracking
// =============================================================================

// Get next daily reset time (midnight UTC)
function getNextDailyReset() {
    const now = new Date();
    const tomorrow = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() + 1, 0, 0, 0));
    return tomorrow.getTime();
}

// Get next weekly reset time (Monday midnight UTC)
function getNextWeeklyReset() {
    const now = new Date();
    const dayOfWeek = now.getUTCDay(); // 0 = Sunday
    const daysUntilMonday = dayOfWeek === 0 ? 1 : (8 - dayOfWeek);
    const nextMonday = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() + daysUntilMonday, 0, 0, 0));
    return nextMonday.getTime();
}

// Check if challenges need to reset and rotate them
function checkChallengeReset(persistent) {
    const now = Date.now();
    let changed = false;
    
    // Check daily reset
    if (now >= persistent.dailyResetTime) {
        // Reset daily challenges
        persistent.activeDailies = selectChallenges(CONFIG.CHALLENGES.DAILY, 3);
        persistent.dailyResetTime = getNextDailyReset();
        changed = true;
    }
    
    // Check weekly reset
    if (now >= persistent.weeklyResetTime) {
        // Reset weekly challenges and weekly tracking stats
        persistent.activeWeeklies = selectChallenges(CONFIG.CHALLENGES.WEEKLY, 5);
        persistent.weeklyResetTime = getNextWeeklyReset();
        persistent.weeklyKills = 0;
        persistent.weeklyExtractions = 0;
        persistent.weeklyBossKills = 0;
        persistent.weeklyScrap = 0;
        persistent.weeklyUniqueLevels = [];
        changed = true;
    }
    
    return changed;
}

// Randomly select N challenges from a pool
function selectChallenges(pool, count) {
    const shuffled = [...pool].sort(() => Math.random() - 0.5);
    return shuffled.slice(0, count).map(c => ({ id: c.id, progress: 0 }));
}

// Update challenge progress based on a stat change
function updateChallengeProgress(persistent, stat, value) {
    // Update daily challenges
    persistent.activeDailies.forEach(challenge => {
        const config = CONFIG.CHALLENGES.DAILY.find(c => c.id === challenge.id);
        if (config && config.stat === stat) {
            challenge.progress = Math.min(value, config.target);
        }
    });
    
    // Update weekly challenges
    persistent.activeWeeklies.forEach(challenge => {
        const config = CONFIG.CHALLENGES.WEEKLY.find(c => c.id === challenge.id);
        if (config && config.stat === stat) {
            challenge.progress = Math.min(value, config.target);
        }
    });
}

// Check if a challenge is completed and award rewards
function checkChallengeCompletion(persistent) {
    const completed = [];
    
    // Check daily challenges
    persistent.activeDailies.forEach((challenge, index) => {
        const config = CONFIG.CHALLENGES.DAILY.find(c => c.id === challenge.id);
        if (config && challenge.progress >= config.target && !challenge.claimed) {
            // Award skill points
            persistent.skillPoints = (persistent.skillPoints || 0) + config.reward;
            persistent.totalSkillPoints = (persistent.totalSkillPoints || 0) + config.reward;
            challenge.claimed = true;
            completed.push({ ...config, type: 'daily' });
        }
    });
    
    // Check weekly challenges
    persistent.activeWeeklies.forEach((challenge, index) => {
        const config = CONFIG.CHALLENGES.WEEKLY.find(c => c.id === challenge.id);
        if (config && challenge.progress >= config.target && !challenge.claimed) {
            // Award skill points
            persistent.skillPoints = (persistent.skillPoints || 0) + config.reward;
            persistent.totalSkillPoints = (persistent.totalSkillPoints || 0) + config.reward;
            challenge.claimed = true;
            completed.push({ ...config, type: 'weekly' });
        }
    });
    
    // Check permanent challenges
    CONFIG.CHALLENGES.PERMANENT.forEach(config => {
        if (persistent.completedPermanents?.includes(config.id)) return;
        
        const currentValue = persistent[config.stat] || 0;
        if (currentValue >= config.target) {
            // Award cosmetic reward
            if (config.reward.type === 'skin') {
                // Add to unlocked upgrades for cosmetics
                if (!persistent.unlockedUpgrades) persistent.unlockedUpgrades = [];
                if (!persistent.unlockedUpgrades.includes(config.reward.id)) {
                    persistent.unlockedUpgrades.push(config.reward.id);
                    // Also add to CONFIG.UPGRADES dynamically if not exists
                    if (!CONFIG.UPGRADES[config.reward.id.toUpperCase()]) {
                        CONFIG.UPGRADES[config.reward.id.toUpperCase()] = {
                            id: config.reward.id, name: config.name + ' Skin', 
                            desc: 'Earned from challenge', category: 'skin',
                            icon: 'üèÜ', tint: config.reward.tint,
                            requirement: { stat: 'never', value: 999999 } // Already unlocked
                        };
                    }
                }
            } else if (config.reward.type === 'muzzle') {
                if (!persistent.unlockedUpgrades) persistent.unlockedUpgrades = [];
                if (!persistent.unlockedUpgrades.includes(config.reward.id)) {
                    persistent.unlockedUpgrades.push(config.reward.id);
                    if (!CONFIG.UPGRADES[config.reward.id.toUpperCase()]) {
                        CONFIG.UPGRADES[config.reward.id.toUpperCase()] = {
                            id: config.reward.id, name: config.name + ' Flash',
                            desc: 'Earned from challenge', category: 'muzzle',
                            icon: 'üèÜ', color: config.reward.color,
                            requirement: { stat: 'never', value: 999999 }
                        };
                    }
                }
            }
            
            if (!persistent.completedPermanents) persistent.completedPermanents = [];
            persistent.completedPermanents.push(config.id);
            completed.push({ ...config, type: 'permanent' });
        }
    });
    
    return completed;
}

// Format time remaining for display
function formatTimeRemaining(ms) {
    if (ms <= 0) return 'Now';
    const hours = Math.floor(ms / (1000 * 60 * 60));
    const minutes = Math.floor((ms % (1000 * 60 * 60)) / (1000 * 60));
    if (hours >= 24) {
        const days = Math.floor(hours / 24);
        const remHours = hours % 24;
        return `${days}d ${remHours}h`;
    }
    return `${hours}h ${minutes}m`;
}

// Check and unlock permanent upgrades based on persistent stats
function checkUpgrades(persistent) {
    const newUpgrades = [];
    if (!persistent.unlockedUpgrades) persistent.unlockedUpgrades = [];
    
    Object.values(CONFIG.UPGRADES).forEach(upgrade => {
        if (persistent.unlockedUpgrades.includes(upgrade.id)) return;
        
        const req = upgrade.requirement;
        const currentValue = persistent[req.stat] || 0;
        
        if (currentValue >= req.value) {
            persistent.unlockedUpgrades.push(upgrade.id);
            newUpgrades.push(upgrade);
        }
    });
    
    return newUpgrades;
}

// Generate starting stats with permanent upgrades applied
function getStartingStats(persistent) {
    const stats = JSON.parse(JSON.stringify(DEFAULT_STATS));
    
    if (!persistent.unlockedUpgrades) return stats;
    
    // Apply starting gear upgrades
    if (persistent.unlockedUpgrades.includes('start_shotgun')) stats.hasShotgun = true;
    if (persistent.unlockedUpgrades.includes('start_grenade')) stats.grenades = 1;
    if (persistent.unlockedUpgrades.includes('start_flashlight')) stats.hasFlashlight = true;
    if (persistent.unlockedUpgrades.includes('start_ammo')) stats.ammo += 20;
    
    // Apply stat boosts (HP)
    if (persistent.unlockedUpgrades.includes('hp_boost_1')) { stats.hp += 1; stats.maxHp += 1; }
    if (persistent.unlockedUpgrades.includes('hp_boost_2')) { stats.hp += 2; stats.maxHp += 2; }
    
    return stats;
}

function checkAchievements(persistent, context = {}) {
    const newAchievements = [];
    const a = CONFIG.ACHIEVEMENTS;
    
    // First Blood - kill first enemy
    if (!persistent.achievements.includes(a.FIRST_BLOOD.id) && persistent.totalKills >= 1) {
        persistent.achievements.push(a.FIRST_BLOOD.id);
        newAchievements.push(a.FIRST_BLOOD);
    }
    
    // Exterminator - kill 50 enemies
    if (!persistent.achievements.includes(a.EXTERMINATOR.id) && persistent.totalKills >= 50) {
        persistent.achievements.push(a.EXTERMINATOR.id);
        newAchievements.push(a.EXTERMINATOR);
    }
    
    // Sharpshooter - 50% accuracy in a run (min 20 shots)
    if (!persistent.achievements.includes(a.SHARPSHOOTER.id) && persistent.runShotsFired >= 20) {
        const accuracy = persistent.runShotsHit / persistent.runShotsFired;
        if (accuracy >= 0.5) {
            persistent.achievements.push(a.SHARPSHOOTER.id);
            newAchievements.push(a.SHARPSHOOTER);
        }
    }
    
    // Melee Master - kill boss with melee only (no gun hits on boss)
    if (!persistent.achievements.includes(a.MELEE_MASTER.id) && context.bossKilledMelee) {
        persistent.achievements.push(a.MELEE_MASTER.id);
        newAchievements.push(a.MELEE_MASTER);
    }
    
    // Survivor - complete first extraction
    if (!persistent.achievements.includes(a.SURVIVOR.id) && persistent.runsCompleted >= 1) {
        persistent.achievements.push(a.SURVIVOR.id);
        newAchievements.push(a.SURVIVOR);
    }
    
    // Veteran - complete 5 extractions
    if (!persistent.achievements.includes(a.VETERAN.id) && persistent.runsCompleted >= 5) {
        persistent.achievements.push(a.VETERAN.id);
        newAchievements.push(a.VETERAN);
    }
    
    // Grenadier - kill 3+ enemies with one grenade
    if (!persistent.achievements.includes(a.GRENADIER.id) && context.grenadeMultiKill >= 3) {
        persistent.achievements.push(a.GRENADIER.id);
        newAchievements.push(a.GRENADIER);
    }
    
    // Untouchable - complete level without damage
    if (!persistent.achievements.includes(a.UNTOUCHABLE.id) && context.levelCompletedNoDamage) {
        persistent.achievements.push(a.UNTOUCHABLE.id);
        newAchievements.push(a.UNTOUCHABLE);
    }
    
    // Scavenger - collect 100 scrap total
    if (!persistent.achievements.includes(a.SCAVENGER.id) && persistent.totalScrapCollected >= 100) {
        persistent.achievements.push(a.SCAVENGER.id);
        newAchievements.push(a.SCAVENGER);
    }
    
    // Fully Loaded - own all weapons
    if (!persistent.achievements.includes(a.FULLY_LOADED.id) && context.hasAllWeapons) {
        persistent.achievements.push(a.FULLY_LOADED.id);
        newAchievements.push(a.FULLY_LOADED);
    }
    
    // === CLASS UNLOCK ACHIEVEMENTS ===
    
    // Scout Unlock - Complete any level without being hit
    if (!persistent.achievements.includes(a.SCOUT_UNLOCK.id) && context.levelCompletedNoDamage) {
        persistent.achievements.push(a.SCOUT_UNLOCK.id);
        if (!persistent.unlockedClasses) persistent.unlockedClasses = ['survivor'];
        if (!persistent.unlockedClasses.includes('scout')) persistent.unlockedClasses.push('scout');
        newAchievements.push(a.SCOUT_UNLOCK);
    }
    
    // Medic Unlock - Heal 50 total HP across all runs
    if (!persistent.achievements.includes(a.MEDIC_UNLOCK.id) && persistent.totalHPHealed >= 50) {
        persistent.achievements.push(a.MEDIC_UNLOCK.id);
        if (!persistent.unlockedClasses) persistent.unlockedClasses = ['survivor'];
        if (!persistent.unlockedClasses.includes('medic')) persistent.unlockedClasses.push('medic');
        newAchievements.push(a.MEDIC_UNLOCK);
    }
    
    // Scavenger Unlock - Collect 500 total scrap
    if (!persistent.achievements.includes(a.SCAVENGER_UNLOCK.id) && persistent.totalScrapCollected >= 500) {
        persistent.achievements.push(a.SCAVENGER_UNLOCK.id);
        if (!persistent.unlockedClasses) persistent.unlockedClasses = ['survivor'];
        if (!persistent.unlockedClasses.includes('scavenger')) persistent.unlockedClasses.push('scavenger');
        newAchievements.push(a.SCAVENGER_UNLOCK);
    }
    
    return newAchievements;
}

// =============================================================================
// FLOATING TEXT POOL - Reuses text objects for performance
// =============================================================================
class FloatingTextPool {
    constructor(scene, poolSize = 20) {
        this.scene = scene;
        this.pool = [];
        for (let i = 0; i < poolSize; i++) {
            const text = scene.add.text(0, 0, '', {
                font: '16px Arial',
                stroke: '#000',
                strokeThickness: 3
            }).setOrigin(0.5).setDepth(101).setVisible(false);
            this.pool.push({ text, active: false });
        }
    }

    spawn(x, y, msg, color) {
        let item = this.pool.find(p => !p.active);
        if (!item) {
            const text = this.scene.add.text(x, y, msg, {
                font: '16px Arial',
                stroke: '#000',
                strokeThickness: 3
            }).setTint(color).setOrigin(0.5).setDepth(101);
            this.scene.tweens.add({
                targets: text,
                y: y - 50,
                alpha: 0,
                duration: 1500,
                onComplete: () => text.destroy()
            });
            return;
        }

        item.active = true;
        item.text.setPosition(x, y).setText(msg).setTint(color).setAlpha(1).setVisible(true);
        
        this.scene.tweens.add({
            targets: item.text,
            y: y - 50,
            alpha: 0,
            duration: 1500,
            onComplete: () => {
                item.text.setVisible(false);
                item.active = false;
            }
        });
    }
}

// =============================================================================
// PARTICLE POOL - For muzzle flashes and effects
// =============================================================================
class ParticlePool {
    constructor(scene, poolSize = 30) {
        this.scene = scene;
        this.pool = [];
        for (let i = 0; i < poolSize; i++) {
            const particle = scene.add.circle(0, 0, 8, 0xffff00)
                .setDepth(50).setVisible(false).setAlpha(0);
            this.pool.push({ particle, active: false });
        }
    }

    spawnMuzzleFlash(x, y, angle, size = 1, color = null) {
        // Spawn 3-5 particles for a flash effect
        const count = 3 + Math.floor(Math.random() * 3);
        // Use custom color or default yellow/orange
        const primaryColor = color || 0xffff00;
        const secondaryColor = color ? this.darkenColor(color) : 0xffaa00;
        
        for (let i = 0; i < count; i++) {
            let item = this.pool.find(p => !p.active);
            if (!item) continue;

            item.active = true;
            const spread = (Math.random() - 0.5) * 0.5;
            const dist = 20 + Math.random() * 15 * size;
            const px = x + Math.cos(angle + spread) * dist;
            const py = y + Math.sin(angle + spread) * dist;
            
            item.particle.setPosition(px, py)
                .setRadius(4 + Math.random() * 6 * size)
                .setFillStyle(Math.random() > 0.5 ? primaryColor : secondaryColor)
                .setVisible(true)
                .setAlpha(1);

            this.scene.tweens.add({
                targets: item.particle,
                alpha: 0,
                scaleX: 0.1,
                scaleY: 0.1,
                duration: 80 + Math.random() * 40,
                onComplete: () => {
                    item.particle.setVisible(false).setScale(1);
                    item.active = false;
                }
            });
        }
    }
    
    // Helper to darken a color for secondary flash
    darkenColor(color) {
        const r = ((color >> 16) & 0xff) * 0.7;
        const g = ((color >> 8) & 0xff) * 0.7;
        const b = (color & 0xff) * 0.7;
        return (Math.floor(r) << 16) | (Math.floor(g) << 8) | Math.floor(b);
    }
}

// =============================================================================
// HIT DIRECTION INDICATOR POOL
// =============================================================================
class HitIndicatorPool {
    constructor(scene, poolSize = 8) {
        this.scene = scene;
        this.pool = [];
        this.settings = loadSettings();
        
        for (let i = 0; i < poolSize; i++) {
            // Create arrow-shaped indicator
            const graphics = scene.add.graphics().setDepth(104).setVisible(false);
            this.pool.push({ graphics, active: false });
        }
    }
    
    // Show hit indicator from a specific direction (in radians)
    showHit(fromX, fromY, playerX, playerY) {
        if (!this.settings.hitIndicators) return;
        
        let item = this.pool.find(p => !p.active);
        if (!item) return;
        
        item.active = true;
        const g = item.graphics;
        g.clear();
        g.setVisible(true);
        g.setAlpha(0.8);
        
        // Calculate angle from player to damage source
        const angle = Phaser.Math.Angle.Between(playerX, playerY, fromX, fromY);
        
        // Draw directional indicator (arrow pointing toward damage source)
        const dist = CONFIG.UI.HIT_INDICATOR_DISTANCE;
        const size = CONFIG.UI.HIT_INDICATOR_SIZE;
        
        // Center of screen
        const cx = 400;
        const cy = 300;
        
        // Position the indicator on the edge of the screen based on angle
        const indicatorX = cx + Math.cos(angle) * dist * 2;
        const indicatorY = cy + Math.sin(angle) * dist * 2;
        
        // Draw red arrow/chevron pointing inward
        g.lineStyle(4, 0xff0000, 1);
        g.fillStyle(0xff0000, 0.6);
        
        // Arrow shape pointing toward center
        const tipX = indicatorX - Math.cos(angle) * size * 0.5;
        const tipY = indicatorY - Math.sin(angle) * size * 0.5;
        
        const leftX = indicatorX + Math.cos(angle + Math.PI * 0.7) * size * 0.4;
        const leftY = indicatorY + Math.sin(angle + Math.PI * 0.7) * size * 0.4;
        
        const rightX = indicatorX + Math.cos(angle - Math.PI * 0.7) * size * 0.4;
        const rightY = indicatorY + Math.sin(angle - Math.PI * 0.7) * size * 0.4;
        
        g.beginPath();
        g.moveTo(tipX, tipY);
        g.lineTo(leftX, leftY);
        g.lineTo(indicatorX, indicatorY);
        g.lineTo(rightX, rightY);
        g.closePath();
        g.fillPath();
        g.strokePath();
        
        // Fade out
        this.scene.tweens.add({
            targets: g,
            alpha: 0,
            duration: CONFIG.UI.HIT_INDICATOR_DURATION,
            onComplete: () => {
                g.setVisible(false);
                g.clear();
                item.active = false;
            }
        });
    }
    
    reloadSettings() {
        this.settings = loadSettings();
    }
}

// =============================================================================
// MAIN MENU SCENE
// =============================================================================
class MainMenuScene extends Phaser.Scene {
    constructor() { super('MainMenuScene'); }
    
    create() {
        this.input.on('pointerdown', () => sfx.resume());

        // Clean dark background
        this.add.rectangle(400, 300, 800, 600, 0x0a0a0a);
        this.add.grid(400, 300, 800, 600, 64, 64, 0x151515).setAlpha(0.3);
        
        // Title
        this.add.text(400, 150, "ZOMBIE", { fontSize: '72px', fill: '#00ff00', fontStyle: 'bold' }).setOrigin(0.5);
        this.add.text(400, 220, "EXTRACTION", { fontSize: '48px', fill: '#008800' }).setOrigin(0.5);

        // Main buttons - centered
        this.createButton(400, 320, "NEW RUN", 0x880000, () => {
            if(confirm("Start a new run? This overwrites current auto-save.")) {
                localStorage.removeItem(CONFIG.SAVE_KEY);
                const persistent = loadPersistent();
                const stats = getStartingStats(persistent);
                sfx.levelStart();
                this.scene.start('HideoutScene', { stats: stats });
            }
        });

        this.createButton(400, 390, "CONTINUE", 0x004488, () => {
            let saved = localStorage.getItem(CONFIG.SAVE_KEY);
            if (!saved) {
                const oldSaved = localStorage.getItem('zombie_save_v16');
                if (oldSaved) {
                    saved = oldSaved;
                    localStorage.setItem(CONFIG.SAVE_KEY, saved);
                }
            }
            if (saved) {
                try {
                    let stats = JSON.parse(saved);
                    if (stats.hp === undefined || stats.hideout === undefined) {
                        throw new Error("Invalid save data");
                    }
                    // Migration for old saves
                    if (!stats.magazines) {
                        stats.magazines = {
                            pistol: CONFIG.WEAPONS.PISTOL.MAG_SIZE,
                            shotgun: CONFIG.WEAPONS.SHOTGUN.MAG_SIZE,
                            smg: CONFIG.WEAPONS.SMG.MAG_SIZE,
                            crossbow: CONFIG.WEAPONS.CROSSBOW.MAG_SIZE,
                            rifle: CONFIG.WEAPONS.RIFLE.MAG_SIZE
                        };
                    }
                    if (stats.magazines.crossbow === undefined) stats.magazines.crossbow = CONFIG.WEAPONS.CROSSBOW.MAG_SIZE;
                    if (stats.magazines.rifle === undefined) stats.magazines.rifle = CONFIG.WEAPONS.RIFLE.MAG_SIZE;
                    if (stats.hasCrossbow === undefined) stats.hasCrossbow = false;
                    if (stats.hasRifle === undefined) stats.hasRifle = false;
                    if (!stats.currentWeapon) stats.currentWeapon = 'pistol';
                    if (stats.nextLevel === undefined) stats.nextLevel = 1;
                    if (stats.highestLevelUnlocked === undefined) stats.highestLevelUnlocked = stats.nextLevel || 1;
                    if (!stats.consumables || !Array.isArray(stats.consumables)) stats.consumables = [null, null, null];
                    while (stats.consumables.length < 3) stats.consumables.push(null);
                    if (!stats.equippedMods) {
                        stats.equippedMods = {
                            pistol: [null, null], shotgun: [null, null], smg: [null, null],
                            crossbow: [null, null], rifle: [null, null]
                        };
                    }
                    sfx.menuOpen();
                    this.scene.start('HideoutScene', { stats });
                } catch (e) {
                    sfx.error();
                    alert("Save data corrupted. Please start a new game.");
                    localStorage.removeItem(CONFIG.SAVE_KEY);
                }
            } else {
                sfx.error();
                alert("No save found! Start a New Run first.");
            }
        });

        // Bottom icon bar
        const iconY = 550;
        const iconSize = 40;
        
        // Settings cog (left)
        const settingsBtn = this.add.rectangle(50, iconY, iconSize, iconSize, 0x333333).setInteractive();
        this.add.text(50, iconY, "‚öôÔ∏è", { fontSize: '24px' }).setOrigin(0.5);
        settingsBtn.on('pointerdown', () => { sfx.menuOpen(); this.showSettingsMenu(); });
        settingsBtn.on('pointerover', () => settingsBtn.setFillStyle(0x444444));
        settingsBtn.on('pointerout', () => settingsBtn.setFillStyle(0x333333));
        
        // Export icon
        const exportBtn = this.add.rectangle(720, iconY, iconSize, iconSize, 0x333333).setInteractive();
        this.add.text(720, iconY, "üì§", { fontSize: '20px' }).setOrigin(0.5);
        exportBtn.on('pointerdown', () => this.exportSave());
        exportBtn.on('pointerover', () => exportBtn.setFillStyle(0x444444));
        exportBtn.on('pointerout', () => exportBtn.setFillStyle(0x333333));
        
        // Import icon
        const importBtn = this.add.rectangle(770, iconY, iconSize, iconSize, 0x333333).setInteractive();
        this.add.text(770, iconY, "üì•", { fontSize: '20px' }).setOrigin(0.5);
        importBtn.on('pointerdown', () => this.importSave());
        importBtn.on('pointerover', () => importBtn.setFillStyle(0x444444));
        importBtn.on('pointerout', () => importBtn.setFillStyle(0x333333));
        
        // Tooltips
        this.add.text(50, iconY + 28, "Settings", { fontSize: '10px', fill: '#666' }).setOrigin(0.5);
        this.add.text(720, iconY + 28, "Export", { fontSize: '10px', fill: '#666' }).setOrigin(0.5);
        this.add.text(770, iconY + 28, "Import", { fontSize: '10px', fill: '#666' }).setOrigin(0.5);
    }
    
    exportSave() {
        let saved = localStorage.getItem(CONFIG.SAVE_KEY);
        if (!saved) { sfx.error(); alert("No save data to export."); return; }
        
        const blob = new Blob([saved], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `zombie_save_${new Date().toISOString().slice(0,10)}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        sfx.success();
    }
    
    importSave() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const json = JSON.parse(event.target.result);
                    if (json.hp !== undefined && json.hideout !== undefined) {
                        localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(json));
                        sfx.success();
                        alert("Save imported successfully!");
                    } else {
                        sfx.error();
                        alert("Invalid save file format.");
                    }
                } catch (err) {
                    sfx.error();
                    alert("Error reading file.");
                }
            };
            reader.readAsText(file);
        };
        input.click();
    }
    
    showSettingsMenu() {
        const settings = loadSettings();
        const elements = [];
        
        // Overlay background (taller to fit controls)
        const overlay = this.add.rectangle(400, 300, 550, 520, 0x111111, 0.98).setDepth(500);
        elements.push(overlay);
        
        const title = this.add.text(400, 65, "SETTINGS", { fontSize: '28px', fill: '#fff' }).setOrigin(0.5).setDepth(501);
        elements.push(title);
        
        // Controls section
        const controlsLabel = this.add.text(400, 100, "CONTROLS", { fontSize: '12px', fill: '#888' }).setOrigin(0.5).setDepth(501);
        elements.push(controlsLabel);
        
        const controlsBg = this.add.rectangle(400, 155, 500, 80, 0x1a1a1a).setDepth(501);
        elements.push(controlsBg);
        
        const controlsText = this.add.text(400, 155, 
            "WASD: Move  |  Mouse: Aim/Fire  |  SPACE: Dodge  |  R: Reload\n" +
            "G: Grenade  |  TAB: Inventory  |  N: NVG  |  F: Interact\n" +
            "Q: Switch Weapon  |  E: Melee  |  1/2/3: Consumables", 
            { fontSize: '11px', fill: '#aaa', align: 'center', lineSpacing: 6 }
        ).setOrigin(0.5).setDepth(502);
        elements.push(controlsText);
        
        // Master Volume Slider
        const masterLabel = this.add.text(170, 205, "MASTER VOLUME", { fontSize: '13px', fill: '#aaa' }).setDepth(501);
        elements.push(masterLabel);
        
        const masterSliderBg = this.add.rectangle(400, 230, 280, 16, 0x333333).setDepth(501);
        elements.push(masterSliderBg);
        
        const masterSliderFill = this.add.rectangle(260, 230, settings.masterVolume * 280, 12, 0x00ff00).setOrigin(0, 0.5).setDepth(502);
        elements.push(masterSliderFill);
        
        const masterPercent = this.add.text(550, 230, `${Math.round(settings.masterVolume * 100)}%`, { fontSize: '11px', fill: '#fff' }).setOrigin(0, 0.5).setDepth(501);
        elements.push(masterPercent);
        
        masterSliderBg.setInteractive();
        masterSliderBg.on('pointerdown', (pointer) => {
            const relX = (pointer.x - 260) / 280;
            const newVol = Phaser.Math.Clamp(relX, 0, 1);
            settings.masterVolume = newVol;
            sfx.setMasterVolume(newVol);
            masterSliderFill.width = newVol * 280;
            masterPercent.setText(`${Math.round(newVol * 100)}%`);
            sfx.click();
        });
        
        // SFX Volume Slider
        const sfxLabel = this.add.text(170, 255, "SFX VOLUME", { fontSize: '13px', fill: '#aaa' }).setDepth(501);
        elements.push(sfxLabel);
        
        const sfxSliderBg = this.add.rectangle(400, 280, 280, 16, 0x333333).setDepth(501);
        elements.push(sfxSliderBg);
        
        const sfxSliderFill = this.add.rectangle(260, 280, settings.sfxVolume * 280, 12, 0x00aaff).setOrigin(0, 0.5).setDepth(502);
        elements.push(sfxSliderFill);
        
        const sfxPercent = this.add.text(550, 280, `${Math.round(settings.sfxVolume * 100)}%`, { fontSize: '11px', fill: '#fff' }).setOrigin(0, 0.5).setDepth(501);
        elements.push(sfxPercent);
        
        sfxSliderBg.setInteractive();
        sfxSliderBg.on('pointerdown', (pointer) => {
            const relX = (pointer.x - 260) / 280;
            const newVol = Phaser.Math.Clamp(relX, 0, 1);
            settings.sfxVolume = newVol;
            sfx.setSfxVolume(newVol);
            sfxSliderFill.width = newVol * 280;
            sfxPercent.setText(`${Math.round(newVol * 100)}%`);
            sfx.click();
        });
        
        // Screen Shake Toggle
        const shakeLabel = this.add.text(170, 315, "SCREEN SHAKE", { fontSize: '13px', fill: '#aaa' }).setDepth(501);
        elements.push(shakeLabel);
        
        const shakeToggle = this.add.rectangle(510, 315, 65, 24, settings.screenShake ? 0x00ff00 : 0x444444).setDepth(501).setInteractive();
        elements.push(shakeToggle);
        
        const shakeText = this.add.text(510, 315, settings.screenShake ? "ON" : "OFF", { fontSize: '11px', fill: '#fff' }).setOrigin(0.5).setDepth(502);
        elements.push(shakeText);
        
        shakeToggle.on('pointerdown', () => {
            settings.screenShake = !settings.screenShake;
            shakeToggle.setFillStyle(settings.screenShake ? 0x00ff00 : 0x444444);
            shakeText.setText(settings.screenShake ? "ON" : "OFF");
            saveSettings(settings);
            sfx.click();
        });
        
        // Hit Indicators Toggle
        const hitToggle = this.add.rectangle(510, 350, 65, 24, settings.hitIndicators ? 0x00ff00 : 0x444444).setDepth(501).setInteractive();
        elements.push(hitToggle);
        
        const hitText = this.add.text(510, 350, settings.hitIndicators ? "ON" : "OFF", { fontSize: '11px', fill: '#fff' }).setOrigin(0.5).setDepth(502);
        elements.push(hitText);
        
        hitToggle.on('pointerdown', () => {
            settings.hitIndicators = !settings.hitIndicators;
            hitToggle.setFillStyle(settings.hitIndicators ? 0x00ff00 : 0x444444);
            hitText.setText(settings.hitIndicators ? "ON" : "OFF");
            saveSettings(settings);
            sfx.click();
        });
        
        // Separator
        const sep = this.add.rectangle(400, 390, 450, 1, 0x444444).setDepth(501);
        elements.push(sep);
        
        // Cheat Code button (developer/debug)
        const cheatBtn = this.add.text(400, 420, "[ ENTER CHEAT CODE ]", { fontSize: '12px', fill: '#555' }).setOrigin(0.5).setDepth(501).setInteractive();
        elements.push(cheatBtn);
        
        cheatBtn.on('pointerdown', () => {
            const code = prompt("ENTER CHEAT CODE:");
            if (code === 'god mode') {
                elements.forEach(e => e.destroy());
                this.activateGodMode();
            }
        });
        cheatBtn.on('pointerover', () => cheatBtn.setFill('#888'));
        cheatBtn.on('pointerout', () => cheatBtn.setFill('#555'));
        
        // Close button
        const closeBtn = this.add.text(400, 510, "[ CLOSE ]", { fontSize: '16px', fill: '#ff4444' }).setOrigin(0.5).setDepth(501).setInteractive();
        elements.push(closeBtn);
        
        closeBtn.on('pointerdown', () => {
            sfx.menuClose();
            elements.forEach(e => e.destroy());
        });
    }

    createButton(x, y, text, color, callback) {
        let btn = this.add.rectangle(x, y, 300, 50, color).setInteractive();
        this.add.text(x, y, text, { fontSize: '22px', fill: '#fff', fontStyle: 'bold' }).setOrigin(0.5);
        btn.on('pointerdown', () => { sfx.click(); callback(); });
        btn.on('pointerover', () => btn.setAlpha(0.8));
        btn.on('pointerout', () => btn.setAlpha(1));
    }

    activateGodMode() {
        const godStats = {
            hp: 20, maxHp: 20, stamina: 100, maxStamina: 100, ammo: 999, scrap: 999,
            credits: 999, materials: 999,
            grenades: CONFIG.GRENADE.MAX_CARRY,
            nextLevel: 1,
            highestLevelUnlocked: 7,  // All levels unlocked in god mode
            consumables: ['adrenaline', 'armor_patch', 'adrenaline'],  // Full consumables
            hasFlashlight: true, hasShotgun: true, hasSMG: true, hasCrossbow: true, hasRifle: true, currentWeapon: 'shotgun',
            magazines: {
                pistol: CONFIG.WEAPONS.PISTOL.MAG_SIZE,
                shotgun: CONFIG.WEAPONS.SHOTGUN.MAG_SIZE,
                smg: CONFIG.WEAPONS.SMG.MAG_SIZE,
                crossbow: CONFIG.WEAPONS.CROSSBOW.MAG_SIZE,
                rifle: CONFIG.WEAPONS.RIFLE.MAG_SIZE
            },
            armor: {
                head: { name: 'GOD HELM', durability: 100, maxDurability: 100 },
                body: { name: 'GOD VEST', durability: 100, maxDurability: 100 },
                arms: { name: 'GOD ARMS', durability: 100, maxDurability: 100 },
                feet: { name: 'GOD BOOTS', durability: 100, maxDurability: 100 }
            },
            hideout: {
                restAreaLvl: 2, generatorLvl: 1, hasSparkPlug: true,
                armory: { crafting: null, hasNVG: true },
                workbenchLvl: 1, repairStationLvl: 1
            }
        };
        localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(godStats));
        alert("GOD MODE ACTIVATED");
        this.scene.start('HideoutScene', { stats: godStats });
    }
}

// =============================================================================
// BULLET CLASS
// =============================================================================
class Bullet extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y) { 
        super(scene, x, y, 'bullet'); 
    }
    
    fire(x, y, targetX, targetY, spreadAngle = 0, isEnemy = false) {
        this.body.reset(x, y);
        this.body.enable = true; 
        this.setActive(true);
        this.setVisible(true);
        this.hasHit = false;
        this.isEnemyBullet = isEnemy; 
        this.setTint(isEnemy ? 0xff0000 : 0xffff00);
        
        // Reset pooled bullet properties
        this.hitEnemies = new Set();
        this.isPiercing = false;
        this.pierceCount = 0;
        this.crossbowDamage = 0;
        this.rifleDamage = 0;
        
        if (isEnemy) sfx.shootPistol();

        let baseAngle = Phaser.Math.Angle.Between(x, y, targetX, targetY);
        let finalAngle = baseAngle + Phaser.Math.DegToRad(spreadAngle);
        this.scene.physics.velocityFromRotation(finalAngle, CONFIG.WEAPONS.BULLET_SPEED, this.body.velocity);
        this.setRotation(finalAngle);
    }
    
    preUpdate(time, delta) {
        super.preUpdate(time, delta);
        if (this.y < -50 || this.y > 650 || this.x < -50 || this.x > 850) {
            this.setActive(false);
            this.setVisible(false);
            this.body.enable = false;
        }
    }
}

// =============================================================================
// ENEMY CLASS
// =============================================================================
class Enemy extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y, target, type) {
        const cfg = CONFIG.ENEMIES[type.toUpperCase()] || CONFIG.ENEMIES.WALKER;
        super(scene, x, y, cfg.TEXTURE);
        
        scene.add.existing(this);
        scene.physics.add.existing(this);
        
        this.target = target;
        this.enemyType = type;
        this.config = cfg;
        this.canTakeDamage = true;
        this.healthBar = scene.add.graphics().setDepth(100).setVisible(false);
        this.lastFired = 0;
        this.isInvulnerable = false;

        this.hp = cfg.HP;
        this.maxHp = cfg.HP;
        this.speed = cfg.SPEED;
        this.damage = cfg.DAMAGE;

        if (type === 'boss') {
            this.setScale(cfg.SCALE);
            this.setTint(0xff0000);
        } else if (type === 'leaper') {
            this.state = 'CHASE';
            this.leapTimer = 0;
            this.setTexture('leaper_idle_0'); // Use individual frame texture
            this.setScale(0.5); // Scale down to fit game
            this.play('leaper_crawl'); // Start crawling animation
        } else if (type === 'bandit') {
            this.ammo = cfg.AMMO;
            this.state = 'CHASE';
        } else if (type === 'spitter') {
            this.lastSpit = 0;
            this.setTint(0x00ff00); // Green tint for toxic look
        } else if (type === 'exploder') {
            this.setTint(0xff6600); // Orange tint for explosive look
            this.setScale(1.2); // Slightly bloated
            // Pulsing effect
            this.scene.tweens.add({
                targets: this,
                scaleX: 1.3,
                scaleY: 1.3,
                duration: 500,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });
        } else if (type === 'necromancer') {
            this.setTint(0x8800ff); // Purple tint
            this.setScale(1.5);
            this.phase = 'SUMMON'; // SUMMON, VULNERABLE, ATTACK
            this.phaseTimer = 0;
            this.lastTeleport = 0;
            this.summonedMinions = [];
            this.isInvulnerable = true; // Starts invulnerable
        }
    }
    
    takeDamage(amount, killSource = 'gun') {
        if (!this.active || !this.canTakeDamage || this.isInvulnerable) return;
        
        this.lastDamageSource = killSource; // Track what damaged us
        this.hp -= amount;
        sfx.enemyHit();
        this.setTint(0xffffff);
        this.scene.time.delayedCall(50, () => { if (this.active) this.clearTint(); });
        this.updateHealthBar();
        
        if (this.enemyType === 'boss' || this.enemyType === 'necromancer') {
            this.scene.updateBossBar(this.hp, this.maxHp);
            this.canTakeDamage = false;
            this.isInvulnerable = true;
            this.flashTween = this.scene.tweens.add({
                targets: this,
                alpha: 0.5,
                duration: 100,
                yoyo: true,
                repeat: 4,
                onComplete: () => {
                    if (this.active) {
                        this.setAlpha(1);
                        this.canTakeDamage = true;
                        this.isInvulnerable = false;
                    }
                }
            });
        }
        
            if (this.hp <= 0) {
            // Check for melee-only boss kill achievement
            const bossKilledMelee = this.enemyType === 'boss' && !this.scene.persistent.bossHitWithGun;
            
            // Play death sound
            sfx.enemyDeath();
            
            // Exploder explosion on death
            if (this.enemyType === 'exploder') {
                this.scene.exploderExplosion(this.x, this.y);
            }
            
            // Necromancer special death
            if (this.enemyType === 'necromancer') {
                sfx.necroDeath();
                this.scene.showFloatingText(this.x, this.y, "VANQUISHED!", 0x8800ff);
                // Kill any remaining minions
                this.summonedMinions.forEach(m => {
                    if (m.active) m.takeDamage(100);
                });
            }
            
            if (this.enemyType === 'boss' && this.scene.currentLevel === 5) {
                this.scene.spawnSwitch(this.x, this.y);
            }
            
            // Necromancer on level 7 spawns switch
            if (this.enemyType === 'necromancer' && this.scene.currentLevel === 7) {
                this.scene.spawnSwitch(this.x, this.y);
            }
            
            this.scene.spawnLootSkull(this.x, this.y, this.enemyType, this.lastDamageSource);
            
            // Check melee master achievement for boss
            if (bossKilledMelee && this.lastDamageSource === 'melee') {
                const newAchievements = checkAchievements(this.scene.persistent, { bossKilledMelee: true });
                newAchievements.forEach(a => {
                    sfx.achievement();
                    this.scene.showFloatingText(400, 200, `${a.icon} ${a.name}!`, 0xffd700);
                });
                savePersistent(this.scene.persistent);
            }
            
            // Leaper death animation - play then destroy after delay
            if (this.enemyType === 'leaper') {
                this.body.enable = false; // Disable physics so it doesn't block
                this.play('leaper_death');
                this.scene.time.delayedCall(600, () => {
                    if (this.active) this.destroy();
                });
            } else {
                this.destroy();
            }
        }
    }
    
    updateHealthBar() {
        if (this.hp <= 0) { this.healthBar.setVisible(false); return; }
        this.healthBar.setVisible(true);
        this.healthBar.clear();
        const w = 40, h = 6, x = -w / 2, y = -40;
        this.healthBar.fillStyle(0xff0000);
        this.healthBar.fillRect(x, y, w, h);
        this.healthBar.fillStyle(0x00ff00);
        this.healthBar.fillRect(x, y, w * (this.hp / this.maxHp), h);
    }
    
    knockBack() {
        const speed = (this.enemyType === 'leaper') ? CONFIG.ENEMIES.LEAPER.KNOCKBACK_SPEED : CONFIG.ENEMIES.KNOCKBACK_SPEED;
        if (this.enemyType === 'leaper') {
            this.state = 'COOLDOWN';
            this.leapTimer = CONFIG.ENEMIES.LEAPER.COOLDOWN_TIME;
        }
        const angle = Phaser.Math.Angle.Between(this.target.x, this.target.y, this.x, this.y);
        this.scene.physics.velocityFromRotation(angle, speed, this.body.velocity);
    }
    
    update(time, delta) {
        if (!this.active || !this.body) return;
        if (this.healthBar) this.healthBar.setPosition(this.x, this.y);

        const cfg = this.config;

        if (this.enemyType === 'bandit') {
            const dist = Phaser.Math.Distance.Between(this.x, this.y, this.target.x, this.target.y);
            if (this.ammo > 0) {
                if (dist < cfg.FIRE_RANGE) {
                    this.setVelocity(0);
                    if (time - this.lastFired > cfg.FIRE_RATE) {
                        const b = this.scene.bullets.get(this.x, this.y);
                        if (b) {
                            b.fire(this.x, this.y, this.target.x, this.target.y, Phaser.Math.Between(-cfg.SPREAD, cfg.SPREAD), true);
                            this.ammo--;
                            this.lastFired = time;
                        }
                    }
                } else {
                    this.scene.physics.moveToObject(this, this.target, this.speed);
                }
            } else {
                this.scene.physics.moveToObject(this, this.target, cfg.MELEE_SPEED);
            }
            return;
        }

        if (this.enemyType === 'spitter') {
            const dist = Phaser.Math.Distance.Between(this.x, this.y, this.target.x, this.target.y);
            if (dist < cfg.SPIT_RANGE) {
                this.setVelocity(0);
                if (time - this.lastSpit > cfg.SPIT_COOLDOWN) {
                    // Spit acid at player
                    this.scene.spawnAcidSpit(this.x, this.y, this.target.x, this.target.y);
                    this.lastSpit = time;
                    sfx.spit();
                    // Visual feedback - flash when spitting
                    this.setTint(0xffff00);
                    this.scene.time.delayedCall(100, () => { if (this.active) this.setTint(0x00ff00); });
                }
            } else {
                this.scene.physics.moveToObject(this, this.target, this.speed);
            }
            return;
        }

        if (this.enemyType === 'boss') {
            this.scene.physics.moveToObject(this, this.target, this.speed);
        } else if (this.enemyType === 'walker') {
            // Patrol enemies are handled separately
            if (this.isPatrol) return;
            if (Phaser.Math.Distance.Between(this.x, this.y, this.target.x, this.target.y) < cfg.AGGRO_RANGE) {
                this.scene.physics.moveToObject(this, this.target, this.speed);
            }
        } else if (this.enemyType === 'leaper') {
            const dist = Phaser.Math.Distance.Between(this.x, this.y, this.target.x, this.target.y);
            switch (this.state) {
                case 'CHASE':
                    // Play crawl animation if not already playing
                    if (this.anims.currentAnim?.key !== 'leaper_crawl') {
                        this.play('leaper_crawl');
                    }
                    this.scene.physics.moveToObject(this, this.target, cfg.SPEED);
                    // Flip sprite based on movement direction
                    this.setFlipX(this.body.velocity.x < 0);
                    if (dist < cfg.LEAP_RANGE) {
                        this.state = 'PREPARE';
                        this.setVelocity(0);
                        this.leapTimer = cfg.PREPARE_TIME;
                        this.play('leaper_attack'); // Start attack animation
                        sfx.leaperPrepare();
                    }
                    break;
                case 'PREPARE':
                    this.leapTimer -= delta;
                    if (this.leapTimer <= 0) {
                        this.state = 'LEAP';
                        this.scene.physics.moveToObject(this, this.target, cfg.LEAP_SPEED);
                        this.leapTimer = cfg.LEAP_DURATION;
                        sfx.leaperLeap();
                    }
                    break;
                case 'LEAP':
                    this.leapTimer -= delta;
                    if (this.leapTimer <= 0) {
                        this.state = 'COOLDOWN';
                        this.setVelocity(0);
                        this.leapTimer = cfg.COOLDOWN_TIME;
                        this.play('leaper_idle'); // Idle/breathing after leap
                    }
                    break;
                case 'PINNING':
                    break;
                case 'COOLDOWN':
                    this.leapTimer -= delta;
                    if (this.leapTimer <= 0) {
                        this.state = 'CHASE';
                        this.play('leaper_crawl'); // Back to crawling
                    }
                    break;
            }
        } else if (this.enemyType === 'exploder') {
            // Exploder just charges directly at player at high speed
            this.scene.physics.moveToObject(this, this.target, this.speed);
            // Play warning sound periodically
            if (!this.lastWarning || time - this.lastWarning > 1000) {
                sfx.exploderWarning();
                this.lastWarning = time;
            }
        } else if (this.enemyType === 'necromancer') {
            // Necromancer boss phases
            this.updateNecromancerAI(time, delta);
        }
    }
    
    updateNecromancerAI(time, delta) {
        const cfg = CONFIG.ENEMIES.NECROMANCER;
        
        switch (this.phase) {
            case 'SUMMON':
                this.setVelocity(0);
                if (!this.hasSummoned) {
                    this.hasSummoned = true;
                    // Summon minions
                    for (let i = 0; i < cfg.SUMMON_COUNT; i++) {
                        const angle = (i / cfg.SUMMON_COUNT) * Math.PI * 2;
                        const spawnX = this.x + Math.cos(angle) * 100;
                        const spawnY = this.y + Math.sin(angle) * 100;
                        const minion = new Enemy(this.scene, spawnX, spawnY, this.target, 'walker');
                        this.scene.enemies.add(minion);
                        this.summonedMinions.push(minion);
                        // Summon visual effect
                        this.scene.showFloatingText(spawnX, spawnY, "RISE!", 0x8800ff);
                    }
                    sfx.necroSummon();
                    this.isInvulnerable = true;
                    this.setTint(0x8800ff);
                }
                // Check if all minions are dead
                this.summonedMinions = this.summonedMinions.filter(m => m.active);
                if (this.summonedMinions.length === 0) {
                    this.phase = 'VULNERABLE';
                    this.phaseTimer = cfg.VULNERABLE_TIME;
                    this.isInvulnerable = false;
                    this.setTint(0xff00ff); // Bright purple when vulnerable
                    sfx.necroVulnerable();
                    this.scene.showFloatingText(this.x, this.y - 40, "VULNERABLE!", 0xff00ff);
                }
                break;
                
            case 'VULNERABLE':
                this.phaseTimer -= delta;
                // Attack while vulnerable
                if (time - this.lastFired > 1500) {
                    this.fireNecroProjectile();
                    this.lastFired = time;
                }
                // Teleport periodically
                if (time - this.lastTeleport > cfg.TELEPORT_COOLDOWN) {
                    this.teleport();
                    this.lastTeleport = time;
                }
                if (this.phaseTimer <= 0) {
                    this.phase = 'SUMMON';
                    this.hasSummoned = false;
                    this.isInvulnerable = true;
                    this.setTint(0x8800ff);
                }
                break;
        }
    }
    
    fireNecroProjectile() {
        const cfg = CONFIG.ENEMIES.NECROMANCER;
        const angle = Phaser.Math.Angle.Between(this.x, this.y, this.target.x, this.target.y);
        // Create acid-like projectile
        this.scene.spawnNecroProjectile(this.x, this.y, this.target.x, this.target.y);
        sfx.necroProjectile();
    }
    
    teleport() {
        // Teleport to random position in arena
        const newX = Phaser.Math.Between(150, 650);
        const newY = Phaser.Math.Between(100, 300);
        
        // Teleport effect
        this.scene.tweens.add({
            targets: this,
            alpha: 0,
            duration: 200,
            onComplete: () => {
                this.setPosition(newX, newY);
                this.scene.tweens.add({
                    targets: this,
                    alpha: 1,
                    duration: 200
                });
            }
        });
        sfx.necroTeleport();
    }
    
    destroy(fromScene) {
        if (this.healthBar) this.healthBar.destroy();
        if (this.flashTween) this.flashTween.stop();
        super.destroy(fromScene);
    }
}

// =============================================================================
// HIDEOUT SCENE
// =============================================================================
class HideoutScene extends Phaser.Scene {
    constructor() { super('HideoutScene'); }
    
    create(data) {
        // Clean up any lingering references from previous scene
        this.mapNodes = null;
        this.mapElements = null;
        this.mapInfoText = null;
        this.mapStatusText = null;
        this.selectedLevel = null;
        
        this.stats = data.stats;
        // Ensure magazines exist
        if (!this.stats.magazines) {
            this.stats.magazines = {
                pistol: CONFIG.WEAPONS.PISTOL.MAG_SIZE,
                shotgun: CONFIG.WEAPONS.SHOTGUN.MAG_SIZE,
                smg: CONFIG.WEAPONS.SMG.MAG_SIZE,
                crossbow: CONFIG.WEAPONS.CROSSBOW.MAG_SIZE,
                rifle: CONFIG.WEAPONS.RIFLE.MAG_SIZE
            };
        }
        // Ensure new weapon magazines exist
        if (this.stats.magazines.crossbow === undefined) this.stats.magazines.crossbow = CONFIG.WEAPONS.CROSSBOW.MAG_SIZE;
        if (this.stats.magazines.rifle === undefined) this.stats.magazines.rifle = CONFIG.WEAPONS.RIFLE.MAG_SIZE;
        // Ensure new weapon flags exist
        if (this.stats.hasCrossbow === undefined) this.stats.hasCrossbow = false;
        if (this.stats.hasRifle === undefined) this.stats.hasRifle = false;
        // Ensure grenades exist for old saves
        if (this.stats.grenades === undefined) {
            this.stats.grenades = 0;
        }
        // Ensure new hideout fields exist
        if (this.stats.hideout.workbenchLvl === undefined) {
            this.stats.hideout.workbenchLvl = 0;
        }
        if (this.stats.hideout.repairStationLvl === undefined) {
            this.stats.hideout.repairStationLvl = 0;
        }
        // Ensure new currency fields exist
        if (this.stats.credits === undefined) {
            this.stats.credits = 0;
        }
        if (this.stats.materials === undefined) {
            this.stats.materials = 0;
        }
        // Ensure consumables is a valid array
        if (!this.stats.consumables || !Array.isArray(this.stats.consumables)) {
            this.stats.consumables = [null, null, null];
        }
        while (this.stats.consumables.length < 3) {
            this.stats.consumables.push(null);
        }
        // Ensure nextLevel exists for old saves
        if (this.stats.nextLevel === undefined) {
            this.stats.nextLevel = 1;
        }
        // Ensure highestLevelUnlocked exists (default to nextLevel for old saves)
        if (this.stats.highestLevelUnlocked === undefined) {
            this.stats.highestLevelUnlocked = this.stats.nextLevel || 1;
        }
        // Ensure equippedMods exists for weapon mods system
        if (!this.stats.equippedMods) {
            this.stats.equippedMods = {
                pistol: [null, null],
                shotgun: [null, null],
                smg: [null, null],
                crossbow: [null, null],
                rifle: [null, null]
            };
        }
        
        // Load persistent stats
        this.persistent = loadPersistent();
        
        localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));
        
        // Check and rotate challenges on hideout load
        if (checkChallengeReset(this.persistent)) {
            savePersistent(this.persistent);
        }

        // Initialize tab content array for cleanup
        this.tabContent = [];
        this.currentTab = 'facilities';
        
        // Render persistent UI elements
        this.renderBackground();
        this.renderHeader();
        this.renderTabs();
        this.renderFooter();
        
        // Show default tab
        this.showTab('facilities');
    }
    
    renderBackground() {
        this.add.rectangle(400, 300, 800, 600, 0x1a1a1a);
        this.add.grid(400, 300, 800, 600, 32, 32, 0x222222).setAlpha(0.3);
    }
    
    renderHeader() {
        // Title
        this.add.text(20, 15, "THE HIDEOUT", { fontSize: '32px', fill: '#00ff00', fontStyle: 'bold' });
        
        // Resources display (top right, horizontal layout)
        this.resourceText = this.add.text(780, 15, "", { fontSize: '14px', fill: '#ccc', align: 'right' }).setOrigin(1, 0);
        this.updateResourceText();
        
        // Separator line
        this.add.rectangle(400, 55, 760, 2, 0x444444);
    }
    
    updateResourceText() {
        if (this.resourceText) {
            this.resourceText.setText(
                `HP: ${this.stats.hp}/${this.stats.maxHp}  |  AMMO: ${this.stats.ammo}  |  ` +
                `SCRAP: ${this.stats.scrap}  |  CREDITS: ${this.stats.credits}  |  MAT: ${this.stats.materials}`
            );
        }
    }
    
    renderTabs() {
        const tabY = 75;
        const tabWidth = 120;
        const tabHeight = 35;
        const tabs = [
            { id: 'facilities', label: 'FACILITIES', x: 80 },
            { id: 'character', label: 'CHARACTER', x: 210 },
            { id: 'shop', label: 'SHOP', x: 340 }
        ];
        
        this.tabButtons = {};
        this.tabTexts = {};
        
        tabs.forEach(tab => {
            const isActive = this.currentTab === tab.id;
            const btn = this.add.rectangle(tab.x, tabY, tabWidth, tabHeight, isActive ? 0x555555 : 0x333333)
                .setStrokeStyle(1, 0x666666)
                .setInteractive();
            const txt = this.add.text(tab.x, tabY, tab.label, { 
                fontSize: '14px', 
                fill: isActive ? '#fff' : '#888',
                fontStyle: 'bold'
            }).setOrigin(0.5);
            
            btn.on('pointerdown', () => {
                sfx.click();
                this.showTab(tab.id);
            });
            btn.on('pointerover', () => {
                if (this.currentTab !== tab.id) btn.setFillStyle(0x444444);
            });
            btn.on('pointerout', () => {
                if (this.currentTab !== tab.id) btn.setFillStyle(0x333333);
            });
            
            this.tabButtons[tab.id] = btn;
            this.tabTexts[tab.id] = txt;
        });
    }
    
    updateTabStyles() {
        const tabs = ['facilities', 'character', 'shop'];
        tabs.forEach(tabId => {
            const isActive = this.currentTab === tabId;
            if (this.tabButtons[tabId]) {
                this.tabButtons[tabId].setFillStyle(isActive ? 0x555555 : 0x333333);
            }
            if (this.tabTexts[tabId]) {
                this.tabTexts[tabId].setFill(isActive ? '#fff' : '#888');
            }
        });
    }
    
    renderFooter() {
        const footerY = 565;
        
        // Separator line above footer
        this.add.rectangle(400, 520, 760, 2, 0x444444);
        
        // Main Menu button (left)
        const menuBtn = this.add.rectangle(80, footerY, 130, 40, 0x444444).setInteractive();
        this.add.text(80, footerY, "MAIN MENU", { fontSize: '13px', fill: '#fff' }).setOrigin(0.5);
        menuBtn.on('pointerdown', () => { sfx.menuClose(); this.scene.start('MainMenuScene'); });
        menuBtn.on('pointerover', () => menuBtn.setFillStyle(0x555555));
        menuBtn.on('pointerout', () => menuBtn.setFillStyle(0x444444));
        
        // Settings cog icon
        const settingsBtn = this.add.rectangle(170, footerY, 40, 40, 0x444444).setInteractive();
        this.add.text(170, footerY, "‚öôÔ∏è", { fontSize: '20px' }).setOrigin(0.5);
        settingsBtn.on('pointerdown', () => { sfx.menuOpen(); this.showSettingsMenu(); });
        settingsBtn.on('pointerover', () => settingsBtn.setFillStyle(0x555555));
        settingsBtn.on('pointerout', () => settingsBtn.setFillStyle(0x444444));
        
        // Mission Map button (right, prominent)
        const missionBtn = this.add.rectangle(580, footerY, 320, 50, 0x00aa44).setInteractive();
        this.add.text(580, footerY, "MISSION MAP", { fontSize: '26px', fill: '#fff', fontStyle: 'bold' }).setOrigin(0.5);
        missionBtn.on('pointerdown', () => { sfx.menuOpen(); this.showMissionMap(); });
        missionBtn.on('pointerover', () => missionBtn.setFillStyle(0x00cc55));
        missionBtn.on('pointerout', () => missionBtn.setFillStyle(0x00aa44));
    }
    
    showTab(tabId) {
        // Clear existing tab content
        this.tabContent.forEach(el => el.destroy());
        this.tabContent = [];
        
        this.currentTab = tabId;
        this.updateTabStyles();
        
        switch(tabId) {
            case 'facilities':
                this.renderFacilitiesTab();
                break;
            case 'character':
                this.renderCharacterTab();
                break;
            case 'shop':
                this.renderShopTab();
                break;
        }
    }
    
    renderFacilitiesTab() {
        const startY = 115;
        const cardWidth = 230;
        const cardHeight = 140;
        const cardSpacing = 15;
        const startX = 25;
        
        // Row 1: REST AREA, GENERATOR, ARMORY
        this.createFacilityCard(startX, startY, cardWidth, cardHeight, "REST AREA", '#ffff00',
            () => `LVL: ${this.stats.hideout.restAreaLvl}\n${this.getRestEffect()}`,
            () => {
                const cost = (this.stats.hideout.restAreaLvl + 1) * 5;
                if (this.stats.scrap >= cost) {
                    this.stats.scrap -= cost;
                    this.stats.hideout.restAreaLvl++;
                    if (this.stats.hideout.restAreaLvl > 0) this.stats.hp = this.stats.maxHp;
                    if (this.stats.hideout.restAreaLvl > 1) this.stats.maxHp += 2;
                    this.updateResourceText();
                    localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));
                    return true;
                }
                return false;
            },
            () => `UPGRADE (${(this.stats.hideout.restAreaLvl + 1) * 5} SCRAP)`
        );
        
        this.createFacilityCard(startX + cardWidth + cardSpacing, startY, cardWidth, cardHeight, "GENERATOR", '#00ff00',
            () => {
                if (this.stats.hideout.generatorLvl === 0) return "Offline\nNeed: Plug + 10 Scrap";
                return "Online\nAuto-Flashlight";
            },
            () => {
                if (this.stats.hideout.generatorLvl === 0) {
                    if (this.stats.scrap >= 10 && this.stats.hideout.hasSparkPlug) {
                        this.stats.scrap -= 10;
                        this.stats.hideout.generatorLvl = 1;
                        this.stats.hideout.hasSparkPlug = false;
                        this.stats.hasFlashlight = true;
                        this.updateResourceText();
                        localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));
                        return true;
                    }
                }
                return false;
            },
            () => this.stats.hideout.generatorLvl === 0 ? "BUILD" : "MAX LEVEL"
        );
        
        this.createArmoryFacilityCard(startX + (cardWidth + cardSpacing) * 2, startY, cardWidth, cardHeight);
        
        // Row 2: WORKBENCH, REPAIR STATION
        const row2Y = startY + cardHeight + cardSpacing;
        this.createWorkbenchFacilityCard(startX, row2Y, cardWidth, cardHeight);
        this.createRepairFacilityCard(startX + cardWidth + cardSpacing, row2Y, cardWidth, cardHeight);
    }
    
    createFacilityCard(x, y, w, h, title, titleColor, descFn, actionFn, costFn) {
        const card = this.add.rectangle(x + w/2, y + h/2, w, h, 0x2a2a2a).setStrokeStyle(2, 0x444444);
        this.tabContent.push(card);
        
        const titleText = this.add.text(x + 10, y + 10, title, { fontSize: '16px', fill: titleColor, fontStyle: 'bold' });
        this.tabContent.push(titleText);
        
        const descText = this.add.text(x + 10, y + 35, descFn(), { fontSize: '13px', fill: '#aaa', lineSpacing: 4 });
        this.tabContent.push(descText);
        
        const btn = this.add.rectangle(x + w/2, y + h - 25, w - 20, 30, 0x444444).setInteractive();
        this.tabContent.push(btn);
        
        const btnText = this.add.text(x + w/2, y + h - 25, costFn(), { fontSize: '12px', fill: '#fff' }).setOrigin(0.5);
        this.tabContent.push(btnText);
        
        btn.on('pointerdown', () => {
            if (actionFn()) {
                sfx.success();
                descText.setText(descFn());
                btnText.setText(costFn());
                this.cameras.main.flash(100, 0, 255, 0);
            } else {
                sfx.error();
                this.cameras.main.shake(100, 0.005);
                btn.setFillStyle(0x660000);
                this.time.delayedCall(200, () => btn.setFillStyle(0x444444));
            }
        });
        btn.on('pointerover', () => btn.setFillStyle(0x555555));
        btn.on('pointerout', () => btn.setFillStyle(0x444444));
    }
    
    createArmoryFacilityCard(x, y, w, h) {
        const card = this.add.rectangle(x + w/2, y + h/2, w, h, 0x2a2a2a).setStrokeStyle(2, 0x444444);
        this.tabContent.push(card);
        
        const titleText = this.add.text(x + 10, y + 10, "ARMORY", { fontSize: '16px', fill: '#ff00ff', fontStyle: 'bold' });
        this.tabContent.push(titleText);
        
        let armory = this.stats.hideout.armory;
        let descStr, btnStr;
        if (armory.hasNVG) {
            descStr = "NVG Equipped\nPress [N] in game";
            btnStr = "EQUIPPED";
        } else if (armory.crafting) {
            descStr = "Fabricating NVG...";
            btnStr = "CRAFTING...";
        } else {
            descStr = "Craft NVG\nCost: 3 Scrap";
            btnStr = "CRAFT NVG";
        }
        
        const descText = this.add.text(x + 10, y + 35, descStr, { fontSize: '13px', fill: '#aaa', lineSpacing: 4 });
        this.tabContent.push(descText);
        
        this.armoryTimerText = this.add.text(x + 10, y + 70, "", { fontSize: '12px', fill: '#00ff00' });
        this.tabContent.push(this.armoryTimerText);
        
        const btn = this.add.rectangle(x + w/2, y + h - 45, w - 20, 28, armory.hasNVG ? 0x222222 : 0x444444);
        if (!armory.hasNVG) btn.setInteractive();
        this.tabContent.push(btn);
        
        this.armoryBtnText = this.add.text(x + w/2, y + h - 45, btnStr, { fontSize: '12px', fill: '#fff' }).setOrigin(0.5);
        this.tabContent.push(this.armoryBtnText);
        
        // Ammo press button
        const ammoBtn = this.add.rectangle(x + w/2, y + h - 15, w - 20, 22, 0x335533).setInteractive();
        this.tabContent.push(ammoBtn);
        const ammoBtnText = this.add.text(x + w/2, y + h - 15, "AMMO PRESS (1 SCRAP = 4 AMMO)", { fontSize: '10px', fill: '#fff' }).setOrigin(0.5);
        this.tabContent.push(ammoBtnText);
        
        btn.on('pointerdown', () => {
            if (armory.hasNVG) return;
            if (armory.crafting && Date.now() >= armory.crafting.finishTime) {
                sfx.lootWeapon();
                armory.hasNVG = true;
                armory.crafting = null;
                descText.setText("NVG Equipped\nPress [N] in game");
                this.armoryBtnText.setText("EQUIPPED");
                btn.disableInteractive();
                btn.setFillStyle(0x222222);
                localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));
                return;
            }
            if (armory.crafting) return;
            if (this.stats.scrap >= 3) {
                sfx.success();
                this.stats.scrap -= 3;
                armory.crafting = { item: 'nvg', finishTime: Date.now() + CONFIG.TIMINGS.NVG_CRAFT };
                this.updateResourceText();
                descText.setText("Fabricating NVG...");
                this.armoryBtnText.setText("CRAFTING...");
                btn.disableInteractive();
                localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));
            } else {
                sfx.error();
                this.cameras.main.shake(100, 0.005);
            }
        });
        
        ammoBtn.on('pointerdown', () => {
            if (this.stats.scrap >= 1) {
                sfx.lootAmmo();
                this.stats.scrap -= 1;
                this.stats.ammo += 4;
                this.updateResourceText();
                localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));
                this.cameras.main.flash(100, 0, 255, 0);
            } else {
                sfx.error();
            }
        });
        ammoBtn.on('pointerover', () => ammoBtn.setFillStyle(0x447744));
        ammoBtn.on('pointerout', () => ammoBtn.setFillStyle(0x335533));
    }
    
    createWorkbenchFacilityCard(x, y, w, h) {
        const card = this.add.rectangle(x + w/2, y + h/2, w, h, 0x2a2a2a).setStrokeStyle(2, 0x444444);
        this.tabContent.push(card);
        
        const titleText = this.add.text(x + 10, y + 10, "WORKBENCH", { fontSize: '16px', fill: '#ff8800', fontStyle: 'bold' });
        this.tabContent.push(titleText);
        
        let descStr, btnStr;
        if (this.stats.hideout.workbenchLvl === 0) {
            descStr = `Upgrade weapons\n+${CONFIG.HIDEOUT.WORKBENCH_DAMAGE_BONUS * 100}% damage`;
            btnStr = `BUILD (${CONFIG.HIDEOUT.WORKBENCH_COST} SCRAP)`;
        } else {
            descStr = `ACTIVE\n+${CONFIG.HIDEOUT.WORKBENCH_DAMAGE_BONUS * 100}% weapon damage`;
            btnStr = "UPGRADED";
        }
        
        const descText = this.add.text(x + 10, y + 35, descStr, { fontSize: '13px', fill: '#aaa', lineSpacing: 4 });
        this.tabContent.push(descText);
        
        const btn = this.add.rectangle(x + w/2, y + h - 25, w - 20, 30, 0x444444).setInteractive();
        this.tabContent.push(btn);
        
        const btnText = this.add.text(x + w/2, y + h - 25, btnStr, { fontSize: '12px', fill: '#fff' }).setOrigin(0.5);
        this.tabContent.push(btnText);
        
        btn.on('pointerdown', () => {
            if (this.stats.hideout.workbenchLvl === 0 && this.stats.scrap >= CONFIG.HIDEOUT.WORKBENCH_COST) {
                sfx.success();
                this.stats.scrap -= CONFIG.HIDEOUT.WORKBENCH_COST;
                this.stats.hideout.workbenchLvl = 1;
                this.updateResourceText();
                descText.setText(`ACTIVE\n+${CONFIG.HIDEOUT.WORKBENCH_DAMAGE_BONUS * 100}% weapon damage`);
                btnText.setText("UPGRADED");
                localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));
                this.cameras.main.flash(100, 255, 136, 0);
            } else {
                sfx.error();
                this.cameras.main.shake(100, 0.005);
            }
        });
        btn.on('pointerover', () => btn.setFillStyle(0x555555));
        btn.on('pointerout', () => btn.setFillStyle(0x444444));
    }
    
    createRepairFacilityCard(x, y, w, h) {
        const card = this.add.rectangle(x + w/2, y + h/2, w, h, 0x2a2a2a).setStrokeStyle(2, 0x444444);
        this.tabContent.push(card);
        
        const titleText = this.add.text(x + 10, y + 10, "REPAIR STATION", { fontSize: '16px', fill: '#00aaff', fontStyle: 'bold' });
        this.tabContent.push(titleText);
        
        const getDescAndBtn = () => {
            if (this.stats.hideout.repairStationLvl === 0) {
                return { desc: "Repair damaged armor", btn: `BUILD (${CONFIG.HIDEOUT.REPAIR_STATION_COST} SCRAP)` };
            }
            // Check if any armor needs repair
            const slots = ['head', 'body', 'arms', 'feet'];
            let needsRepair = false;
            for (const slot of slots) {
                const armor = this.stats.armor[slot];
                if (armor && armor.durability < armor.maxDurability) {
                    needsRepair = true;
                    break;
                }
            }
            return { 
                desc: needsRepair ? "Some armor damaged" : "All armor at full durability", 
                btn: needsRepair ? "REPAIR ARMOR" : "NO REPAIRS NEEDED" 
            };
        };
        
        const { desc, btn: btnStr } = getDescAndBtn();
        
        const descText = this.add.text(x + 10, y + 35, desc, { fontSize: '13px', fill: '#aaa', lineSpacing: 4 });
        this.tabContent.push(descText);
        
        const btn = this.add.rectangle(x + w/2, y + h - 25, w - 20, 30, 0x444444).setInteractive();
        this.tabContent.push(btn);
        
        const btnText = this.add.text(x + w/2, y + h - 25, btnStr, { fontSize: '12px', fill: '#fff' }).setOrigin(0.5);
        this.tabContent.push(btnText);
        
        btn.on('pointerdown', () => {
            if (this.stats.hideout.repairStationLvl === 0 && this.stats.scrap >= CONFIG.HIDEOUT.REPAIR_STATION_COST) {
                sfx.success();
                this.stats.scrap -= CONFIG.HIDEOUT.REPAIR_STATION_COST;
                this.stats.hideout.repairStationLvl = 1;
                this.updateResourceText();
                const { desc: newDesc, btn: newBtn } = getDescAndBtn();
                descText.setText(newDesc);
                btnText.setText(newBtn);
                localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));
                this.cameras.main.flash(100, 0, 170, 255);
            } else if (this.stats.hideout.repairStationLvl > 0) {
                this.repairArmor();
                const { desc: newDesc, btn: newBtn } = getDescAndBtn();
                descText.setText(newDesc);
                btnText.setText(newBtn);
            } else {
                sfx.error();
                this.cameras.main.shake(100, 0.005);
            }
        });
        btn.on('pointerover', () => btn.setFillStyle(0x555555));
        btn.on('pointerout', () => btn.setFillStyle(0x444444));
    }
    
    renderCharacterTab() {
        const startY = 115;
        const btnWidth = 230;
        const btnHeight = 60;
        const spacing = 15;
        const startX = 25;
        
        // Row 1: CLASS, SKILLS, UPGRADES
        this.createCharacterButton(startX, startY, btnWidth, btnHeight, "CLASS", '#00aaaa',
            () => {
                const classConfig = CONFIG.CLASSES[this.persistent.selectedClass.toUpperCase()] || CONFIG.CLASSES.SURVIVOR;
                return classConfig.name;
            },
            () => { sfx.menuOpen(); this.showClassModal(); }
        );
        
        const skillPts = this.persistent.skillPoints || 0;
        this.createCharacterButton(startX + btnWidth + spacing, startY, btnWidth, btnHeight, 
            `SKILLS${skillPts > 0 ? ' (' + skillPts + ')' : ''}`, '#8844aa',
            () => `${Object.values(this.persistent.skills || {}).filter(v => v > 0).length} unlocked`,
            () => { sfx.menuOpen(); this.showSkillsPanel(); }
        );
        
        this.createCharacterButton(startX + (btnWidth + spacing) * 2, startY, btnWidth, btnHeight, "UPGRADES", '#886600',
            () => `${this.persistent.permanentUpgrades?.length || 0} purchased`,
            () => { sfx.menuOpen(); this.showUpgradesPanel(); }
        );
        
        // Row 2: MODS, STATS, CHALLENGES
        const row2Y = startY + btnHeight + spacing;
        const modsCount = this.persistent.modInventory?.length || 0;
        this.createCharacterButton(startX, row2Y, btnWidth, btnHeight, 
            `MODS${modsCount > 0 ? ' (' + modsCount + ')' : ''}`, '#885588',
            () => `${modsCount} in inventory`,
            () => { sfx.menuOpen(); this.showModsPanel(); }
        );
        
        this.createCharacterButton(startX + btnWidth + spacing, row2Y, btnWidth, btnHeight, "STATS", '#444488',
            () => `Runs: ${this.persistent.totalRuns || 0}`,
            () => { sfx.menuOpen(); this.showStatsPanel(); }
        );
        
        const unclaimed = this.countUnclaimedChallenges();
        this.createCharacterButton(startX + (btnWidth + spacing) * 2, row2Y, btnWidth, btnHeight, 
            `CHALLENGES${unclaimed > 0 ? ' (' + unclaimed + ')' : ''}`, '#448844',
            () => unclaimed > 0 ? `${unclaimed} rewards ready!` : 'Daily & Weekly tasks',
            () => { sfx.menuOpen(); this.showChallengesPanel(); }
        );
    }
    
    createCharacterButton(x, y, w, h, title, color, subtitleFn, onClick) {
        const btn = this.add.rectangle(x + w/2, y + h/2, w, h, 0x2a2a2a)
            .setStrokeStyle(2, Phaser.Display.Color.HexStringToColor(color).color)
            .setInteractive();
        this.tabContent.push(btn);
        
        const titleText = this.add.text(x + w/2, y + h/2 - 10, title, { 
            fontSize: '16px', fill: color, fontStyle: 'bold' 
        }).setOrigin(0.5);
        this.tabContent.push(titleText);
        
        const subtitle = this.add.text(x + w/2, y + h/2 + 12, subtitleFn(), { 
            fontSize: '12px', fill: '#888' 
        }).setOrigin(0.5);
        this.tabContent.push(subtitle);
        
        btn.on('pointerdown', onClick);
        btn.on('pointerover', () => btn.setFillStyle(0x3a3a3a));
        btn.on('pointerout', () => btn.setFillStyle(0x2a2a2a));
    }
    
    renderShopTab() {
        const centerX = 400;
        const centerY = 280;
        
        // Large trader button
        const traderBtn = this.add.rectangle(centerX, centerY, 400, 120, 0x3a3a0a)
            .setStrokeStyle(3, 0xffd700)
            .setInteractive();
        this.tabContent.push(traderBtn);
        
        const traderIcon = this.add.text(centerX, centerY - 20, "TRADER", { 
            fontSize: '32px', fill: '#ffd700', fontStyle: 'bold' 
        }).setOrigin(0.5);
        this.tabContent.push(traderIcon);
        
        const traderDesc = this.add.text(centerX, centerY + 20, "Buy weapons, armor, and consumables\nSell items for credits", { 
            fontSize: '14px', fill: '#ccc', align: 'center' 
        }).setOrigin(0.5);
        this.tabContent.push(traderDesc);
        
        traderBtn.on('pointerdown', () => { sfx.menuOpen(); this.showTraderModal(); });
        traderBtn.on('pointerover', () => traderBtn.setFillStyle(0x4a4a1a));
        traderBtn.on('pointerout', () => traderBtn.setFillStyle(0x3a3a0a));
        
        // Future shop features hint
        const futureText = this.add.text(centerX, centerY + 100, "More shop features coming soon...", { 
            fontSize: '12px', fill: '#555' 
        }).setOrigin(0.5);
        this.tabContent.push(futureText);
    }
    
    countUnclaimedChallenges() {
        let count = 0;
        // Count completed but unclaimed dailies
        this.persistent.activeDailies?.forEach(challenge => {
            const config = CONFIG.CHALLENGES.DAILY.find(c => c.id === challenge.id);
            if (config && challenge.progress >= config.target && !challenge.claimed) {
                count++;
            }
        });
        // Count completed but unclaimed weeklies
        this.persistent.activeWeeklies?.forEach(challenge => {
            const config = CONFIG.CHALLENGES.WEEKLY.find(c => c.id === challenge.id);
            if (config && challenge.progress >= config.target && !challenge.claimed) {
                count++;
            }
        });
        return count;
    }
    
    showSettingsMenu() {
        const settings = loadSettings();
        const elements = [];
        
        // Overlay background (taller to fit controls)
        const overlay = this.add.rectangle(400, 300, 550, 520, 0x111111, 0.98).setDepth(500);
        elements.push(overlay);
        
        const title = this.add.text(400, 65, "SETTINGS", { fontSize: '28px', fill: '#fff' }).setOrigin(0.5).setDepth(501);
        elements.push(title);
        
        // Controls section
        const controlsLabel = this.add.text(400, 100, "CONTROLS", { fontSize: '12px', fill: '#888' }).setOrigin(0.5).setDepth(501);
        elements.push(controlsLabel);
        
        const controlsBg = this.add.rectangle(400, 155, 500, 80, 0x1a1a1a).setDepth(501);
        elements.push(controlsBg);
        
        const controlsText = this.add.text(400, 155, 
            "WASD: Move  |  Mouse: Aim/Fire  |  SPACE: Dodge  |  R: Reload\n" +
            "G: Grenade  |  TAB: Inventory  |  N: NVG  |  F: Interact\n" +
            "Q: Switch Weapon  |  E: Melee  |  1/2/3: Consumables", 
            { fontSize: '11px', fill: '#aaa', align: 'center', lineSpacing: 6 }
        ).setOrigin(0.5).setDepth(502);
        elements.push(controlsText);
        
        // Master Volume Slider
        const masterLabel = this.add.text(170, 205, "MASTER VOLUME", { fontSize: '13px', fill: '#aaa' }).setDepth(501);
        elements.push(masterLabel);
        
        const masterSliderBg = this.add.rectangle(400, 230, 280, 16, 0x333333).setDepth(501);
        elements.push(masterSliderBg);
        
        const masterSliderFill = this.add.rectangle(260, 230, settings.masterVolume * 280, 12, 0x00ff00).setOrigin(0, 0.5).setDepth(502);
        elements.push(masterSliderFill);
        
        const masterPercent = this.add.text(550, 230, `${Math.round(settings.masterVolume * 100)}%`, { fontSize: '11px', fill: '#fff' }).setOrigin(0, 0.5).setDepth(501);
        elements.push(masterPercent);
        
        masterSliderBg.setInteractive();
        masterSliderBg.on('pointerdown', (pointer) => {
            const relX = (pointer.x - 260) / 280;
            const newVol = Phaser.Math.Clamp(relX, 0, 1);
            settings.masterVolume = newVol;
            sfx.setMasterVolume(newVol);
            masterSliderFill.width = newVol * 280;
            masterPercent.setText(`${Math.round(newVol * 100)}%`);
            sfx.click();
        });
        
        // SFX Volume Slider
        const sfxLabel = this.add.text(170, 255, "SFX VOLUME", { fontSize: '13px', fill: '#aaa' }).setDepth(501);
        elements.push(sfxLabel);
        
        const sfxSliderBg = this.add.rectangle(400, 280, 280, 16, 0x333333).setDepth(501);
        elements.push(sfxSliderBg);
        
        const sfxSliderFill = this.add.rectangle(260, 280, settings.sfxVolume * 280, 12, 0x00aaff).setOrigin(0, 0.5).setDepth(502);
        elements.push(sfxSliderFill);
        
        const sfxPercent = this.add.text(550, 280, `${Math.round(settings.sfxVolume * 100)}%`, { fontSize: '11px', fill: '#fff' }).setOrigin(0, 0.5).setDepth(501);
        elements.push(sfxPercent);
        
        sfxSliderBg.setInteractive();
        sfxSliderBg.on('pointerdown', (pointer) => {
            const relX = (pointer.x - 260) / 280;
            const newVol = Phaser.Math.Clamp(relX, 0, 1);
            settings.sfxVolume = newVol;
            sfx.setSfxVolume(newVol);
            sfxSliderFill.width = newVol * 280;
            sfxPercent.setText(`${Math.round(newVol * 100)}%`);
            sfx.click();
        });
        
        // Screen Shake Toggle
        const shakeLabel = this.add.text(170, 315, "SCREEN SHAKE", { fontSize: '13px', fill: '#aaa' }).setDepth(501);
        elements.push(shakeLabel);
        
        const shakeToggle = this.add.rectangle(510, 315, 65, 24, settings.screenShake ? 0x00ff00 : 0x444444).setDepth(501).setInteractive();
        elements.push(shakeToggle);
        
        const shakeText = this.add.text(510, 315, settings.screenShake ? "ON" : "OFF", { fontSize: '11px', fill: '#fff' }).setOrigin(0.5).setDepth(502);
        elements.push(shakeText);
        
        shakeToggle.on('pointerdown', () => {
            settings.screenShake = !settings.screenShake;
            shakeToggle.setFillStyle(settings.screenShake ? 0x00ff00 : 0x444444);
            shakeText.setText(settings.screenShake ? "ON" : "OFF");
            saveSettings(settings);
            sfx.click();
        });
        
        // Hit Indicators Toggle
        const hitLabel = this.add.text(170, 350, "HIT INDICATORS", { fontSize: '13px', fill: '#aaa' }).setDepth(501);
        elements.push(hitLabel);
        
        const hitToggle = this.add.rectangle(510, 350, 65, 24, settings.hitIndicators ? 0x00ff00 : 0x444444).setDepth(501).setInteractive();
        elements.push(hitToggle);
        
        const hitText = this.add.text(510, 350, settings.hitIndicators ? "ON" : "OFF", { fontSize: '11px', fill: '#fff' }).setOrigin(0.5).setDepth(502);
        elements.push(hitText);
        
        hitToggle.on('pointerdown', () => {
            settings.hitIndicators = !settings.hitIndicators;
            hitToggle.setFillStyle(settings.hitIndicators ? 0x00ff00 : 0x444444);
            hitText.setText(settings.hitIndicators ? "ON" : "OFF");
            saveSettings(settings);
            sfx.click();
        });
        
        // Separator
        const sep = this.add.rectangle(400, 390, 450, 1, 0x444444).setDepth(501);
        elements.push(sep);
        
        // Export/Import save
        const exportBtn = this.add.rectangle(300, 420, 150, 28, 0x335533).setDepth(501).setInteractive();
        const exportText = this.add.text(300, 420, "üì§ EXPORT SAVE", { fontSize: '11px', fill: '#fff' }).setOrigin(0.5).setDepth(502);
        elements.push(exportBtn, exportText);
        
        exportBtn.on('pointerdown', () => {
            let saved = localStorage.getItem(CONFIG.SAVE_KEY);
            if (!saved) { sfx.error(); return; }
            const blob = new Blob([saved], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `zombie_save_${new Date().toISOString().slice(0,10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            sfx.success();
        });
        exportBtn.on('pointerover', () => exportBtn.setFillStyle(0x447744));
        exportBtn.on('pointerout', () => exportBtn.setFillStyle(0x335533));
        
        const importBtn = this.add.rectangle(500, 420, 150, 28, 0x335533).setDepth(501).setInteractive();
        const importText = this.add.text(500, 420, "üì• IMPORT SAVE", { fontSize: '11px', fill: '#fff' }).setOrigin(0.5).setDepth(502);
        elements.push(importBtn, importText);
        
        importBtn.on('pointerdown', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const json = JSON.parse(event.target.result);
                        if (json.hp !== undefined && json.hideout !== undefined) {
                            localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(json));
                            sfx.success();
                            elements.forEach(e => e.destroy());
                            this.scene.restart();
                        } else {
                            sfx.error();
                        }
                    } catch (err) {
                        sfx.error();
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        });
        importBtn.on('pointerover', () => importBtn.setFillStyle(0x447744));
        importBtn.on('pointerout', () => importBtn.setFillStyle(0x335533));
        
        // Cheat Code button
        const cheatBtn = this.add.text(400, 460, "[ ENTER CHEAT CODE ]", { fontSize: '11px', fill: '#555' }).setOrigin(0.5).setDepth(501).setInteractive();
        elements.push(cheatBtn);
        
        cheatBtn.on('pointerdown', () => {
            const code = prompt("ENTER CHEAT CODE:");
            if (code === 'god mode') {
                elements.forEach(e => e.destroy());
                this.activateGodMode();
            }
        });
        cheatBtn.on('pointerover', () => cheatBtn.setFill('#888'));
        cheatBtn.on('pointerout', () => cheatBtn.setFill('#555'));
        
        // Close button
        const closeBtn = this.add.text(400, 510, "[ CLOSE ]", { fontSize: '14px', fill: '#ff4444' }).setOrigin(0.5).setDepth(501).setInteractive();
        elements.push(closeBtn);
        
        closeBtn.on('pointerdown', () => {
            sfx.menuClose();
            elements.forEach(e => e.destroy());
        });
    }
    
    activateGodMode() {
        const godStats = {
            hp: 999, maxHp: 999, stamina: 100, maxStamina: 100, ammo: 999, scrap: 999,
            credits: 999, materials: 999,
            grenades: CONFIG.GRENADE.MAX_CARRY,
            nextLevel: 1, highestLevelUnlocked: 7,
            consumables: ['adrenaline', 'armor_patch', 'stim_pack'],
            hasFlashlight: true, hasShotgun: true, hasSMG: true, hasCrossbow: true, hasRifle: true,
            currentWeapon: 'rifle',
            magazines: {
                pistol: CONFIG.WEAPONS.PISTOL.MAG_SIZE,
                shotgun: CONFIG.WEAPONS.SHOTGUN.MAG_SIZE,
                smg: CONFIG.WEAPONS.SMG.MAG_SIZE,
                crossbow: CONFIG.WEAPONS.CROSSBOW.MAG_SIZE,
                rifle: CONFIG.WEAPONS.RIFLE.MAG_SIZE
            },
            armor: {
                head: { name: 'GOD HELM', durability: 999, maxDurability: 999 },
                body: { name: 'GOD VEST', durability: 999, maxDurability: 999 },
                arms: null, feet: null
            },
            hideout: {
                restAreaLvl: 99, generatorLvl: 1, hasSparkPlug: true,
                armory: { crafting: null, hasNVG: true },
                workbenchLvl: 1, repairStationLvl: 1
            },
            equippedMods: {
                pistol: [null, null], shotgun: [null, null], smg: [null, null],
                crossbow: [null, null], rifle: [null, null]
            }
        };
        localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(godStats));
        sfx.success();
        this.scene.restart({ stats: godStats });
    }
    
    createWorkbenchCard(x, y) {
        this.add.rectangle(x + 100, y + 60, 220, 130, 0x333333).setStrokeStyle(2, 0x555555);
        this.add.text(x + 10, y + 10, "WORKBENCH", { fontSize: '18px', fill: '#ff8800' });
        this.workbenchDesc = this.add.text(x + 10, y + 35, "", { fontSize: '12px', fill: '#aaa' });
        const btn = this.add.rectangle(x + 100, y + 100, 200, 25, 0x555555).setInteractive();
        this.workbenchBtnText = this.add.text(x + 100, y + 100, "", { fontSize: '12px', fill: '#fff' }).setOrigin(0.5);
        
        this.updateWorkbenchUI();
        
        btn.on('pointerdown', () => {
            if (this.stats.hideout.workbenchLvl === 0 && this.stats.scrap >= CONFIG.HIDEOUT.WORKBENCH_COST) {
                sfx.success();
                this.stats.scrap -= CONFIG.HIDEOUT.WORKBENCH_COST;
                this.stats.hideout.workbenchLvl = 1;
                this.updateStatText();
                this.updateWorkbenchUI();
                localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));
                this.cameras.main.flash(100, 255, 136, 0);
            } else {
                sfx.error();
                this.cameras.main.shake(100, 0.005);
            }
        });
    }
    
    updateWorkbenchUI() {
        if (this.stats.hideout.workbenchLvl === 0) {
            this.workbenchDesc.setText(`Upgrade weapons\n+${CONFIG.HIDEOUT.WORKBENCH_DAMAGE_BONUS * 100}% damage`);
            this.workbenchBtnText.setText(`BUILD (${CONFIG.HIDEOUT.WORKBENCH_COST} SCRAP)`);
        } else {
            this.workbenchDesc.setText(`ACTIVE\n+${CONFIG.HIDEOUT.WORKBENCH_DAMAGE_BONUS * 100}% weapon damage`);
            this.workbenchBtnText.setText("UPGRADED");
        }
    }
    
    createRepairStationCard(x, y) {
        this.add.rectangle(x + 100, y + 60, 220, 130, 0x333333).setStrokeStyle(2, 0x555555);
        this.add.text(x + 10, y + 10, "REPAIR STATION", { fontSize: '18px', fill: '#00aaff' });
        this.repairDesc = this.add.text(x + 10, y + 35, "", { fontSize: '12px', fill: '#aaa' });
        const btn = this.add.rectangle(x + 100, y + 100, 200, 25, 0x555555).setInteractive();
        this.repairBtnText = this.add.text(x + 100, y + 100, "", { fontSize: '12px', fill: '#fff' }).setOrigin(0.5);
        
        this.updateRepairUI();
        
        btn.on('pointerdown', () => {
            if (this.stats.hideout.repairStationLvl === 0 && this.stats.scrap >= CONFIG.HIDEOUT.REPAIR_STATION_COST) {
                // Build repair station
                sfx.success();
                this.stats.scrap -= CONFIG.HIDEOUT.REPAIR_STATION_COST;
                this.stats.hideout.repairStationLvl = 1;
                this.updateStatText();
                this.updateRepairUI();
                localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));
                this.cameras.main.flash(100, 0, 170, 255);
            } else if (this.stats.hideout.repairStationLvl > 0) {
                // Repair armor
                this.repairArmor();
            } else {
                sfx.error();
                this.cameras.main.shake(100, 0.005);
            }
        });
    }
    
    repairArmor() {
        let repaired = false;
        const slots = ['head', 'body', 'arms', 'feet'];
        for (const slot of slots) {
            const armor = this.stats.armor[slot];
            if (armor && armor.durability < armor.maxDurability) {
                const needed = armor.maxDurability - armor.durability;
                const cost = needed * CONFIG.HIDEOUT.REPAIR_COST_PER_POINT;
                if (this.stats.scrap >= cost) {
                    this.stats.scrap -= cost;
                    armor.durability = armor.maxDurability;
                    repaired = true;
                }
            }
        }
        if (repaired) {
            sfx.success();
            this.updateStatText();
            this.updateRepairUI();
            localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));
            this.cameras.main.flash(100, 0, 255, 0);
        } else {
            sfx.error();
            this.cameras.main.shake(100, 0.005);
        }
    }
    
    updateRepairUI() {
        if (this.stats.hideout.repairStationLvl === 0) {
            this.repairDesc.setText(`Repair damaged armor\n${CONFIG.HIDEOUT.REPAIR_COST_PER_POINT} scrap per point`);
            this.repairBtnText.setText(`BUILD (${CONFIG.HIDEOUT.REPAIR_STATION_COST} SCRAP)`);
        } else {
            // Calculate total repair cost
            let totalCost = 0;
            const slots = ['head', 'body', 'arms', 'feet'];
            for (const slot of slots) {
                const armor = this.stats.armor[slot];
                if (armor && armor.durability < armor.maxDurability) {
                    totalCost += (armor.maxDurability - armor.durability) * CONFIG.HIDEOUT.REPAIR_COST_PER_POINT;
                }
            }
            if (totalCost > 0) {
                this.repairDesc.setText(`Armor needs repair\nCost: ${totalCost} scrap`);
                this.repairBtnText.setText("REPAIR ALL");
            } else {
                this.repairDesc.setText("All armor at full\ndurability");
                this.repairBtnText.setText("NO REPAIRS NEEDED");
            }
        }
    }
    
    showMissionMap() {
        const elements = [];
        this.selectedLevel = this.stats.nextLevel || 1;
        
        // Level configuration
        const LEVELS = {
            1: { x: 150, y: 140, name: "Street", color: 0x2d5a27 },
            2: { x: 300, y: 100, name: "Apartment", color: 0x666666 },
            3: { x: 450, y: 140, name: "Rooftop", color: 0x334455 },
            4: { x: 180, y: 240, name: "Sewers", color: 0x2a3a2a },
            5: { x: 350, y: 220, name: "Hospital", color: 0xdddddd },
            6: { x: 450, y: 320, name: "Mall", color: 0x8B4513 },
            7: { x: 600, y: 360, name: "Cemetery", color: 0x1a1a1a }
        };
        
        // Road connections
        const ROADS = [[1,2], [2,3], [1,4], [4,5], [3,5], [5,6], [6,7]];
        
        // Dark overlay
        const overlay = this.add.rectangle(400, 300, 800, 600, 0x000000, 0.9).setDepth(500);
        elements.push(overlay);
        
        // Title
        const title = this.add.text(400, 40, "MISSION SELECT", { 
            fontSize: '36px', fill: '#00ff00', fontStyle: 'bold' 
        }).setOrigin(0.5).setDepth(501);
        elements.push(title);
        
        // City grid background
        const mapBg = this.add.rectangle(400, 250, 700, 350, 0x111122).setDepth(501);
        elements.push(mapBg);
        
        // Grid lines
        const graphics = this.add.graphics().setDepth(502);
        graphics.lineStyle(1, 0x222233, 0.5);
        for (let x = 50; x <= 750; x += 40) {
            graphics.moveTo(x, 75);
            graphics.lineTo(x, 425);
        }
        for (let y = 75; y <= 425; y += 35) {
            graphics.moveTo(50, y);
            graphics.lineTo(750, y);
        }
        graphics.strokePath();
        elements.push(graphics);
        
        // Draw roads first (under nodes)
        const roadGraphics = this.add.graphics().setDepth(503);
        roadGraphics.lineStyle(4, 0x444444);
        ROADS.forEach(([from, to]) => {
            const fromLevel = LEVELS[from];
            const toLevel = LEVELS[to];
            roadGraphics.moveTo(fromLevel.x, fromLevel.y);
            roadGraphics.lineTo(toLevel.x, toLevel.y);
        });
        roadGraphics.strokePath();
        elements.push(roadGraphics);
        
        // Store node references for updates
        this.mapNodes = {};
        
        // Draw level nodes
        for (let i = 1; i <= 7; i++) {
            const level = LEVELS[i];
            const isUnlocked = i <= this.stats.highestLevelUnlocked;
            const isCleared = i < this.stats.highestLevelUnlocked;
            const isSelected = i === this.selectedLevel;
            const isNext = i === this.stats.nextLevel;
            
            // Node background
            let nodeColor = 0x333333; // Locked
            if (isCleared) nodeColor = 0x006600; // Cleared
            if (isNext && !isCleared) nodeColor = 0xaa6600; // Current target
            if (isSelected) nodeColor = 0x0066aa; // Selected
            
            const node = this.add.circle(level.x, level.y, 28, nodeColor).setDepth(504);
            if (isUnlocked) {
                node.setInteractive({ useHandCursor: true });
                node.on('pointerover', () => {
                    if (this.selectedLevel !== i) node.setFillStyle(0x0088cc);
                });
                node.on('pointerout', () => {
                    this.updateMapNodeColor(i);
                });
                node.on('pointerdown', () => {
                    sfx.click();
                    this.selectedLevel = i;
                    this.updateMapSelection();
                });
            }
            
            // Level number
            const numText = this.add.text(level.x, level.y, `${i}`, { 
                fontSize: '20px', fill: isUnlocked ? '#ffffff' : '#555555', fontStyle: 'bold' 
            }).setOrigin(0.5).setDepth(505);
            
            // Status icon
            let icon = '';
            if (!isUnlocked) icon = 'üîí';
            else if (isCleared) icon = '‚úì';
            else if (isNext) icon = '‚Üí';
            
            const iconText = this.add.text(level.x + 20, level.y - 20, icon, { 
                fontSize: '14px' 
            }).setOrigin(0.5).setDepth(506);
            
            // Level name
            const nameText = this.add.text(level.x, level.y + 40, level.name, { 
                fontSize: '12px', fill: isUnlocked ? '#cccccc' : '#555555' 
            }).setOrigin(0.5).setDepth(505);
            
            this.mapNodes[i] = { node, numText, iconText, nameText };
            elements.push(node, numText, iconText, nameText);
        }
        
        // Selected level info panel
        const infoPanel = this.add.rectangle(400, 480, 400, 80, 0x222233).setDepth(501);
        elements.push(infoPanel);
        
        this.mapInfoText = this.add.text(400, 465, '', { 
            fontSize: '18px', fill: '#ffffff', align: 'center' 
        }).setOrigin(0.5).setDepth(502);
        elements.push(this.mapInfoText);
        
        this.mapStatusText = this.add.text(400, 490, '', { 
            fontSize: '14px', fill: '#888888', align: 'center' 
        }).setOrigin(0.5).setDepth(502);
        elements.push(this.mapStatusText);
        
        // Deploy button
        const deployBtn = this.add.rectangle(550, 540, 150, 45, 0x008800).setInteractive().setDepth(501);
        const deployTxt = this.add.text(550, 540, "DEPLOY", { 
            fontSize: '20px', fill: '#ffffff', fontStyle: 'bold' 
        }).setOrigin(0.5).setDepth(502);
        elements.push(deployBtn, deployTxt);
        
        deployBtn.on('pointerover', () => deployBtn.setFillStyle(0x00aa00));
        deployBtn.on('pointerout', () => deployBtn.setFillStyle(0x008800));
        deployBtn.on('pointerdown', () => {
            sfx.success();
            // Apply hideout bonuses before deploying
            if (this.stats.hideout.restAreaLvl > 0) {
                const heal = this.stats.hideout.restAreaLvl >= 2 ? this.stats.maxHp : Math.floor(this.stats.maxHp / 2);
                this.stats.hp = Math.min(this.stats.hp + heal, this.stats.maxHp);
            }
            if (this.stats.hideout.generatorLvl > 0) this.stats.hasFlashlight = true;
            // Refill magazines
            this.stats.magazines.pistol = CONFIG.WEAPONS.PISTOL.MAG_SIZE;
            this.stats.magazines.shotgun = CONFIG.WEAPONS.SHOTGUN.MAG_SIZE;
            this.stats.magazines.smg = CONFIG.WEAPONS.SMG.MAG_SIZE;
            this.stats.magazines.crossbow = CONFIG.WEAPONS.CROSSBOW.MAG_SIZE;
            this.stats.magazines.rifle = CONFIG.WEAPONS.RIFLE.MAG_SIZE;
            // Update nextLevel to selected level
            this.stats.nextLevel = this.selectedLevel;
            localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));
            
            this.cameras.main.fade(500, 0, 0, 0);
            this.time.delayedCall(500, () => { 
                this.scene.start('GameScene', { level: this.selectedLevel, stats: this.stats }); 
            });
        });
        
        // Close button
        const closeBtn = this.add.rectangle(250, 540, 150, 45, 0x444444).setInteractive().setDepth(501);
        const closeTxt = this.add.text(250, 540, "BACK", { 
            fontSize: '20px', fill: '#ffffff' 
        }).setOrigin(0.5).setDepth(502);
        elements.push(closeBtn, closeTxt);
        
        closeBtn.on('pointerover', () => closeBtn.setFillStyle(0x555555));
        closeBtn.on('pointerout', () => closeBtn.setFillStyle(0x444444));
        closeBtn.on('pointerdown', () => {
            sfx.menuClose();
            elements.forEach(e => e.destroy());
        });
        
        // Store elements for cleanup
        this.mapElements = elements;
        
        // Initial selection update
        this.updateMapSelection();
    }
    
    updateMapNodeColor(levelNum) {
        if (!this.mapNodes || !this.mapNodes[levelNum] || !this.mapNodes[levelNum].node) return;
        if (!this.mapNodes[levelNum].node.active) return;
        
        const isUnlocked = levelNum <= this.stats.highestLevelUnlocked;
        const isCleared = levelNum < this.stats.highestLevelUnlocked;
        const isSelected = levelNum === this.selectedLevel;
        const isNext = levelNum === this.stats.nextLevel;
        
        let nodeColor = 0x333333; // Locked
        if (isCleared) nodeColor = 0x006600; // Cleared
        if (isNext && !isCleared) nodeColor = 0xaa6600; // Current target
        if (isSelected) nodeColor = 0x0066aa; // Selected
        
        this.mapNodes[levelNum].node.setFillStyle(nodeColor);
    }
    
    updateMapSelection() {
        // Guard against destroyed UI
        if (!this.mapInfoText || !this.mapStatusText) return;
        
        const LEVEL_NAMES = ['', 'Street', 'Apartment', 'Rooftop', 'Sewers', 'Hospital', 'Mall', 'Cemetery'];
        const LEVEL_DESC = [
            '',
            'Urban streets with scattered zombies',
            'Multi-floor building, find the key',
            'Night sky, collect molotov, burn debris',
            'Dark tunnels, need flashlight',
            'BOSS FIGHT - Heavy zombie',
            'Shopping center with breach waves',
            'FINAL BOSS - Necromancer awaits'
        ];
        
        // Update all node colors
        for (let i = 1; i <= 7; i++) {
            this.updateMapNodeColor(i);
        }
        
        // Update info panel
        const levelName = LEVEL_NAMES[this.selectedLevel] || '';
        const levelDesc = LEVEL_DESC[this.selectedLevel] || '';
        const isCleared = this.selectedLevel < this.stats.highestLevelUnlocked;
        
        if (this.mapInfoText.active) {
            this.mapInfoText.setText(`${this.selectedLevel}. ${levelName}`);
        }
        if (this.mapStatusText.active) {
            this.mapStatusText.setText(isCleared ? `CLEARED - ${levelDesc}` : levelDesc);
        }
    }
    
    showStatsPanel() {
        // Create overlay
        const overlay = this.add.rectangle(400, 300, 700, 500, 0x111111, 0.95).setDepth(500);
        const title = this.add.text(400, 80, "STATS & ACHIEVEMENTS", { fontSize: '28px', fill: '#ffd700' }).setOrigin(0.5).setDepth(501);
        
        const p = this.persistent;
        const accuracy = p.totalShotsFired > 0 ? Math.round((p.totalShotsHit / p.totalShotsFired) * 100) : 0;
        
        // Stats column
        const statsText = this.add.text(100, 120, 
            `LIFETIME STATS\n\n` +
            `Kills: ${p.totalKills}\n` +
            `Deaths: ${p.totalDeaths}\n` +
            `Extractions: ${p.runsCompleted}\n` +
            `Runs Started: ${p.runsStarted}\n` +
            `Accuracy: ${accuracy}%\n` +
            `(${p.totalShotsHit}/${p.totalShotsFired} shots)\n` +
            `Scrap Collected: ${p.totalScrapCollected}\n` +
            `Credits Earned: ${p.totalCreditsEarned || 0}\n` +
            `Materials Found: ${p.totalMaterialsCollected || 0}\n` +
            `Items Bought: ${p.itemsBought || 0}\n` +
            `Items Sold: ${p.itemsSold || 0}\n` +
            `Melee Kills: ${p.meleeKills}\n` +
            `Grenade Kills: ${p.totalGrenadeKills}\n` +
            `Bosses Killed: ${p.bossesKilled}`,
            { fontSize: '13px', fill: '#ccc', lineSpacing: 5 }
        ).setDepth(501);
        
        // Achievements column
        const achTitle = this.add.text(420, 120, "ACHIEVEMENTS", { fontSize: '16px', fill: '#ffd700' }).setDepth(501);
        let achY = 150;
        const allAchievements = Object.values(CONFIG.ACHIEVEMENTS);
        allAchievements.forEach(ach => {
            const unlocked = p.achievements.includes(ach.id);
            const color = unlocked ? '#00ff00' : '#555555';
            const icon = unlocked ? ach.icon : 'üîí';
            this.add.text(420, achY, `${icon} ${ach.name}`, { fontSize: '14px', fill: color }).setDepth(501);
            this.add.text(440, achY + 16, ach.desc, { fontSize: '11px', fill: unlocked ? '#888' : '#444' }).setDepth(501);
            achY += 40;
        });
        
        // Close button
        const closeBtn = this.add.text(400, 530, "[ CLOSE ]", { fontSize: '18px', fill: '#ff4444' }).setOrigin(0.5).setDepth(501).setInteractive();
        const elements = [overlay, title, statsText, achTitle, closeBtn];
        
        closeBtn.on('pointerdown', () => {
            sfx.menuClose();
            elements.forEach(e => e.destroy());
            // Destroy achievement texts too
            this.children.list.filter(c => c.depth === 501).forEach(c => c.destroy());
        });
    }
    
    showClassModal() {
        const elements = [];
        
        // Dark overlay
        const overlay = this.add.rectangle(400, 300, 800, 600, 0x000000, 0.8).setDepth(499).setInteractive();
        elements.push(overlay);
        overlay.on('pointerdown', () => {
            sfx.menuClose();
            elements.forEach(e => e.destroy());
        });
        
        // Modal background
        const modalBg = this.add.rectangle(400, 300, 550, 450, 0x1a1a1a, 0.98).setDepth(500).setStrokeStyle(3, 0x00aaaa);
        elements.push(modalBg);
        
        // Title
        const title = this.add.text(400, 100, "SELECT CLASS", { fontSize: '32px', fill: '#00ffff', fontStyle: 'bold' }).setOrigin(0.5).setDepth(501);
        elements.push(title);
        
        // Current class display
        const currentConfig = CONFIG.CLASSES[this.persistent.selectedClass.toUpperCase()] || CONFIG.CLASSES.SURVIVOR;
        const currentText = this.add.text(400, 140, `Current: ${currentConfig.icon} ${currentConfig.name}`, { fontSize: '16px', fill: '#aaa' }).setOrigin(0.5).setDepth(501);
        elements.push(currentText);
        
        // Class cards - 2x2 grid
        const classes = Object.values(CONFIG.CLASSES);
        const startX = 220;
        const startY = 200;
        const cardWidth = 170;
        const cardHeight = 100;
        const gap = 20;
        
        classes.forEach((classConfig, index) => {
            const col = index % 2;
            const row = Math.floor(index / 2);
            const x = startX + col * (cardWidth + gap);
            const y = startY + row * (cardHeight + gap);
            
            const isUnlocked = this.persistent.unlockedClasses.includes(classConfig.id);
            const isSelected = this.persistent.selectedClass === classConfig.id;
            
            // Card background
            const cardColor = isSelected ? 0x006666 : (isUnlocked ? 0x333333 : 0x222222);
            const card = this.add.rectangle(x + cardWidth/2, y + cardHeight/2, cardWidth, cardHeight, cardColor).setDepth(501);
            if (isSelected) card.setStrokeStyle(3, 0x00ffff);
            else if (isUnlocked) card.setStrokeStyle(2, 0x555555);
            else card.setStrokeStyle(2, 0x333333);
            elements.push(card);
            
            // Class icon and name
            const iconText = this.add.text(x + 15, y + 10, classConfig.icon, { fontSize: '28px' }).setDepth(502);
            elements.push(iconText);
            
            const nameColor = isUnlocked ? '#fff' : '#666';
            const nameText = this.add.text(x + 55, y + 15, classConfig.name, { fontSize: '18px', fill: nameColor, fontStyle: 'bold' }).setDepth(502);
            elements.push(nameText);
            
            // Description or lock reason
            if (isUnlocked) {
                const descText = this.add.text(x + 10, y + 50, classConfig.desc, { fontSize: '11px', fill: '#aaa', wordWrap: { width: cardWidth - 20 } }).setDepth(502);
                elements.push(descText);
                
                // Make clickable to select
                card.setInteractive();
                card.on('pointerdown', () => {
                    if (this.persistent.selectedClass !== classConfig.id) {
                        this.persistent.selectedClass = classConfig.id;
                        savePersistent(this.persistent);
                        sfx.success();
                        // Refresh modal
                        elements.forEach(e => e.destroy());
                        this.showClassModal();
                    }
                });
                card.on('pointerover', () => {
                    if (!isSelected) card.setFillStyle(0x444444);
                });
                card.on('pointerout', () => {
                    if (!isSelected) card.setFillStyle(0x333333);
                });
            } else {
                // Show unlock requirement
                let unlockReq = "???";
                if (classConfig.id === 'scout') unlockReq = "üîí Any level no damage";
                else if (classConfig.id === 'medic') unlockReq = "üîí Heal 50 total HP";
                else if (classConfig.id === 'scavenger') unlockReq = "üîí Collect 500 scrap";
                
                const lockText = this.add.text(x + 10, y + 50, unlockReq, { fontSize: '11px', fill: '#ff6666', wordWrap: { width: cardWidth - 20 } }).setDepth(502);
                elements.push(lockText);
            }
        });
        
        // Close button
        const closeBtn = this.add.text(400, 480, "[ CLOSE ]", { fontSize: '18px', fill: '#ff4444' }).setOrigin(0.5).setDepth(501).setInteractive();
        elements.push(closeBtn);
        closeBtn.on('pointerdown', () => {
            sfx.menuClose();
            elements.forEach(e => e.destroy());
        });
    }
    
    showSkillsPanel() {
        const elements = [];
        
        // Reload persistent data
        this.persistent = loadPersistent();
        
        // Dark overlay
        const overlay = this.add.rectangle(400, 300, 800, 600, 0x000000, 0.85).setDepth(499);
        elements.push(overlay);
        
        // Modal background
        const modalBg = this.add.rectangle(400, 300, 720, 520, 0x1a1a1a, 0.98).setDepth(500).setStrokeStyle(3, 0x8844aa);
        elements.push(modalBg);
        
        // Title with skill points
        const title = this.add.text(400, 65, "SKILL TREE", { fontSize: '28px', fill: '#aa66ff', fontStyle: 'bold' }).setOrigin(0.5).setDepth(501);
        elements.push(title);
        
        const pointsText = this.add.text(400, 95, `Skill Points: ${this.persistent.skillPoints || 0}`, { fontSize: '16px', fill: '#ffff00' }).setOrigin(0.5).setDepth(501);
        elements.push(pointsText);
        
        // Branch headers
        const branches = [
            { id: 'survival', name: 'SURVIVAL', x: 170, color: 0xff4444 },
            { id: 'stealth', name: 'STEALTH', x: 400, color: 0x44ff44 },
            { id: 'utility', name: 'UTILITY', x: 630, color: 0x4488ff }
        ];
        
        branches.forEach(branch => {
            const header = this.add.text(branch.x, 125, branch.name, { 
                fontSize: '16px', fill: '#ffffff', fontStyle: 'bold' 
            }).setOrigin(0.5).setDepth(501);
            elements.push(header);
            
            // Branch divider line
            const line = this.add.rectangle(branch.x, 140, 180, 2, branch.color).setDepth(501);
            elements.push(line);
        });
        
        // Render skills for each branch
        const branchSkills = {
            survival: ['thick_skin', 'iron_will', 'second_wind', 'regeneration', 'last_stand'],
            stealth: ['light_feet', 'shadow_step', 'silent_killer', 'ambush', 'ghost'],
            utility: ['quick_hands', 'haggler', 'scrapper', 'swift_reload', 'pack_mule']
        };
        
        const startY = 160;
        const skillHeight = 70;
        
        Object.entries(branchSkills).forEach(([branchId, skillIds]) => {
            const branch = branches.find(b => b.id === branchId);
            
            skillIds.forEach((skillId, index) => {
                const skillConfig = Object.values(CONFIG.SKILLS).find(s => s.id === skillId);
                if (!skillConfig) return;
                
                const y = startY + index * skillHeight;
                const x = branch.x;
                
                const isUnlocked = this.persistent.unlockedSkills?.includes(skillId);
                const canAfford = (this.persistent.skillPoints || 0) >= skillConfig.cost;
                const hasPrereq = !skillConfig.requires || this.persistent.unlockedSkills?.includes(skillConfig.requires);
                const canPurchase = !isUnlocked && canAfford && hasPrereq;
                
                // Skill card background
                let cardColor = 0x222222; // Locked
                if (isUnlocked) cardColor = 0x226622; // Unlocked
                else if (canPurchase) cardColor = 0x333366; // Can purchase
                else if (!hasPrereq) cardColor = 0x1a1a1a; // Missing prereq
                
                const card = this.add.rectangle(x, y + 25, 170, 60, cardColor).setDepth(501);
                if (isUnlocked) card.setStrokeStyle(2, 0x44ff44);
                else if (canPurchase) card.setStrokeStyle(2, 0x6666ff);
                else card.setStrokeStyle(1, 0x444444);
                elements.push(card);
                
                // Skill name
                const nameColor = isUnlocked ? '#44ff44' : (canPurchase ? '#aaaaff' : '#888888');
                const nameText = this.add.text(x, y + 10, skillConfig.name, { 
                    fontSize: '13px', fill: nameColor, fontStyle: 'bold' 
                }).setOrigin(0.5).setDepth(502);
                elements.push(nameText);
                
                // Skill description
                const descText = this.add.text(x, y + 28, skillConfig.desc, { 
                    fontSize: '10px', fill: '#aaaaaa', wordWrap: { width: 160 }
                }).setOrigin(0.5).setDepth(502);
                elements.push(descText);
                
                // Cost or status
                let statusText;
                if (isUnlocked) {
                    statusText = this.add.text(x, y + 48, '‚úì UNLOCKED', { 
                        fontSize: '10px', fill: '#44ff44' 
                    }).setOrigin(0.5).setDepth(502);
                } else if (!hasPrereq) {
                    const prereqSkill = Object.values(CONFIG.SKILLS).find(s => s.id === skillConfig.requires);
                    statusText = this.add.text(x, y + 48, `Requires: ${prereqSkill?.name || 'Unknown'}`, { 
                        fontSize: '10px', fill: '#ff6666' 
                    }).setOrigin(0.5).setDepth(502);
                } else {
                    statusText = this.add.text(x, y + 48, `Cost: ${skillConfig.cost} pts`, { 
                        fontSize: '10px', fill: canAfford ? '#ffff00' : '#ff6666' 
                    }).setOrigin(0.5).setDepth(502);
                }
                elements.push(statusText);
                
                // Make purchasable skills clickable
                if (canPurchase) {
                    card.setInteractive({ useHandCursor: true });
                    card.on('pointerover', () => card.setFillStyle(0x444488));
                    card.on('pointerout', () => card.setFillStyle(0x333366));
                    card.on('pointerdown', () => {
                        this.purchaseSkill(skillId);
                        sfx.success();
                        elements.forEach(e => e.destroy());
                        this.showSkillsPanel();
                    });
                }
                
                // Draw connection line to next skill (if has dependent)
                if (index < skillIds.length - 1) {
                    const nextSkillId = skillIds[index + 1];
                    const nextSkillConfig = Object.values(CONFIG.SKILLS).find(s => s.id === nextSkillId);
                    if (nextSkillConfig?.requires === skillId) {
                        const connLine = this.add.rectangle(x, y + 60, 2, 10, isUnlocked ? 0x44ff44 : 0x444444).setDepth(500);
                        elements.push(connLine);
                    }
                }
            });
        });
        
        // Close button
        const closeBtn = this.add.text(400, 540, "[ CLOSE ]", { 
            fontSize: '18px', fill: '#ff4444' 
        }).setOrigin(0.5).setDepth(510).setInteractive({ useHandCursor: true });
        elements.push(closeBtn);
        closeBtn.on('pointerdown', () => {
            sfx.menuClose();
            elements.forEach(e => e.destroy());
            // Refresh the scene to update button labels with current values
            this.scene.restart({ stats: this.stats });
        });
        closeBtn.on('pointerover', () => closeBtn.setColor('#ff6666'));
        closeBtn.on('pointerout', () => closeBtn.setColor('#ff4444'));
    }
    
    purchaseSkill(skillId) {
        const skillConfig = Object.values(CONFIG.SKILLS).find(s => s.id === skillId);
        if (!skillConfig) return false;
        
        // Verify can purchase
        if (this.persistent.unlockedSkills?.includes(skillId)) return false;
        if ((this.persistent.skillPoints || 0) < skillConfig.cost) return false;
        if (skillConfig.requires && !this.persistent.unlockedSkills?.includes(skillConfig.requires)) return false;
        
        // Purchase the skill
        this.persistent.skillPoints -= skillConfig.cost;
        if (!this.persistent.unlockedSkills) this.persistent.unlockedSkills = [];
        this.persistent.unlockedSkills.push(skillId);
        
        savePersistent(this.persistent);
        return true;
    }
    
    showChallengesPanel() {
        const elements = [];
        
        // Reload and check challenges
        this.persistent = loadPersistent();
        checkChallengeReset(this.persistent);
        
        // Check for completed challenges
        const completedChallenges = checkChallengeCompletion(this.persistent);
        if (completedChallenges.length > 0) {
            completedChallenges.forEach(c => {
                sfx.achievement();
            });
            savePersistent(this.persistent);
        }
        
        // Dark overlay
        const overlay = this.add.rectangle(400, 300, 800, 600, 0x000000, 0.85).setDepth(499);
        elements.push(overlay);
        
        // Modal background
        const modalBg = this.add.rectangle(400, 300, 700, 530, 0x1a1a1a, 0.98).setDepth(500).setStrokeStyle(3, 0x448844);
        elements.push(modalBg);
        
        // Title
        const title = this.add.text(400, 60, "CHALLENGES", { fontSize: '28px', fill: '#66ff66', fontStyle: 'bold' }).setOrigin(0.5).setDepth(501);
        elements.push(title);
        
        // Skill points display
        const pointsText = this.add.text(400, 90, `Skill Points: ${this.persistent.skillPoints || 0}`, { fontSize: '14px', fill: '#ffff00' }).setOrigin(0.5).setDepth(501);
        elements.push(pointsText);
        
        let yPos = 115;
        
        // === DAILY CHALLENGES ===
        const dailyResetTime = this.persistent.dailyResetTime - Date.now();
        const dailyHeader = this.add.text(80, yPos, `DAILY (Resets in ${formatTimeRemaining(dailyResetTime)})`, { fontSize: '14px', fill: '#ffaa00', fontStyle: 'bold' }).setDepth(501);
        elements.push(dailyHeader);
        yPos += 25;
        
        this.persistent.activeDailies?.forEach((challenge, index) => {
            const config = CONFIG.CHALLENGES.DAILY.find(c => c.id === challenge.id);
            if (!config) return;
            
            const isComplete = challenge.progress >= config.target;
            const isClaimed = challenge.claimed;
            
            // Challenge card
            const cardColor = isClaimed ? 0x224422 : (isComplete ? 0x336633 : 0x2a2a2a);
            const card = this.add.rectangle(400, yPos + 20, 620, 40, cardColor).setDepth(501);
            if (isComplete && !isClaimed) card.setStrokeStyle(2, 0x88ff88);
            elements.push(card);
            
            // Challenge name and desc
            const nameText = this.add.text(100, yPos + 12, config.name, { fontSize: '13px', fill: isClaimed ? '#666666' : '#ffffff', fontStyle: 'bold' }).setDepth(502);
            elements.push(nameText);
            
            const descText = this.add.text(100, yPos + 28, config.desc, { fontSize: '10px', fill: '#888888' }).setDepth(502);
            elements.push(descText);
            
            // Progress bar
            const progress = Math.min(challenge.progress / config.target, 1);
            const barBg = this.add.rectangle(550, yPos + 15, 120, 12, 0x333333).setDepth(502);
            elements.push(barBg);
            if (progress > 0) {
                const barFill = this.add.rectangle(490 + (progress * 60), yPos + 15, progress * 120, 10, isComplete ? 0x44ff44 : 0xffaa00).setDepth(503);
                elements.push(barFill);
            }
            
            // Progress text
            const progressText = this.add.text(550, yPos + 15, `${challenge.progress}/${config.target}`, { fontSize: '9px', fill: '#fff' }).setOrigin(0.5).setDepth(504);
            elements.push(progressText);
            
            // Reward/Status
            const rewardText = this.add.text(660, yPos + 20, isClaimed ? 'CLAIMED' : (isComplete ? 'CLAIM!' : `+${config.reward} pts`), { 
                fontSize: '11px', fill: isClaimed ? '#666666' : (isComplete ? '#88ff88' : '#ffff00')
            }).setOrigin(0.5).setDepth(502);
            elements.push(rewardText);
            
            // Make claimable challenges clickable
            if (isComplete && !isClaimed) {
                card.setInteractive({ useHandCursor: true });
                card.on('pointerdown', () => {
                    challenge.claimed = true;
                    this.persistent.skillPoints = (this.persistent.skillPoints || 0) + config.reward;
                    this.persistent.totalSkillPoints = (this.persistent.totalSkillPoints || 0) + config.reward;
                    savePersistent(this.persistent);
                    sfx.success();
                    elements.forEach(e => e.destroy());
                    this.showChallengesPanel();
                });
            }
            
            yPos += 45;
        });
        
        yPos += 10;
        
        // === WEEKLY CHALLENGES ===
        const weeklyResetTime = this.persistent.weeklyResetTime - Date.now();
        const weeklyHeader = this.add.text(80, yPos, `WEEKLY (Resets in ${formatTimeRemaining(weeklyResetTime)})`, { fontSize: '14px', fill: '#00aaff', fontStyle: 'bold' }).setDepth(501);
        elements.push(weeklyHeader);
        yPos += 25;
        
        this.persistent.activeWeeklies?.forEach((challenge, index) => {
            const config = CONFIG.CHALLENGES.WEEKLY.find(c => c.id === challenge.id);
            if (!config) return;
            
            const isComplete = challenge.progress >= config.target;
            const isClaimed = challenge.claimed;
            
            const cardColor = isClaimed ? 0x222244 : (isComplete ? 0x333366 : 0x2a2a2a);
            const card = this.add.rectangle(400, yPos + 20, 620, 40, cardColor).setDepth(501);
            if (isComplete && !isClaimed) card.setStrokeStyle(2, 0x88aaff);
            elements.push(card);
            
            const nameText = this.add.text(100, yPos + 12, config.name, { fontSize: '13px', fill: isClaimed ? '#666666' : '#ffffff', fontStyle: 'bold' }).setDepth(502);
            elements.push(nameText);
            
            const descText = this.add.text(100, yPos + 28, config.desc, { fontSize: '10px', fill: '#888888' }).setDepth(502);
            elements.push(descText);
            
            const progress = Math.min(challenge.progress / config.target, 1);
            const barBg = this.add.rectangle(550, yPos + 15, 120, 12, 0x333333).setDepth(502);
            elements.push(barBg);
            if (progress > 0) {
                const barFill = this.add.rectangle(490 + (progress * 60), yPos + 15, progress * 120, 10, isComplete ? 0x4488ff : 0xffaa00).setDepth(503);
                elements.push(barFill);
            }
            
            const progressText = this.add.text(550, yPos + 15, `${challenge.progress}/${config.target}`, { fontSize: '9px', fill: '#fff' }).setOrigin(0.5).setDepth(504);
            elements.push(progressText);
            
            const rewardText = this.add.text(660, yPos + 20, isClaimed ? 'CLAIMED' : (isComplete ? 'CLAIM!' : `+${config.reward} pts`), { 
                fontSize: '11px', fill: isClaimed ? '#666666' : (isComplete ? '#88aaff' : '#ffff00')
            }).setOrigin(0.5).setDepth(502);
            elements.push(rewardText);
            
            if (isComplete && !isClaimed) {
                card.setInteractive({ useHandCursor: true });
                card.on('pointerdown', () => {
                    challenge.claimed = true;
                    this.persistent.skillPoints = (this.persistent.skillPoints || 0) + config.reward;
                    this.persistent.totalSkillPoints = (this.persistent.totalSkillPoints || 0) + config.reward;
                    savePersistent(this.persistent);
                    sfx.success();
                    elements.forEach(e => e.destroy());
                    this.showChallengesPanel();
                });
            }
            
            yPos += 45;
        });
        
        // Close button
        const closeBtn = this.add.text(400, 550, "[ CLOSE ]", { fontSize: '18px', fill: '#ff4444' }).setOrigin(0.5).setDepth(510).setInteractive({ useHandCursor: true });
        elements.push(closeBtn);
        closeBtn.on('pointerdown', () => {
            sfx.menuClose();
            elements.forEach(e => e.destroy());
            // Refresh the scene to update button labels with current values
            this.scene.restart({ stats: this.stats });
        });
        closeBtn.on('pointerover', () => closeBtn.setColor('#ff6666'));
        closeBtn.on('pointerout', () => closeBtn.setColor('#ff4444'));
    }
    
    showModsPanel() {
        // Reload persistent data to get latest mod inventory
        this.persistent = loadPersistent();
        
        const elements = [];
        // Only initialize selectedMod if not already set (preserve selection during redraws)
        if (this.selectedMod === undefined) {
            this.selectedMod = null;
        }
        
        // Dark overlay
        const overlay = this.add.rectangle(400, 300, 800, 600, 0x000000, 0.8).setDepth(499);
        elements.push(overlay);
        
        // Modal background
        const modalBg = this.add.rectangle(400, 300, 700, 520, 0x1a1a1a, 0.98).setDepth(500).setStrokeStyle(3, 0xff00ff);
        elements.push(modalBg);
        
        // Title
        const title = this.add.text(400, 65, 'WEAPON MODS', { fontSize: '28px', fill: '#ff00ff', fontStyle: 'bold' }).setOrigin(0.5).setDepth(501);
        elements.push(title);
        
        const subtitle = this.add.text(400, 90, 'Click a mod, then click a weapon slot to equip', { fontSize: '12px', fill: '#888888' }).setOrigin(0.5).setDepth(501);
        elements.push(subtitle);
        
        // Inventory section (top half)
        const invLabel = this.add.text(80, 110, 'INVENTORY', { fontSize: '14px', fill: '#ffaa00', fontStyle: 'bold' }).setDepth(501);
        elements.push(invLabel);
        
        // Get unique mod types and counts from inventory
        const modCounts = {};
        (this.persistent.modInventory || []).forEach(modId => {
            modCounts[modId] = (modCounts[modId] || 0) + 1;
        });
        
        // Display mods in inventory
        const modTypes = Object.keys(modCounts);
        let modX = 80;
        modTypes.forEach((modId, index) => {
            const modConfig = Object.values(CONFIG.MODS).find(m => m.id === modId);
            if (!modConfig) return;
            
            const count = modCounts[modId];
            const modBg = this.add.rectangle(modX + 55, 160, 100, 60, 0x333355).setDepth(501).setInteractive({ useHandCursor: true });
            elements.push(modBg);
            
            const modIcon = this.add.text(modX + 55, 150, modConfig.icon, { fontSize: '24px', fill: '#ffffff' }).setOrigin(0.5).setDepth(502);
            elements.push(modIcon);
            
            const modName = this.add.text(modX + 55, 175, modConfig.name, { fontSize: '9px', fill: '#aaaaaa' }).setOrigin(0.5).setDepth(502);
            elements.push(modName);
            
            if (count > 1) {
                const countText = this.add.text(modX + 95, 135, `x${count}`, { fontSize: '12px', fill: '#ffff00' }).setDepth(503);
                elements.push(countText);
            }
            
            modBg.on('pointerdown', () => {
                this.selectedMod = modId;
                sfx.click();
                // Highlight selection - redraw panel
                elements.forEach(e => e.destroy());
                this.showModsPanel();
            });
            
            modBg.on('pointerover', () => modBg.setFillStyle(0x555577));
            modBg.on('pointerout', () => modBg.setFillStyle(this.selectedMod === modId ? 0x5555aa : 0x333355));
            
            // Highlight if selected
            if (this.selectedMod === modId) {
                modBg.setFillStyle(0x5555aa);
                modBg.setStrokeStyle(2, 0xffff00);
            }
            
            modX += 110;
        });
        
        if (modTypes.length === 0) {
            const noMods = this.add.text(400, 160, 'No mods in inventory - find them in levels or buy from trader', { fontSize: '12px', fill: '#666666' }).setOrigin(0.5).setDepth(501);
            elements.push(noMods);
        }
        
        // Weapon slots section (bottom half)
        const weaponsLabel = this.add.text(80, 210, 'EQUIPPED MODS (Current Run)', { fontSize: '14px', fill: '#ffaa00', fontStyle: 'bold' }).setDepth(501);
        elements.push(weaponsLabel);
        
        const weapons = ['pistol', 'shotgun', 'smg', 'crossbow', 'rifle'];
        const weaponNames = { pistol: 'PISTOL', shotgun: 'SHOTGUN', smg: 'SMG', crossbow: 'CROSSBOW', rifle: 'RIFLE' };
        let weaponY = 245;
        
        weapons.forEach((weapon, wIndex) => {
            // Weapon label
            const weaponLabel = this.add.text(80, weaponY, weaponNames[weapon], { fontSize: '14px', fill: '#ffffff' }).setDepth(501);
            elements.push(weaponLabel);
            
            // Two slots per weapon
            for (let slot = 0; slot < 2; slot++) {
                const slotX = 200 + slot * 130;
                const equippedModId = this.stats.equippedMods?.[weapon]?.[slot];
                const equippedMod = equippedModId ? Object.values(CONFIG.MODS).find(m => m.id === equippedModId) : null;
                
                const slotBg = this.add.rectangle(slotX + 45, weaponY + 8, 110, 30, equippedMod ? 0x445544 : 0x222233).setDepth(501).setInteractive({ useHandCursor: true });
                elements.push(slotBg);
                
                if (equippedMod) {
                    const slotText = this.add.text(slotX + 45, weaponY + 8, `[${equippedMod.icon}] ${equippedMod.name}`, { fontSize: '10px', fill: '#88ff88' }).setOrigin(0.5).setDepth(502);
                    elements.push(slotText);
                } else {
                    const slotText = this.add.text(slotX + 45, weaponY + 8, 'Empty Slot', { fontSize: '10px', fill: '#555555' }).setOrigin(0.5).setDepth(502);
                    elements.push(slotText);
                }
                
                slotBg.on('pointerdown', () => {
                    if (this.selectedMod) {
                        // Equipping a mod
                        const modConfig = Object.values(CONFIG.MODS).find(m => m.id === this.selectedMod);
                        
                        // Check compatibility
                        if (!modConfig.compatible.includes(weapon)) {
                            sfx.error();
                            this.showFloatingText(400, 300, `${modConfig.name} not compatible with ${weaponNames[weapon]}!`, '#ff4444');
                            return;
                        }
                        
                        // Check if mod is in inventory
                        const modIndex = this.persistent.modInventory.indexOf(this.selectedMod);
                        if (modIndex === -1) {
                            sfx.error();
                            return;
                        }
                        
                        // If slot has existing mod, return it to inventory
                        if (equippedModId) {
                            this.persistent.modInventory.push(equippedModId);
                        }
                        
                        // Remove mod from inventory and equip
                        this.persistent.modInventory.splice(modIndex, 1);
                        if (!this.stats.equippedMods) {
                            this.stats.equippedMods = { pistol: [null, null], shotgun: [null, null], smg: [null, null], crossbow: [null, null], rifle: [null, null] };
                        }
                        this.stats.equippedMods[weapon][slot] = this.selectedMod;
                        
                        savePersistent(this.persistent);
                        localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));
                        
                        sfx.success();
                        this.selectedMod = null;
                        elements.forEach(e => e.destroy());
                        this.showModsPanel();
                    } else if (equippedModId) {
                        // Unequipping - return mod to inventory
                        this.persistent.modInventory.push(equippedModId);
                        this.stats.equippedMods[weapon][slot] = null;
                        
                        savePersistent(this.persistent);
                        localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));
                        
                        sfx.click();
                        elements.forEach(e => e.destroy());
                        this.showModsPanel();
                    }
                });
                
                slotBg.on('pointerover', () => slotBg.setFillStyle(this.selectedMod ? 0x444466 : 0x333344));
                slotBg.on('pointerout', () => slotBg.setFillStyle(equippedMod ? 0x445544 : 0x222233));
            }
            
            weaponY += 45;
        });
        
        // Mod description if selected
        if (this.selectedMod) {
            const selectedConfig = Object.values(CONFIG.MODS).find(m => m.id === this.selectedMod);
            if (selectedConfig) {
                const descBg = this.add.rectangle(560, 320, 200, 150, 0x222244).setDepth(501).setStrokeStyle(1, 0x5555aa);
                elements.push(descBg);
                
                const descTitle = this.add.text(560, 260, selectedConfig.name, { fontSize: '14px', fill: '#ff00ff', fontStyle: 'bold' }).setOrigin(0.5).setDepth(502);
                elements.push(descTitle);
                
                const descText = this.add.text(560, 285, selectedConfig.desc, { fontSize: '12px', fill: '#ffffff' }).setOrigin(0.5).setDepth(502);
                elements.push(descText);
                
                const compatLabel = this.add.text(560, 320, 'Compatible with:', { fontSize: '10px', fill: '#888888' }).setOrigin(0.5).setDepth(502);
                elements.push(compatLabel);
                
                const compatWeapons = selectedConfig.compatible.map(w => weaponNames[w] || w).join(', ');
                const compatText = this.add.text(560, 340, compatWeapons, { fontSize: '10px', fill: '#88ff88', wordWrap: { width: 180 } }).setOrigin(0.5).setDepth(502);
                elements.push(compatText);
                
                const cancelBtn = this.add.text(560, 380, '[ CANCEL SELECTION ]', { fontSize: '10px', fill: '#ff8888' }).setOrigin(0.5).setDepth(502).setInteractive({ useHandCursor: true });
                elements.push(cancelBtn);
                cancelBtn.on('pointerdown', () => {
                    this.selectedMod = null;
                    sfx.click();
                    elements.forEach(e => e.destroy());
                    this.showModsPanel();
                });
            }
        }
        
        // Close button
        const closeBtn = this.add.text(400, 540, "[ CLOSE ]", { fontSize: '18px', fill: '#ff4444' }).setOrigin(0.5).setDepth(510).setInteractive({ useHandCursor: true });
        elements.push(closeBtn);
        closeBtn.on('pointerdown', () => {
            sfx.menuClose();
            this.selectedMod = null; // Clear selection when closing
            elements.forEach(e => e.destroy());
            this.scene.restart({ stats: this.stats });
        });
        closeBtn.on('pointerover', () => closeBtn.setColor('#ff6666'));
        closeBtn.on('pointerout', () => closeBtn.setColor('#ff4444'));
    }
    
    showUpgradesPanel() {
        // Reload persistent data to get latest stats
        this.persistent = loadPersistent();
        
        // Check for newly unlocked upgrades before showing panel
        const newUpgrades = checkUpgrades(this.persistent);
        if (newUpgrades.length > 0) {
            savePersistent(this.persistent);
            // Show notification for newly unlocked upgrades
            newUpgrades.forEach(u => {
                this.showFloatingText(400, 250, `UNLOCKED: ${u.name}!`, '#88ff88');
            });
        }
        
        const elements = [];
        if (!this.upgradeTab) this.upgradeTab = 'gear'; // Current tab (preserve across refreshes)
        
        // Dark overlay - NOT interactive, just visual
        const overlay = this.add.rectangle(400, 300, 800, 600, 0x000000, 0.8).setDepth(499);
        elements.push(overlay);
        
        // Modal background
        const modalBg = this.add.rectangle(400, 300, 650, 500, 0x1a1a1a, 0.98).setDepth(500).setStrokeStyle(3, 0xffaa00);
        elements.push(modalBg);
        
        // Title
        const title = this.add.text(400, 75, "PERMANENT UPGRADES", { fontSize: '28px', fill: '#ffaa00', fontStyle: 'bold' }).setOrigin(0.5).setDepth(501);
        elements.push(title);
        
        // Tab buttons - positioned in a row
        const tabData = [
            { id: 'gear', label: 'GEAR' },
            { id: 'stats', label: 'STATS' },
            { id: 'skin', label: 'SKINS' },
            { id: 'muzzle', label: 'EFFECTS' }
        ];
        
        const tabStartX = 170;
        const tabSpacing = 130;
        const tabY = 115;
        
        tabData.forEach((tab, index) => {
            const tabX = tabStartX + index * tabSpacing;
            const isActive = this.upgradeTab === tab.id;
            
            // Tab button background
            const btn = this.add.rectangle(tabX, tabY, 110, 30, isActive ? 0xffaa00 : 0x444444).setDepth(510).setInteractive({ useHandCursor: true });
            elements.push(btn);
            
            // Tab label
            const label = this.add.text(tabX, tabY, tab.label, { 
                fontSize: '14px', 
                fill: isActive ? '#000' : '#fff',
                fontStyle: 'bold'
            }).setOrigin(0.5).setDepth(511);
            elements.push(label);
            
            // Click handler
            btn.on('pointerdown', () => {
                this.upgradeTab = tab.id;
                sfx.click();
                elements.forEach(e => e.destroy());
                this.showUpgradesPanel();
            });
            
            // Hover effects for inactive tabs
            if (!isActive) {
                btn.on('pointerover', () => {
                    btn.setFillStyle(0x666666);
                    label.setColor('#ffaa00');
                });
                btn.on('pointerout', () => {
                    btn.setFillStyle(0x444444);
                    label.setColor('#fff');
                });
            }
        });
        
        // Render upgrade items for current tab
        this.renderUpgradeItems(elements, this.upgradeTab);
        
        // Close button
        const closeBtn = this.add.text(400, 530, "[ CLOSE ]", { 
            fontSize: '18px', 
            fill: '#ff4444' 
        }).setOrigin(0.5).setDepth(510).setInteractive({ useHandCursor: true });
        elements.push(closeBtn);
        closeBtn.on('pointerdown', () => {
            sfx.menuClose();
            elements.forEach(e => e.destroy());
        });
        closeBtn.on('pointerover', () => closeBtn.setColor('#ff6666'));
        closeBtn.on('pointerout', () => closeBtn.setColor('#ff4444'));
    }
    
    renderUpgradeItems(elements, category) {
        const upgrades = Object.values(CONFIG.UPGRADES).filter(u => u.category === category);
        const startY = 160;
        const itemHeight = 70;
        
        // Show message if no upgrades in this category
        if (upgrades.length === 0) {
            const noItems = this.add.text(400, 300, 'No upgrades in this category', { fontSize: '16px', fill: '#666' }).setOrigin(0.5).setDepth(502);
            elements.push(noItems);
            return;
        }
        
        upgrades.forEach((upgrade, index) => {
            const y = startY + index * itemHeight;
            const isUnlocked = this.persistent.unlockedUpgrades?.includes(upgrade.id);
            const isEquipped = (category === 'skin' && this.persistent.equippedSkin === upgrade.id) ||
                              (category === 'muzzle' && this.persistent.equippedMuzzle === upgrade.id);
            
            // Card background
            const cardColor = isEquipped ? 0x446644 : (isUnlocked ? 0x333333 : 0x222222);
            const card = this.add.rectangle(400, y + 25, 580, 60, cardColor).setDepth(501);
            if (isEquipped) card.setStrokeStyle(2, 0x88ff88);
            else if (isUnlocked) card.setStrokeStyle(1, 0x555555);
            elements.push(card);
            
            // Icon and name
            const icon = this.add.text(130, y + 10, upgrade.icon || '?', { fontSize: '24px' }).setDepth(502);
            elements.push(icon);
            
            const nameColor = isUnlocked ? '#fff' : '#888';
            const name = this.add.text(170, y + 10, upgrade.name, { fontSize: '18px', fill: nameColor, fontStyle: 'bold' }).setDepth(502);
            elements.push(name);
            
            // Description
            const desc = this.add.text(170, y + 35, upgrade.desc, { fontSize: '12px', fill: '#aaa' }).setDepth(502);
            elements.push(desc);
            
            if (isUnlocked) {
                // Show checkmark or equip button for cosmetics
                if (category === 'skin' || category === 'muzzle') {
                    if (isEquipped) {
                        const equipped = this.add.text(620, y + 25, '‚úì EQUIPPED', { fontSize: '12px', fill: '#88ff88' }).setOrigin(0.5).setDepth(502);
                        elements.push(equipped);
                    } else {
                        const equipBtn = this.add.rectangle(620, y + 25, 80, 30, 0x446688).setDepth(515).setInteractive({ useHandCursor: true });
                        elements.push(equipBtn);
                        const equipText = this.add.text(620, y + 25, 'EQUIP', { fontSize: '12px', fill: '#fff' }).setOrigin(0.5).setDepth(516);
                        elements.push(equipText);
                        
                        equipBtn.on('pointerdown', () => {
                            if (category === 'skin') {
                                this.persistent.equippedSkin = upgrade.id;
                            } else if (category === 'muzzle') {
                                this.persistent.equippedMuzzle = upgrade.id;
                            }
                            savePersistent(this.persistent);
                            sfx.success();
                            elements.forEach(e => e.destroy());
                            this.showUpgradesPanel();
                        });
                        equipBtn.on('pointerover', () => equipBtn.setFillStyle(0x5577aa));
                        equipBtn.on('pointerout', () => equipBtn.setFillStyle(0x446688));
                    }
                } else {
                    // Non-cosmetic: just show checkmark
                    const check = this.add.text(620, y + 25, '‚úì UNLOCKED', { fontSize: '12px', fill: '#88ff88' }).setOrigin(0.5).setDepth(502);
                    elements.push(check);
                }
            } else {
                // Show progress bar
                const req = upgrade.requirement;
                const current = this.persistent[req.stat] || 0;
                const progress = Math.min(current / req.value, 1);
                
                // Progress bar background
                const barBg = this.add.rectangle(540, y + 25, 150, 16, 0x222222).setDepth(502);
                elements.push(barBg);
                
                // Progress bar fill
                if (progress > 0) {
                    const barFill = this.add.rectangle(465 + (progress * 150) / 2, y + 25, progress * 150, 12, 0xffaa00).setDepth(503);
                    elements.push(barFill);
                }
                
                // Progress text
                const progressText = this.add.text(540, y + 25, `${current}/${req.value}`, { fontSize: '10px', fill: '#fff' }).setOrigin(0.5).setDepth(504);
                elements.push(progressText);
            }
        });
    }
    
    showTraderModal() {
        const elements = [];
        this.traderTab = 'buy'; // Track current tab
        this.traderScrollOffset = 0; // Track scroll position for buy items
        
        // Dark overlay - click to close
        const overlay = this.add.rectangle(400, 300, 800, 600, 0x000000, 0.7).setDepth(499).setInteractive();
        elements.push(overlay);
        overlay.on('pointerdown', () => this.closeTraderModal(elements));
        
        // Modal background
        const modalBg = this.add.rectangle(400, 300, 600, 480, 0x1a1a1a, 0.98).setDepth(500).setStrokeStyle(3, 0xffd700);
        elements.push(modalBg);
        
        // Title
        const title = this.add.text(400, 85, "TRADER", { fontSize: '36px', fill: '#ffd700', fontStyle: 'bold' }).setOrigin(0.5).setDepth(501);
        elements.push(title);
        
        // Currency display
        const currencyText = this.add.text(400, 120, 
            `üí∞ Credits: ${this.stats.credits}  |  üîß Scrap: ${this.stats.scrap}  |  ‚öôÔ∏è Materials: ${this.stats.materials}`,
            { fontSize: '14px', fill: '#ccc' }
        ).setOrigin(0.5).setDepth(501);
        elements.push(currencyText);
        this.traderCurrencyText = currencyText;
        
        // Tab buttons
        const buyTab = this.add.rectangle(300, 155, 150, 35, 0xffd700).setDepth(501).setInteractive();
        const buyTabText = this.add.text(300, 155, "BUY", { fontSize: '18px', fill: '#000', fontStyle: 'bold' }).setOrigin(0.5).setDepth(502);
        elements.push(buyTab, buyTabText);
        
        const sellTab = this.add.rectangle(500, 155, 150, 35, 0x444444).setDepth(501).setInteractive();
        const sellTabText = this.add.text(500, 155, "SELL", { fontSize: '18px', fill: '#fff' }).setOrigin(0.5).setDepth(502);
        elements.push(sellTab, sellTabText);
        
        // Content area (interactive for mouse wheel scrolling)
        const contentBg = this.add.rectangle(400, 350, 560, 280, 0x222222).setDepth(500).setInteractive();
        elements.push(contentBg);
        
        // Mouse wheel scrolling for trader
        contentBg.on('wheel', (pointer, deltaX, deltaY) => {
            if (this.traderTab === 'buy') {
                const totalItems = CONFIG.TRADER.HIDEOUT_STOCK.length;
                const maxVisibleItems = 6;
                const maxScroll = Math.max(0, totalItems - maxVisibleItems);
                
                if (deltaY > 0 && this.traderScrollOffset < maxScroll) {
                    this.traderScrollOffset++;
                    this.renderTraderItems(elements);
                } else if (deltaY < 0 && this.traderScrollOffset > 0) {
                    this.traderScrollOffset--;
                    this.renderTraderItems(elements);
                }
            }
        });
        
        // Store item elements reference for tab switching
        this.traderItemElements = [];
        
        // Tab click handlers
        buyTab.on('pointerdown', () => {
            sfx.click();
            this.traderTab = 'buy';
            buyTab.setFillStyle(0xffd700);
            buyTabText.setColor('#000');
            sellTab.setFillStyle(0x444444);
            sellTabText.setColor('#fff');
            this.renderTraderItems(elements);
        });
        
        sellTab.on('pointerdown', () => {
            sfx.click();
            this.traderTab = 'sell';
            sellTab.setFillStyle(0xffd700);
            sellTabText.setColor('#000');
            buyTab.setFillStyle(0x444444);
            buyTabText.setColor('#fff');
            this.renderTraderItems(elements);
        });
        
        // Close button
        const closeBtn = this.add.text(400, 520, "[ CLOSE ]", { fontSize: '18px', fill: '#ff4444' }).setOrigin(0.5).setDepth(501).setInteractive();
        elements.push(closeBtn);
        closeBtn.on('pointerdown', () => this.closeTraderModal(elements));
        
        // Store elements reference
        this.traderElements = elements;
        
        // Render initial items
        this.renderTraderItems(elements);
    }
    
    renderTraderItems(elements) {
        // Clear previous item elements
        if (this.traderItemElements) {
            this.traderItemElements.forEach(e => e.destroy());
        }
        this.traderItemElements = [];
        
        const startY = 195;
        const itemHeight = 45;
        const maxVisibleItems = 6; // Show 6 items at a time
        
        if (this.traderTab === 'buy') {
            const allItems = CONFIG.TRADER.HIDEOUT_STOCK;
            const totalItems = allItems.length;
            const maxScroll = Math.max(0, totalItems - maxVisibleItems);
            
            // Clamp scroll offset
            if (this.traderScrollOffset === undefined) this.traderScrollOffset = 0;
            this.traderScrollOffset = Math.max(0, Math.min(this.traderScrollOffset, maxScroll));
            
            // Render visible items
            const visibleItems = allItems.slice(this.traderScrollOffset, this.traderScrollOffset + maxVisibleItems);
            visibleItems.forEach((item, i) => {
                const y = startY + i * itemHeight;
                
                // Item name
                const nameText = this.add.text(150, y, item.name, { fontSize: '16px', fill: '#fff' }).setDepth(501);
                this.traderItemElements.push(nameText);
                
                // Item description
                let desc = '';
                if (item.type === 'ammo') desc = `+${item.amount} ammo`;
                else if (item.type === 'heal') desc = `+${item.amount} HP`;
                else if (item.type === 'grenade') desc = `+${item.amount} grenade`;
                else if (item.type === 'consumable') desc = CONFIG.CONSUMABLES[item.id]?.icon || '';
                else if (item.type === 'mod') {
                    const modConfig = Object.values(CONFIG.MODS).find(m => m.id === item.id);
                    desc = modConfig ? modConfig.desc : 'Weapon mod';
                }
                
                const descText = this.add.text(300, y, desc, { fontSize: '12px', fill: '#888' }).setDepth(501);
                this.traderItemElements.push(descText);
                
                // Cost (with Haggler discount if applicable)
                const currIcon = CONFIG.CURRENCIES[item.currency.toUpperCase()].icon;
                const hasHaggler = this.persistent.unlockedSkills?.includes('haggler');
                const displayCost = hasHaggler ? Math.floor(item.cost * 0.85) : item.cost;
                const costColor = hasHaggler ? '#88ff88' : '#ffd700'; // Green if discounted
                const costText = this.add.text(480, y, `${displayCost} ${currIcon}`, { fontSize: '14px', fill: costColor }).setDepth(501);
                this.traderItemElements.push(costText);
                
                // Buy button
                const canAfford = this.stats[item.currency] >= displayCost;
                const buyBtn = this.add.rectangle(600, y + 8, 70, 28, canAfford ? 0x00aa00 : 0x444444).setDepth(501).setInteractive();
                const buyBtnText = this.add.text(600, y + 8, "BUY", { fontSize: '14px', fill: '#fff' }).setOrigin(0.5).setDepth(502);
                this.traderItemElements.push(buyBtn, buyBtnText);
                
                if (canAfford) {
                    buyBtn.on('pointerdown', () => {
                        if (this.purchaseItem(item)) {
                            this.updateTraderCurrency();
                            this.renderTraderItems(elements);
                        }
                    });
                    buyBtn.on('pointerover', () => buyBtn.setAlpha(0.8));
                    buyBtn.on('pointerout', () => buyBtn.setAlpha(1));
                }
            });
            
            // Scroll buttons (only show if needed)
            if (totalItems > maxVisibleItems) {
                // Scroll up button
                const canScrollUp = this.traderScrollOffset > 0;
                const upBtn = this.add.text(640, 180, '‚ñ≤', { fontSize: '20px', fill: canScrollUp ? '#ffd700' : '#444' })
                    .setDepth(503).setInteractive({ useHandCursor: canScrollUp });
                this.traderItemElements.push(upBtn);
                if (canScrollUp) {
                    upBtn.on('pointerdown', () => {
                        this.traderScrollOffset--;
                        sfx.click();
                        this.renderTraderItems(elements);
                    });
                }
                
                // Scroll down button
                const canScrollDown = this.traderScrollOffset < maxScroll;
                const downBtn = this.add.text(640, 460, '‚ñº', { fontSize: '20px', fill: canScrollDown ? '#ffd700' : '#444' })
                    .setDepth(503).setInteractive({ useHandCursor: canScrollDown });
                this.traderItemElements.push(downBtn);
                if (canScrollDown) {
                    downBtn.on('pointerdown', () => {
                        this.traderScrollOffset++;
                        sfx.click();
                        this.renderTraderItems(elements);
                    });
                }
                
                // Scroll indicator
                const scrollText = this.add.text(640, 320, `${this.traderScrollOffset + 1}-${Math.min(this.traderScrollOffset + maxVisibleItems, totalItems)}/${totalItems}`, 
                    { fontSize: '10px', fill: '#666' }).setOrigin(0.5).setDepth(503);
                this.traderItemElements.push(scrollText);
            }
        } else {
            // Render sell items
            let y = startY;
            const sellItems = [];
            
            // Add armor pieces that can be sold
            const armorSlots = ['head', 'body', 'arms', 'feet'];
            armorSlots.forEach(slot => {
                if (this.stats.armor[slot]) {
                    sellItems.push({
                        type: 'armor',
                        slot: slot,
                        name: this.stats.armor[slot].name,
                        value: Math.floor(20 * CONFIG.TRADER.SELL_RATE)
                    });
                }
            });
            
            // Add consumables that can be sold
            this.stats.consumables.forEach((cons, idx) => {
                if (cons) {
                    const config = CONFIG.CONSUMABLES[cons];
                    sellItems.push({
                        type: 'consumable',
                        slot: idx,
                        name: config.name,
                        value: Math.floor(25 * CONFIG.TRADER.SELL_RATE)
                    });
                }
            });
            
            // Add unequipped weapon mods that can be sold
            const modInventory = this.persistent.modInventory || [];
            const modCounts = {};
            modInventory.forEach(modId => {
                modCounts[modId] = (modCounts[modId] || 0) + 1;
            });
            
            Object.entries(modCounts).forEach(([modId, count]) => {
                const modConfig = Object.values(CONFIG.MODS).find(m => m.id === modId);
                if (modConfig) {
                    // Sell value is based on material cost (50% rate)
                    const baseCost = modConfig.cost?.amount || 15;
                    const sellValue = Math.floor(baseCost * 0.5);
                    sellItems.push({
                        type: 'mod',
                        modId: modId,
                        name: `${modConfig.name}${count > 1 ? ' (x' + count + ')' : ''}`,
                        displayName: modConfig.name,
                        value: sellValue,
                        count: count
                    });
                }
            });
            
            if (sellItems.length === 0) {
                const noItems = this.add.text(400, 300, "Nothing to sell", { fontSize: '18px', fill: '#666' }).setOrigin(0.5).setDepth(501);
                this.traderItemElements.push(noItems);
            } else {
                sellItems.forEach((item, i) => {
                    const itemY = startY + i * itemHeight;
                    
                    // Mods show differently (sell for materials)
                    const nameColor = item.type === 'mod' ? '#cc88ff' : '#fff';
                    const nameText = this.add.text(150, itemY, item.name, { fontSize: '16px', fill: nameColor }).setDepth(501);
                    this.traderItemElements.push(nameText);
                    
                    // Mods sell for materials (‚öôÔ∏è), others sell for credits (üí∞)
                    const currencyIcon = item.type === 'mod' ? '‚öôÔ∏è' : 'üí∞';
                    const valueText = this.add.text(450, itemY, `+${item.value} ${currencyIcon}`, { fontSize: '14px', fill: '#00ff00' }).setDepth(501);
                    this.traderItemElements.push(valueText);
                    
                    const sellBtn = this.add.rectangle(600, itemY + 8, 70, 28, 0xaa0000).setDepth(501).setInteractive();
                    const sellBtnText = this.add.text(600, itemY + 8, "SELL", { fontSize: '14px', fill: '#fff' }).setOrigin(0.5).setDepth(502);
                    this.traderItemElements.push(sellBtn, sellBtnText);
                    
                    sellBtn.on('pointerdown', () => {
                        this.sellItem(item);
                        this.updateTraderCurrency();
                        this.renderTraderItems(elements);
                    });
                    sellBtn.on('pointerover', () => sellBtn.setAlpha(0.8));
                    sellBtn.on('pointerout', () => sellBtn.setAlpha(1));
                });
            }
        }
    }
    
    updateTraderCurrency() {
        if (this.traderCurrencyText) {
            this.traderCurrencyText.setText(
                `üí∞ Credits: ${this.stats.credits}  |  üîß Scrap: ${this.stats.scrap}  |  ‚öôÔ∏è Materials: ${this.stats.materials}`
            );
        }
        this.updateStatText();
    }
    
    closeTraderModal(elements) {
        sfx.menuClose();
        if (this.traderItemElements) {
            this.traderItemElements.forEach(e => e.destroy());
            this.traderItemElements = [];
        }
        elements.forEach(e => e.destroy());
        localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));
    }
    
    purchaseItem(item) {
        const currency = item.currency;
        let cost = item.cost;
        
        // Apply Haggler skill discount (15%)
        if (this.persistent.unlockedSkills?.includes('haggler')) {
            cost = Math.floor(cost * 0.85);
        }
        
        // Check if player can afford
        if (this.stats[currency] < cost) {
            sfx.error();
            return false;
        }
        
        // For consumables, check if there's an empty slot
        if (item.type === 'consumable') {
            const emptySlot = this.stats.consumables.findIndex(c => c === null);
            if (emptySlot === -1) {
                sfx.error();
                // Show feedback somehow
                return false;
            }
        }
        
        // For grenades, check max carry
        if (item.type === 'grenade' && this.stats.grenades >= CONFIG.GRENADE.MAX_CARRY) {
            sfx.error();
            return false;
        }
        
        // Deduct cost
        this.stats[currency] -= cost;
        this.persistent.itemsBought++;
        
        // Apply item effect
        switch (item.type) {
            case 'ammo':
                this.stats.ammo += item.amount;
                break;
            case 'heal':
                const oldHp = this.stats.hp;
                this.stats.hp = Math.min(this.stats.hp + item.amount, this.stats.maxHp);
                const healedAmount = this.stats.hp - oldHp;
                if (healedAmount > 0) {
                    this.persistent.totalHPHealed = (this.persistent.totalHPHealed || 0) + healedAmount;
                    // Check medic unlock achievement
                    const medicAchievements = checkAchievements(this.persistent, {});
                    medicAchievements.forEach(a => {
                        sfx.achievement();
                    });
                }
                break;
            case 'grenade':
                this.stats.grenades = Math.min(this.stats.grenades + item.amount, CONFIG.GRENADE.MAX_CARRY);
                break;
            case 'consumable':
                this.addConsumable(item.id);
                break;
            case 'mod':
                // Add mod to persistent inventory
                if (!this.persistent.modInventory) this.persistent.modInventory = [];
                this.persistent.modInventory.push(item.id);
                break;
        }
        
        sfx.purchase();
        savePersistent(this.persistent);
        localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));
        return true;
    }
    
    addConsumable(consumableId) {
        const emptySlot = this.stats.consumables.findIndex(c => c === null);
        if (emptySlot !== -1) {
            this.stats.consumables[emptySlot] = consumableId;
            return true;
        }
        return false;
    }
    
    sellItem(item) {
        if (item.type === 'armor') {
            // Remove armor and add credits
            this.stats.armor[item.slot] = null;
            this.stats.credits += item.value;
        } else if (item.type === 'consumable') {
            // Remove consumable and add credits
            this.stats.consumables[item.slot] = null;
            this.stats.credits += item.value;
        } else if (item.type === 'mod') {
            // Remove ONE mod from inventory and add materials (mods sell for materials)
            const modIndex = this.persistent.modInventory.indexOf(item.modId);
            if (modIndex !== -1) {
                this.persistent.modInventory.splice(modIndex, 1);
                this.stats.materials += item.value;
            }
        }
        
        this.persistent.itemsSold++;
        sfx.sell();
        savePersistent(this.persistent);
        localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));
        return true;
    }

    update(time, delta) {
        if (this.armoryTimerText && this.stats.hideout.armory.crafting) {
            let remaining = this.stats.hideout.armory.crafting.finishTime - Date.now();
            if (remaining > 0) {
                let seconds = Math.floor(remaining / 1000);
                this.armoryTimerText.setText(`CRAFTING: ${Math.floor(seconds/60)}:${(seconds%60).toString().padStart(2,'0')}`);
                this.armoryBtnText.setText("WAIT...");
            } else {
                this.armoryTimerText.setText("COMPLETE!");
                this.armoryBtnText.setText("CLAIM NVG");
                this.armoryBtn.setInteractive();
            }
        }
    }

    createArmoryCard(x, y) {
        this.add.rectangle(x + 100, y + 75, 220, 160, 0x333333).setStrokeStyle(2, 0x555555);
        this.add.text(x + 10, y + 10, "ARMORY", { fontSize: '20px', fill: '#ff00ff' });
        this.armoryDesc = this.add.text(x + 10, y + 40, "", { fontSize: '14px', fill: '#aaa' });
        this.armoryTimerText = this.add.text(x + 10, y + 80, "", { fontSize: '14px', fill: '#00ff00' });
        this.armoryBtn = this.add.rectangle(x + 100, y + 130, 200, 30, 0x555555).setInteractive();
        this.armoryBtnText = this.add.text(x + 100, y + 130, "", { fontSize: '14px', fill: '#fff' }).setOrigin(0.5);
        const ammoBtn = this.add.rectangle(x + 100, y + 165, 200, 20, 0x444444).setInteractive();
        this.add.text(x + 100, y + 165, "AMMO PRESS (1 SCRAP -> 4 AMMO)", { fontSize: '10px', fill: '#fff' }).setOrigin(0.5);

        this.updateArmoryUI();

        this.armoryBtn.on('pointerdown', () => {
            let armory = this.stats.hideout.armory;
            if (armory.hasNVG) return;
            if (armory.crafting && Date.now() >= armory.crafting.finishTime) {
                sfx.lootWeapon();
                armory.hasNVG = true;
                armory.crafting = null;
                this.updateArmoryUI();
                localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));
                return;
            }
            if (armory.crafting) return;
            if (this.stats.scrap >= 3) {
                sfx.success();
                this.stats.scrap -= 3;
                armory.crafting = { item: 'nvg', finishTime: Date.now() + CONFIG.TIMINGS.NVG_CRAFT };
                this.updateStatText();
                this.updateArmoryUI();
                localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));
            } else {
                sfx.error();
                this.cameras.main.shake(100, 0.005);
            }
        });

        ammoBtn.on('pointerdown', () => {
            if (this.stats.scrap >= 1) {
                sfx.lootAmmo();
                this.stats.scrap -= 1;
                this.stats.ammo += 4;
                this.updateStatText();
                localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));
                this.cameras.main.flash(100, 0, 255, 0);
            } else {
                sfx.error();
            }
        });
    }

    updateArmoryUI() {
        let armory = this.stats.hideout.armory;
        if (armory.hasNVG) {
            this.armoryDesc.setText("NVG UNLOCKED\nPress [N] in game.");
            this.armoryBtnText.setText("EQUIPPED");
            this.armoryTimerText.setText("");
            this.armoryBtn.disableInteractive();
            this.armoryBtn.setFillStyle(0x222222);
        } else if (armory.crafting) {
            this.armoryDesc.setText("Fabricating NVG...");
            this.armoryBtn.disableInteractive();
        } else {
            this.armoryDesc.setText("Craft Night Vision\nCost: 3 Scrap\nTime: 1m 30s");
            this.armoryBtnText.setText("CRAFT (3 SCRAP)");
            this.armoryTimerText.setText("");
            this.armoryBtn.setInteractive();
        }
    }

    getRestEffect() {
        if (this.stats.hideout.restAreaLvl === 0) return "Sleep on floor (No Heal)";
        if (this.stats.hideout.restAreaLvl === 1) return "Mattress (+50% HP)";
        return "Med Bay (+100% HP, +Max HP)";
    }

    updateStatText() {
        // Update the new resource header text
        this.updateResourceText();
    }

    createUpgradeCard(x, y, title, descFn, actionFn, costFn) {
        this.add.rectangle(x + 100, y + 75, 220, 160, 0x333333).setStrokeStyle(2, 0x555555);
        this.add.text(x + 10, y + 10, title, { fontSize: '20px', fill: '#ffff00' });
        const descText = this.add.text(x + 10, y + 40, descFn(), { fontSize: '14px', fill: '#aaa' });
        const btn = this.add.rectangle(x + 100, y + 130, 200, 30, 0x555555).setInteractive();
        const btnText = this.add.text(x + 100, y + 130, costFn(), { fontSize: '14px', fill: '#fff' }).setOrigin(0.5);
        btn.on('pointerdown', () => {
            if (actionFn()) {
                sfx.success();
                descText.setText(descFn());
                btnText.setText(costFn());
                this.cameras.main.flash(100, 0, 255, 0);
            } else {
                sfx.error();
                this.cameras.main.shake(100, 0.005);
                btn.setFillStyle(0xff0000);
                this.time.delayedCall(200, () => btn.setFillStyle(0x555555));
            }
        });
    }
    
    showFloatingText(x, y, msg, color) {
        // Simple floating text for HideoutScene
        const text = this.add.text(x, y, msg, { 
            fontSize: '16px', 
            fill: typeof color === 'string' ? color : '#' + color.toString(16).padStart(6, '0'),
            fontStyle: 'bold',
            stroke: '#000000',
            strokeThickness: 3
        }).setOrigin(0.5).setDepth(600);
        
        this.tweens.add({
            targets: text,
            y: y - 30,
            alpha: 0,
            duration: 1500,
            ease: 'Power2',
            onComplete: () => text.destroy()
        });
    }
}

// =============================================================================
// GAME SCENE
// =============================================================================
class GameScene extends Phaser.Scene {
    constructor() { super('GameScene'); }
    
    preload() {
        // Load leaper animation frames as individual images
        // Idle frames
        this.load.image('leaper_idle_0', 'leaper_idle_0.png');
        this.load.image('leaper_idle_1', 'leaper_idle_1.png');
        // TODO: Add more frames as they become available
        // this.load.image('leaper_idle_2', 'leaper_idle_2.png');
        // this.load.image('leaper_idle_3', 'leaper_idle_3.png');
        // this.load.image('leaper_crawl_0', 'leaper_crawl_0.png');
        // etc...
        
        // Load crate sprite
        this.load.image('crate', 'sprite_crate.png');
        
        const graphics = this.make.graphics({ x: 0, y: 0, add: false });
        
        graphics.fillStyle(0x00ff00, 1); graphics.fillRect(0,0,32,32); graphics.generateTexture('player', 32,32);
        // crate texture loaded from sprite above
        graphics.fillStyle(0x663399, 1); graphics.fillRect(0,0,32,32); graphics.generateTexture('zombie', 32,32);
        // leaper texture loaded from spritesheet above
        graphics.fillStyle(0x0000FF, 1); graphics.fillRect(0,0,32,32); graphics.generateTexture('bandit', 32,32);
        graphics.fillStyle(0x00AA00, 1); graphics.fillRect(0,0,32,32); graphics.generateTexture('spitter', 32,32);
        graphics.fillStyle(0xffff00, 1); graphics.fillRect(0,0,8,8); graphics.generateTexture('bullet', 8,8);
        graphics.fillStyle(0x00ff00, 1); graphics.fillCircle(6,6,6); graphics.generateTexture('acid', 12,12);
        graphics.fillStyle(0x556B2F, 1); graphics.fillCircle(8,8,8); graphics.generateTexture('grenade', 16,16);
        graphics.fillStyle(0xFFD700, 1); graphics.fillRect(0,0,40,60); graphics.generateTexture('door', 40,60);
        graphics.fillStyle(0x555555, 1); graphics.fillRect(0,0,32,32); graphics.generateTexture('wall', 32,32);
        graphics.fillStyle(0xffffff, 1); graphics.fillRect(0,0,40,40); graphics.generateTexture('slash', 40,40);
        graphics.fillStyle(0x2d5a27, 1); graphics.fillRect(0,0,32,32); graphics.generateTexture('floor_grass', 32,32);
        graphics.clear(); graphics.fillStyle(0x444444, 1); graphics.fillRect(0,0,32,32); graphics.generateTexture('floor_apt', 32,32);
        graphics.clear(); graphics.fillStyle(0x1a1a2e, 1); graphics.fillRect(0,0,32,32); graphics.generateTexture('floor_roof', 32,32);
        graphics.clear(); graphics.fillStyle(0x2a3a2a, 1); graphics.fillRect(0,0,32,32); graphics.generateTexture('floor_sewer', 32,32);
        graphics.clear(); graphics.fillStyle(0xddeedd, 1); graphics.fillRect(0,0,32,32); graphics.generateTexture('floor_hospital', 32,32);
        graphics.clear(); graphics.fillStyle(0xff0000, 1); graphics.fillRect(0,0,20,20); graphics.generateTexture('pickup_hp', 20,20);
        graphics.clear(); graphics.fillStyle(0x0088ff, 1); graphics.fillRect(0,0,20,20); graphics.generateTexture('pickup_stamina', 20,20);
        graphics.clear(); graphics.fillStyle(0x333333, 1); graphics.fillRect(0,0,60,60); graphics.generateTexture('debris', 60,60);
        graphics.clear(); graphics.fillStyle(0x00ff00, 1); graphics.fillRect(0,0,30,30); graphics.generateTexture('switch', 30,30);
        
        // Skull art
        graphics.clear();
        graphics.lineStyle(2, 0x000000, 1);
        graphics.fillStyle(0xEAEAEA, 1);
        graphics.fillCircle(16, 14, 11); graphics.strokeCircle(16, 14, 11);
        graphics.fillRect(10, 20, 12, 8); graphics.strokeRect(10, 20, 12, 8);
        graphics.fillStyle(0x000000, 1);
        graphics.fillCircle(12, 14, 3.5); graphics.fillCircle(20, 14, 3.5);
        graphics.beginPath(); graphics.moveTo(16, 18); graphics.lineTo(14, 21); graphics.lineTo(18, 21); graphics.closePath(); graphics.fill();
        graphics.lineStyle(1, 0x000000);
        graphics.beginPath(); graphics.moveTo(13, 20); graphics.lineTo(13, 28); graphics.moveTo(16, 20); graphics.lineTo(16, 28); graphics.moveTo(19, 20); graphics.lineTo(19, 28); graphics.strokePath();
        graphics.generateTexture('skull', 32, 32);
    }
    
    create(data = {}) {
        // Create leaper animations from individual images (only if not already created)
        if (!this.anims.exists('leaper_idle')) {
            // Idle animation (using available frames)
            this.anims.create({
                key: 'leaper_idle',
                frames: [
                    { key: 'leaper_idle_0' },
                    { key: 'leaper_idle_1' }
                    // Add more frames here as they become available
                ],
                frameRate: 6,
                repeat: -1
            });
            
            // For now, use idle for all states until more frames are added
            // These will be updated once all frames are available
            this.anims.create({
                key: 'leaper_crawl',
                frames: [
                    { key: 'leaper_idle_0' },
                    { key: 'leaper_idle_1' }
                ],
                frameRate: 8,
                repeat: -1
            });
            this.anims.create({
                key: 'leaper_attack',
                frames: [
                    { key: 'leaper_idle_0' },
                    { key: 'leaper_idle_1' }
                ],
                frameRate: 10,
                repeat: 0
            });
            this.anims.create({
                key: 'leaper_death',
                frames: [
                    { key: 'leaper_idle_1' },
                    { key: 'leaper_idle_0' }
                ],
                frameRate: 4,
                repeat: 0
            });
        }
        
        // Clean up any lingering handlers from previous scene
        if (this.levelChoiceEnterHandler) {
            this.input.keyboard.off('keydown-ENTER', this.levelChoiceEnterHandler);
            this.levelChoiceEnterHandler = null;
        }
        if (this.levelChoiceEscHandler) {
            this.input.keyboard.off('keydown-ESC', this.levelChoiceEscHandler);
            this.levelChoiceEscHandler = null;
        }
        this.levelChoiceMade = false;
        this.consumableSlotTexts = null;
        
        this.currentLevel = data.level || 1;
        this.playerStats = data.stats ? JSON.parse(JSON.stringify(data.stats)) : JSON.parse(JSON.stringify(DEFAULT_STATS));
        // Ensure magazines exist
        if (!this.playerStats.magazines) {
            this.playerStats.magazines = {
                pistol: CONFIG.WEAPONS.PISTOL.MAG_SIZE,
                shotgun: CONFIG.WEAPONS.SHOTGUN.MAG_SIZE,
                smg: CONFIG.WEAPONS.SMG.MAG_SIZE,
                crossbow: CONFIG.WEAPONS.CROSSBOW.MAG_SIZE,
                rifle: CONFIG.WEAPONS.RIFLE.MAG_SIZE
            };
        }
        // Ensure new weapon magazines exist
        if (this.playerStats.magazines.crossbow === undefined) this.playerStats.magazines.crossbow = CONFIG.WEAPONS.CROSSBOW.MAG_SIZE;
        if (this.playerStats.magazines.rifle === undefined) this.playerStats.magazines.rifle = CONFIG.WEAPONS.RIFLE.MAG_SIZE;
        // Ensure new weapon flags exist
        if (this.playerStats.hasCrossbow === undefined) this.playerStats.hasCrossbow = false;
        if (this.playerStats.hasRifle === undefined) this.playerStats.hasRifle = false;
        // Ensure grenades exist for old saves
        if (this.playerStats.grenades === undefined) {
            this.playerStats.grenades = 0;
        }
        // Ensure new currency fields exist
        if (this.playerStats.credits === undefined) {
            this.playerStats.credits = 0;
        }
        if (this.playerStats.materials === undefined) {
            this.playerStats.materials = 0;
        }
        // Ensure consumables is a valid array (handle null, undefined, or corrupted data)
        if (!this.playerStats.consumables || !Array.isArray(this.playerStats.consumables)) {
            this.playerStats.consumables = [null, null, null];
        }
        // Ensure consumables array has exactly 3 slots
        while (this.playerStats.consumables.length < 3) {
            this.playerStats.consumables.push(null);
        }
        // Ensure equippedMods exists for weapon mods system
        if (!this.playerStats.equippedMods) {
            this.playerStats.equippedMods = {
                pistol: [null, null],
                shotgun: [null, null],
                smg: [null, null],
                crossbow: [null, null],
                rifle: [null, null]
            };
        }
        // Ensure highestLevelUnlocked exists
        if (this.playerStats.highestLevelUnlocked === undefined) {
            this.playerStats.highestLevelUnlocked = this.playerStats.nextLevel || 1;
        }
        this.checkpointStats = JSON.parse(JSON.stringify(this.playerStats));

        // State flags
        this.hasKey = false;
        this.hasMolotov = false;
        this.isOpening = false;
        this.isPaused = false;
        this.isPinned = false;
        this.pinnedBy = null;
        this.isMeleeAttacking = false;
        this.debrisBurning = false;
        this.lastFired = 0;
        this.switchDropped = false;
        this.extractionTimer = 15;
        this.extractionActive = false;
        this.isInventoryOpen = false;
        this.nvgOn = false;
        this.baseSpeedMultiplier = 1; // Base speed (modified by class)
        this.speedMultiplier = 1; // For adrenaline consumable
        this.silentFootsteps = false; // Scout class passive
        
        // Persistent stats tracking
        this.persistent = loadPersistent();
        
        // Ensure challenges are initialized (in case player skipped Hideout)
        if (checkChallengeReset(this.persistent)) {
            savePersistent(this.persistent);
        }
        
        if (this.currentLevel === 1) {
            // New run - reset run stats and increment runs started
            this.persistent = resetRunStats(this.persistent);
            this.persistent.runsStarted++;
            this.levelDamageTaken = 0; // Track damage for untouchable achievement
        }
        this.levelDamageTaken = this.levelDamageTaken || 0;
        
        // Track level start time for speed run challenge
        this.levelStartTime = Date.now();
        
        // Apply class passives
        if (this.persistent.selectedClass === 'scout') {
            this.baseSpeedMultiplier = 1.2; // +20% movement speed
            this.speedMultiplier = this.baseSpeedMultiplier;
            this.silentFootsteps = true;
        } else if (this.persistent.selectedClass === 'medic') {
            // Medic: Regenerate 1 HP every 30 seconds
            this.medicRegenEvent = this.time.addEvent({
                delay: 30000,
                callback: () => {
                    if (this.playerStats.hp < this.playerStats.maxHp && this.player && this.player.active) {
                        this.playerStats.hp = Math.min(this.playerStats.hp + 1, this.playerStats.maxHp);
                        this.showFloatingText(this.player.x, this.player.y - 40, "+1 HP (Medic)", 0x00ff00);
                        sfx.heal();
                    }
                },
                loop: true
            });
        }
        
        // Apply permanent upgrades
        if (this.persistent.unlockedUpgrades?.includes('speed_boost')) {
            this.baseSpeedMultiplier *= 1.05; // +5% speed, stacks with Scout
            this.speedMultiplier = this.baseSpeedMultiplier;
        }
        this.permanentDamageBoost = this.persistent.unlockedUpgrades?.includes('damage_boost') ? 1.1 : 1.0;
        
        // Apply cosmetics - skin tint (will apply after player is created)
        this.equippedSkinTint = null;
        if (this.persistent.equippedSkin) {
            const skinUpgrade = Object.values(CONFIG.UPGRADES).find(u => u.id === this.persistent.equippedSkin);
            if (skinUpgrade?.tint) this.equippedSkinTint = skinUpgrade.tint;
        }
        
        // Apply cosmetics - muzzle flash color
        this.muzzleFlashColor = 0xffff00; // Default yellow
        if (this.persistent.equippedMuzzle) {
            const muzzleUpgrade = Object.values(CONFIG.UPGRADES).find(u => u.id === this.persistent.equippedMuzzle);
            if (muzzleUpgrade?.color) this.muzzleFlashColor = muzzleUpgrade.color;
        }
        
        // ===== APPLY SKILL EFFECTS =====
        // Calculate damage reduction from skills (Thick Skin + Iron Will)
        this.skillDamageReduction = 0;
        if (this.hasSkill('thick_skin')) this.skillDamageReduction += 0.1;
        if (this.hasSkill('iron_will')) this.skillDamageReduction += 0.2;
        
        // Last Stand: +50% damage when below 25% HP
        this.lastStandBonus = this.hasSkill('last_stand') ? 0.5 : 0;
        this.lastStandThreshold = 0.25;
        
        // Regeneration skill: Heal 1 HP every 60 seconds (stacks with Medic class)
        if (this.hasSkill('regeneration')) {
            this.skillRegenEvent = this.time.addEvent({
                delay: 60000,
                callback: () => {
                    if (this.playerStats.hp < this.playerStats.maxHp && this.player && this.player.active) {
                        this.playerStats.hp = Math.min(this.playerStats.hp + 1, this.playerStats.maxHp);
                        this.showFloatingText(this.player.x, this.player.y - 40, "+1 HP (Regen)", 0x88ff88);
                        sfx.lootHealth();
                    }
                },
                loop: true
            });
        }
        
        // Light Feet: Reduced footstep volume (handled in footstep calls)
        this.lightFeetVolume = this.hasSkill('light_feet') ? 0.3 : 1.0;
        
        // Ghost: Faster detection decay (handled in stealth mechanics)
        this.ghostDecayMultiplier = this.hasSkill('ghost') ? 2.0 : 1.0;
        
        // Shadow Step: Reduced enemy detection range
        this.shadowStepReduction = this.hasSkill('shadow_step') ? 0.25 : 0;
        
        // Swift Reload: -15% reload time
        this.swiftReloadBonus = this.hasSkill('swift_reload') ? 0.15 : 0;
        
        // Quick Hands: +25% interact speed
        this.quickHandsBonus = this.hasSkill('quick_hands') ? 0.25 : 0;
        
        // Scrapper: +25% scrap bonus
        this.scrapperBonus = this.hasSkill('scrapper') ? 0.25 : 0;
        
        // Pack Mule: +1 consumable slot (handled at stats level)
        if (this.hasSkill('pack_mule')) {
            // Ensure 4 consumable slots
            while (this.playerStats.consumables.length < 4) {
                this.playerStats.consumables.push(null);
            }
        }
        
        // Calculate weapon mod effects for each weapon
        this.weaponModEffects = {};
        const weapons = ['pistol', 'shotgun', 'smg', 'crossbow', 'rifle'];
        weapons.forEach(weapon => {
            this.weaponModEffects[weapon] = {
                magSizeMultiplier: 1,
                damageMultiplier: 1,
                fireRateMultiplier: 1,
                spreadMultiplier: 1,
                isSilent: false,
                hasLaser: false
            };
            
            const equippedMods = this.playerStats.equippedMods?.[weapon] || [null, null];
            equippedMods.forEach(modId => {
                if (!modId) return;
                const mod = Object.values(CONFIG.MODS).find(m => m.id === modId);
                if (!mod) return;
                
                const effect = mod.effect;
                switch (effect.type) {
                    case 'mag_size':
                        this.weaponModEffects[weapon].magSizeMultiplier += effect.value;
                        break;
                    case 'suppressor':
                        this.weaponModEffects[weapon].isSilent = true;
                        this.weaponModEffects[weapon].damageMultiplier -= effect.damageReduction;
                        break;
                    case 'laser_sight':
                        this.weaponModEffects[weapon].hasLaser = true;
                        break;
                    case 'damage_barrel':
                        this.weaponModEffects[weapon].damageMultiplier += effect.damage;
                        this.weaponModEffects[weapon].fireRateMultiplier += effect.fireRate; // negative
                        break;
                    case 'rapid_fire':
                        this.weaponModEffects[weapon].fireRateMultiplier += effect.fireRate;
                        this.weaponModEffects[weapon].spreadMultiplier += effect.spread;
                        break;
                }
            });
        });
        
        // Apply extended mag effect to initial magazine sizes
        weapons.forEach(weapon => {
            const magMod = this.weaponModEffects[weapon].magSizeMultiplier;
            if (magMod > 1) {
                const baseSize = CONFIG.WEAPONS[weapon.toUpperCase()].MAG_SIZE;
                const newSize = Math.floor(baseSize * magMod);
                // If magazine is full, extend it; otherwise keep current
                if (this.playerStats.magazines[weapon] === baseSize) {
                    this.playerStats.magazines[weapon] = newSize;
                }
            }
        });
        
        this.grenadeKillCount = 0; // For tracking multi-kills
        
        // Dodge roll state
        this.isDodging = false;
        this.dodgeCooldown = 0;
        this.lastDodgeTime = 0;
        
        // Reload state
        this.isReloading = false;
        this.reloadTimer = null;
        
        // Transition state - prevents updates during level change
        this.isTransitioning = false;
        
        // Track active timer events for cleanup
        this.activeTimerEvents = [];

        // Groups
        this.bullets = this.physics.add.group({ classType: Bullet, runChildUpdate: true, maxSize: 50 });
        this.acidProjectiles = this.physics.add.group({ runChildUpdate: true, maxSize: 20 });
        this.grenades = this.physics.add.group({ runChildUpdate: true, maxSize: 10 });
        this.enemies = this.add.group();
        this.pickups = this.physics.add.staticGroup();
        this.crates = this.physics.add.staticGroup();
        this.skulls = this.physics.add.staticGroup();
        this.walls = this.physics.add.staticGroup();
        this.debris = this.physics.add.staticGroup();
        this.switches = this.physics.add.staticGroup();

        // Floating text, particle, and hit indicator pools
        this.floatingText = new FloatingTextPool(this, 20);
        this.particles = new ParticlePool(this, 30);
        this.hitIndicators = new HitIndicatorPool(this, 8);
        
        // Load settings
        this.gameSettings = loadSettings();

        // UI elements needed by spawnLevelEntities (must be created before)
        this.uiGraphics = this.add.graphics().setDepth(100);
        this.uiText = this.add.text(10, 65, '', { font: '16px Arial', fill: '#fff' }).setDepth(100);
        this.bossBar = this.add.graphics().setDepth(150).setVisible(false);
        
        // Laser sight graphics (for weapon mod)
        this.laserGraphics = this.add.graphics().setDepth(50);
        this.bossText = this.add.text(400, 25, "BOSS", { fontSize: '20px', fill: '#fff' }).setOrigin(0.5).setDepth(200).setVisible(false);

        // Initialize room system variables
        this.roomGrid = null;
        this.roomWalls = [];
        this.roomDoors = [];
        this.roomFloor = null;
        this.roomOverlay = null;
        this.riskDoor = null;
        this.riskDoorIcon = null;
        this.inRiskRoom = false;
        this.isTransitioningRoom = false; // Prevent transition re-entry
        this.keySpawned = false; // Reset key tracking for new level
        this.mapSpawned = false; // Reset map tracking for new level
        this.hasMap = false;     // Map pickup is per-level only
        
        // Generate procedural room grid
        this.roomGrid = this.generateRoomGrid(this.currentLevel);
        
        if (this.roomGrid) {
            // Create minimap
            this.createMinimap();
            
            // Setup first room
            const startRoom = this.roomGrid.rooms[this.roomGrid.startRoom];
            this.setupRoom(startRoom);
        } else {
            // Fallback to legacy single-room system
            this.setupMapForLevel(this.currentLevel);
        }
        
        this.player = this.physics.add.sprite(400, 550, 'player').setCollideWorldBounds(true).setDepth(10);
        // Apply equipped skin tint
        if (this.equippedSkinTint) {
            this.player.setTint(this.equippedSkinTint);
        }
        
        if (this.roomGrid) {
            // Spawn entities for first room
            const startRoom = this.roomGrid.rooms[this.roomGrid.startRoom];
            this.spawnRoomEntities(startRoom, false);
        } else {
            // Fallback to legacy spawning
            this.spawnLevelEntities(this.currentLevel);
        }

        // Colliders
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.player, this.crates);
        this.physics.add.collider(this.player, this.debris);
        this.physics.add.collider(this.enemies, this.walls);
        this.physics.add.collider(this.enemies, this.crates);
        this.physics.add.collider(this.bullets, this.walls, (b) => { b.setActive(false); b.setVisible(false); b.body.enable = false; });
        this.physics.add.collider(this.bullets, this.crates, (b) => { b.setActive(false); b.setVisible(false); b.body.enable = false; });
        this.physics.add.collider(this.bullets, this.debris, (b) => { b.setActive(false); b.setVisible(false); b.body.enable = false; });

        // Overlaps
        this.physics.add.overlap(this.bullets, this.enemies, (obj1, obj2) => {
            const bullet = (obj1.texture.key === 'bullet') ? obj1 : obj2;
            const enemy = (obj1.texture.key === 'bullet') ? obj2 : obj1;
            if (bullet.active && enemy.active) {
                if (bullet.isEnemyBullet) return;
                
                // Track which enemies this bullet has hit (for piercing)
                if (!bullet.hitEnemies) bullet.hitEnemies = new Set();
                if (bullet.hitEnemies.has(enemy)) return; // Already hit this enemy
                bullet.hitEnemies.add(enemy);
                
                // Piercing bullets can hit multiple enemies but have a limit
                if (bullet.isPiercing) {
                    if (!bullet.pierceCount) bullet.pierceCount = 0;
                    bullet.pierceCount++;
                    if (bullet.pierceCount > 2) { // Pierce through 2 enemies max
                        bullet.setActive(false);
                        bullet.setVisible(false);
                        bullet.body.enable = false;
                    }
                } else {
                    // Non-piercing bullets stop on first hit
                    bullet.hasHit = true;
                    bullet.setActive(false);
                    bullet.setVisible(false);
                    bullet.body.enable = false;
                }
                
                // Track hit stats
                this.persistent.runShotsHit++;
                this.persistent.totalShotsHit++;
                // Track if boss was hit with gun (for melee master achievement)
                if (enemy.enemyType === 'boss') {
                    this.persistent.bossHitWithGun = true;
                }
                
                // Calculate damage based on weapon type
                let damage = 1;
                let weaponSource = 'gun'; // Default
                if (bullet.crossbowDamage) {
                    damage = bullet.crossbowDamage; // Crossbow high damage
                    weaponSource = 'crossbow';
                } else if (bullet.rifleDamage) {
                    damage = bullet.rifleDamage; // Rifle medium damage
                    weaponSource = 'rifle';
                }
                
                // Apply weapon mod damage multiplier
                if (bullet.modDamageMultiplier && bullet.modDamageMultiplier !== 1) {
                    damage = Math.ceil(damage * bullet.modDamageMultiplier);
                }
                
                // Apply workbench damage bonus
                if (this.playerStats.hideout.workbenchLvl > 0) {
                    damage = Math.ceil(damage * (1 + CONFIG.HIDEOUT.WORKBENCH_DAMAGE_BONUS));
                }
                // Apply permanent damage boost upgrade
                if (this.permanentDamageBoost > 1) {
                    damage = Math.ceil(damage * this.permanentDamageBoost);
                }
                // Apply Last Stand skill (+50% damage when below 25% HP)
                if (this.lastStandBonus > 0 && this.playerStats.hp / this.playerStats.maxHp <= this.lastStandThreshold) {
                    damage = Math.ceil(damage * (1 + this.lastStandBonus));
                }
                if (typeof enemy.takeDamage === 'function') enemy.takeDamage(damage, weaponSource);
            }
        });

        this.physics.add.overlap(this.bullets, this.player, (player, bullet) => {
            if (bullet.active && !bullet.hasHit) {
                if (!bullet.isEnemyBullet) return;
                // Dodge roll grants invincibility
                if (this.isDodging) return;
                bullet.hasHit = true;
                const bx = bullet.x, by = bullet.y;
                bullet.setActive(false);
                bullet.setVisible(false);
                bullet.body.enable = false;
                this.hitPlayer(1, bx, by);
            }
        });

        // Acid projectile hits player
        this.physics.add.overlap(this.acidProjectiles, this.player, (player, acid) => {
            if (acid.active && !acid.hasHit) {
                if (this.isDodging) return;
                acid.hasHit = true;
                const ax = acid.x, ay = acid.y;
                acid.setActive(false);
                acid.setVisible(false);
                acid.body.enable = false;
                this.hitPlayer(CONFIG.ENEMIES.SPITTER.DAMAGE, ax, ay);
                this.showFloatingText(this.player.x, this.player.y - 30, "ACID!", 0x00ff00);
            }
        });

        // Acid hits walls
        this.physics.add.collider(this.acidProjectiles, this.walls, (acid) => { 
            acid.setActive(false); acid.setVisible(false); acid.body.enable = false; 
        });
        this.physics.add.collider(this.acidProjectiles, this.crates, (acid) => { 
            acid.setActive(false); acid.setVisible(false); acid.body.enable = false; 
        });

        this.physics.add.overlap(this.player, this.enemies, (p, e) => {
            if (!e.active) return;
            // Dodge roll grants invincibility
            if (this.isDodging) return;
            if (e.enemyType === 'leaper' && e.state === 'LEAP') this.triggerKnockdown(e);
            else if (e.enemyType === 'bandit' && e.ammo > 0) return;
            else this.hitPlayer(e.damage, e.x, e.y);
        });

        this.physics.add.overlap(this.player, this.pickups, (p, item) => {
            this.applyLoot(item.getData('type'));
            item.destroy();
        });

        // Input
        this.cursors = this.input.keyboard.createCursorKeys();
        this.wasd = this.input.keyboard.addKeys('W,A,S,D,SHIFT');
        this.keys = this.input.keyboard.addKeys({
            interact: Phaser.Input.Keyboard.KeyCodes.F,
            space: Phaser.Input.Keyboard.KeyCodes.SPACE,
            esc: Phaser.Input.Keyboard.KeyCodes.ESC,
            melee: Phaser.Input.Keyboard.KeyCodes.E,
            switch: Phaser.Input.Keyboard.KeyCodes.Q,
            inv: Phaser.Input.Keyboard.KeyCodes.I,
            tab: Phaser.Input.Keyboard.KeyCodes.TAB,
            nvg: Phaser.Input.Keyboard.KeyCodes.N,
            reload: Phaser.Input.Keyboard.KeyCodes.R,
            grenade: Phaser.Input.Keyboard.KeyCodes.G,
            consumable1: Phaser.Input.Keyboard.KeyCodes.ONE,
            consumable2: Phaser.Input.Keyboard.KeyCodes.TWO,
            consumable3: Phaser.Input.Keyboard.KeyCodes.THREE,
            laser: Phaser.Input.Keyboard.KeyCodes.L
        });
        
        // Laser sight toggle (default on)
        this.laserEnabled = true;
        this.input.on('pointerdown', (p) => this.fireBullet(p));
        
        // Mouse wheel for weapon switching
        this.input.on('wheel', (pointer, gameObjects, deltaX, deltaY) => {
            if (this.isPaused || this.isInventoryOpen) return;
            if (deltaY > 0) this.switchWeapon(1);  // Scroll down = next weapon
            else if (deltaY < 0) this.switchWeapon(-1); // Scroll up = previous weapon
        });

        // Level text (UI elements like uiGraphics, bossBar already created above)
        this.levelText = this.add.text(400, 300, `LEVEL ${this.currentLevel}`, { fontSize: '64px', fill: '#fff' }).setOrigin(0.5).setDepth(200);
        this.tweens.add({ targets: this.levelText, alpha: 0, duration: 2000, delay: 1000 });
        
        // Play level start sound
        sfx.levelStart();

        this.createInventoryUI();
        this.pauseText = this.add.text(400, 300, 'PAUSED', { fontSize: '48px', fill: '#fff' }).setOrigin(0.5).setDepth(200).setVisible(false);

        // Lighting & NVG
        this.lightShape = this.make.graphics({ x: 0, y: 0, add: false });
        const mask = this.lightShape.createGeometryMask();
        mask.setInvertAlpha(true);
        this.darkness = this.add.rectangle(400, 300, 800, 600, 0x000000, 0.95).setDepth(90);
        this.darkness.setMask(mask);
        this.nvgLayer = this.add.rectangle(400, 300, 800, 600, 0x00ff00, 0.2).setDepth(95).setVisible(false);
        
        // Low HP Vignette - red edges when health is low
        this.vignetteGraphics = this.add.graphics().setDepth(105);
        
        // Scene shutdown cleanup
        this.events.on('shutdown', this.shutdown, this);
    }
    
    shutdown() {
        // Clean up graphics objects to prevent errors during transition
        if (this.lightShape) {
            this.lightShape.destroy();
            this.lightShape = null;
        }
        if (this.vignetteGraphics) {
            this.vignetteGraphics.destroy();
            this.vignetteGraphics = null;
        }
        if (this.uiGraphics) {
            this.uiGraphics.destroy();
            this.uiGraphics = null;
        }
        this.events.off('shutdown', this.shutdown, this);
    }

    // ==================== SKILL HELPER ====================
    hasSkill(skillId) {
        return this.persistent?.unlockedSkills?.includes(skillId) || false;
    }
    
    // Update challenge progress for daily/weekly challenges based on current run
    updateChallengeProgress() {
        if (!this.persistent.activeDailies) this.persistent.activeDailies = [];
        if (!this.persistent.activeWeeklies) this.persistent.activeWeeklies = [];
        
        // Update daily challenges based on run stats
        this.persistent.activeDailies.forEach(challenge => {
            const config = CONFIG.CHALLENGES.DAILY.find(c => c.id === challenge.id);
            if (!config || challenge.claimed) return;
            
            switch (config.stat) {
                case 'runMeleeKills':
                    challenge.progress = this.persistent.runMeleeKills || 0;
                    break;
                case 'runKills':
                    challenge.progress = this.persistent.runKills || 0;
                    break;
                case 'levelNoDamage':
                    if (this.levelDamageTaken === 0) challenge.progress = 1;
                    break;
                case 'highAccuracy':
                    if (this.persistent.runShotsFired >= 20) {
                        const acc = this.persistent.runShotsHit / this.persistent.runShotsFired;
                        if (acc >= 0.6) challenge.progress = 1;
                    }
                    break;
                case 'runGrenadeKills':
                    challenge.progress = this.persistent.runGrenadeKills || 0;
                    break;
                case 'runScrapCollected':
                    challenge.progress = this.persistent.runScrapCollected || 0;
                    break;
                case 'speedRun':
                    const levelTime = Date.now() - (this.levelStartTime || Date.now());
                    if (levelTime < 120000) challenge.progress = 1; // Under 2 minutes
                    break;
                case 'pistolOnly':
                    // Check if only pistol was used (no other weapons acquired/switched)
                    if (!this.playerStats.hasShotgun && !this.playerStats.hasSMG && 
                        !this.playerStats.hasCrossbow && !this.playerStats.hasRifle) {
                        challenge.progress = 1;
                    }
                    break;
            }
            // Cap progress at target
            challenge.progress = Math.min(challenge.progress, config.target);
        });
        
        // Update weekly challenges based on weekly stats
        this.persistent.activeWeeklies.forEach(challenge => {
            const config = CONFIG.CHALLENGES.WEEKLY.find(c => c.id === challenge.id);
            if (!config || challenge.claimed) return;
            
            switch (config.stat) {
                case 'weeklyKills':
                    challenge.progress = this.persistent.weeklyKills || 0;
                    break;
                case 'weeklyExtractions':
                    challenge.progress = this.persistent.weeklyExtractions || 0;
                    break;
                case 'weeklyBossKills':
                    challenge.progress = this.persistent.weeklyBossKills || 0;
                    break;
                case 'weeklyScrap':
                    challenge.progress = this.persistent.weeklyScrap || 0;
                    break;
                case 'weeklyUniqueLevels':
                    challenge.progress = (this.persistent.weeklyUniqueLevels || []).length;
                    break;
            }
            // Cap progress at target
            challenge.progress = Math.min(challenge.progress, config.target);
        });
    }
    
    // Calculate skill points earned from a run based on performance
    calculateRunSkillPoints() {
        let points = 1; // Base: 1 point per extraction
        
        // Bonus: +1 for no damage taken this level
        if (this.levelDamageTaken === 0) {
            points += 1;
        }
        
        // Bonus: +1 for boss killed this run (levels 5 and 7 have bosses)
        if (this.currentLevel === 5 || this.currentLevel === 7) {
            points += 1;
        }
        
        // Bonus: +1 for 50%+ accuracy (min 10 shots)
        if (this.persistent.runShotsFired >= 10) {
            const accuracy = this.persistent.runShotsHit / this.persistent.runShotsFired;
            if (accuracy >= 0.5) {
                points += 1;
            }
        }
        
        return points;
    }

    // ==================== DODGE ROLL ====================
    performDodgeRoll() {
        const now = this.time.now;
        const cfg = CONFIG.PLAYER;
        
        // Check cooldown and stamina
        if (now - this.lastDodgeTime < cfg.DODGE_COOLDOWN) return;
        if (this.playerStats.stamina < cfg.DODGE_STAMINA_COST) {
            this.showFloatingText(this.player.x, this.player.y - 40, "NO STAMINA!", 0xff0000);
            return;
        }
        if (this.isDodging || this.isPinned || this.isReloading) return;
        
        // Get movement direction or face direction
        let vx = 0, vy = 0;
        if (this.cursors.left.isDown || this.wasd.A.isDown) vx = -1;
        else if (this.cursors.right.isDown || this.wasd.D.isDown) vx = 1;
        if (this.cursors.up.isDown || this.wasd.W.isDown) vy = -1;
        else if (this.cursors.down.isDown || this.wasd.S.isDown) vy = 1;
        
        // If not moving, dodge toward mouse
        if (vx === 0 && vy === 0) {
            const angle = Phaser.Math.Angle.Between(
                this.player.x, this.player.y,
                this.input.activePointer.x, this.input.activePointer.y
            );
            vx = Math.cos(angle);
            vy = Math.sin(angle);
        } else {
            // Normalize
            const len = Math.sqrt(vx * vx + vy * vy);
            vx /= len;
            vy /= len;
        }
        
        // Consume stamina
        this.playerStats.stamina -= cfg.DODGE_STAMINA_COST;
        this.isDodging = true;
        this.lastDodgeTime = now;
        
        // Visual feedback
        sfx.dodge();
        this.player.setAlpha(0.5);
        this.player.setTint(0x00ffff);
        
        // Apply velocity
        this.player.setVelocity(vx * cfg.DODGE_SPEED, vy * cfg.DODGE_SPEED);
        
        // End dodge after duration
        this.time.delayedCall(cfg.DODGE_DURATION, () => {
            this.isDodging = false;
            this.player.setAlpha(1);
            this.player.clearTint();
        });
    }

    // ==================== RELOAD SYSTEM ====================
    startReload() {
        if (this.isReloading) return;
        
        const weapon = this.playerStats.currentWeapon;
        const wpnConfig = CONFIG.WEAPONS[weapon.toUpperCase()];
        const currentMag = this.playerStats.magazines[weapon];
        
        // Calculate effective magazine size with mods
        const modEffects = this.weaponModEffects?.[weapon] || { magSizeMultiplier: 1 };
        const effectiveMagSize = Math.floor(wpnConfig.MAG_SIZE * modEffects.magSizeMultiplier);
        
        // Already full
        if (currentMag >= effectiveMagSize) {
            this.showFloatingText(this.player.x, this.player.y - 40, "MAG FULL", 0xffff00);
            return;
        }
        
        // No reserve ammo
        if (this.playerStats.ammo <= 0) {
            this.showFloatingText(this.player.x, this.player.y - 40, "NO AMMO!", 0xff0000);
            return;
        }
        
        this.isReloading = true;
        sfx.reload();
        this.showFloatingText(this.player.x, this.player.y - 40, "RELOADING...", 0xffff00);
        
        // Apply Swift Reload skill (-15% reload time)
        const reloadTime = Math.floor(wpnConfig.RELOAD_TIME * (1 - (this.swiftReloadBonus || 0)));
        
        this.reloadTimer = this.time.delayedCall(reloadTime, () => {
            const needed = effectiveMagSize - this.playerStats.magazines[weapon];
            const toLoad = Math.min(needed, this.playerStats.ammo);
            
            this.playerStats.magazines[weapon] += toLoad;
            this.playerStats.ammo -= toLoad;
            
            this.isReloading = false;
            this.reloadTimer = null;
            sfx.reloadFinish();
            this.showFloatingText(this.player.x, this.player.y - 40, "RELOADED!", 0x00ff00);
        });
    }
    
    cancelReload() {
        if (this.reloadTimer) {
            this.reloadTimer.remove();
            this.reloadTimer = null;
        }
        this.isReloading = false;
    }

    // ==================== LOW HP VIGNETTE ====================
    drawVignette() {
        if (!this.vignetteGraphics) return;
        this.vignetteGraphics.clear();
        
        const hpPercent = this.playerStats.hp / this.playerStats.maxHp;
        if (hpPercent > CONFIG.PLAYER.LOW_HP_THRESHOLD) return;
        
        // Intensity increases as HP decreases
        const intensity = 1 - (hpPercent / CONFIG.PLAYER.LOW_HP_THRESHOLD);
        const alpha = 0.3 + intensity * 0.4; // 0.3 to 0.7
        
        // Pulsing effect when very low
        let pulseAlpha = alpha;
        if (hpPercent < 0.15) {
            const pulse = Math.sin(this.time.now / 200) * 0.15;
            pulseAlpha = alpha + pulse;
        }
        
        // Draw red gradient from edges
        const thickness = 60 + intensity * 40; // 60-100px thick
        
        // Top edge
        this.vignetteGraphics.fillGradientStyle(0xff0000, 0xff0000, 0xff0000, 0xff0000, pulseAlpha, pulseAlpha, 0, 0);
        this.vignetteGraphics.fillRect(0, 0, 800, thickness);
        
        // Bottom edge
        this.vignetteGraphics.fillGradientStyle(0xff0000, 0xff0000, 0xff0000, 0xff0000, 0, 0, pulseAlpha, pulseAlpha);
        this.vignetteGraphics.fillRect(0, 600 - thickness, 800, thickness);
        
        // Left edge
        this.vignetteGraphics.fillGradientStyle(0xff0000, 0xff0000, 0xff0000, 0xff0000, pulseAlpha, 0, 0, pulseAlpha);
        this.vignetteGraphics.fillRect(0, 0, thickness, 600);
        
        // Right edge
        this.vignetteGraphics.fillGradientStyle(0xff0000, 0xff0000, 0xff0000, 0xff0000, 0, pulseAlpha, pulseAlpha, 0);
        this.vignetteGraphics.fillRect(800 - thickness, 0, thickness, 600);
    }

    spawnLootSkull(x, y, enemyType, killSource = 'gun') {
        // Track kill stats
        this.persistent.runKills++;
        this.persistent.totalKills++;
        
        // Challenge tracking - weekly kills
        this.persistent.weeklyKills = (this.persistent.weeklyKills || 0) + 1;
        
        if (killSource === 'melee') {
            this.persistent.meleeKills++;
            this.persistent.runMeleeKills++;
        } else if (killSource === 'grenade') {
            this.persistent.totalGrenadeKills++;
            this.persistent.runGrenadeKills++;
        } else if (killSource === 'crossbow') {
            // Track crossbow kills for permanent challenge
            this.persistent.crossbowKills = (this.persistent.crossbowKills || 0) + 1;
        }
        
        if (enemyType === 'boss') {
            this.persistent.bossesKilled++;
            // Challenge tracking - weekly boss kills
            this.persistent.weeklyBossKills = (this.persistent.weeklyBossKills || 0) + 1;
        }
        
        // Check achievements after kill
        const newAchievements = checkAchievements(this.persistent, {
            hasAllWeapons: this.playerStats.hasShotgun && this.playerStats.hasSMG
        });
        newAchievements.forEach(a => {
            sfx.achievement();
            this.showFloatingText(400, 200, `${a.icon} ${a.name}!`, 0xffd700);
        });
        
        // NEW: Auto-collect currency based on enemy type
        const dropConfig = CONFIG.ENEMY_DROPS[enemyType.toUpperCase()];
        if (dropConfig) {
            let amount = Phaser.Math.Between(dropConfig.min, dropConfig.max);
            // Scavenger class: +50% loot drops
            if (this.persistent.selectedClass === 'scavenger') {
                amount = Math.floor(amount * 1.5);
            }
            const currency = dropConfig.currency;
            
            // Scrapper skill: +25% scrap bonus
            if (currency === 'scrap' && this.scrapperBonus > 0) {
                amount = Math.floor(amount * (1 + this.scrapperBonus));
            }
            
            // Add currency to player and track in persistent stats
            if (currency === 'scrap') {
                this.playerStats.scrap += amount;
                this.persistent.totalScrapCollected += amount;
                // Challenge tracking - run and weekly scrap
                this.persistent.runScrapCollected = (this.persistent.runScrapCollected || 0) + amount;
                this.persistent.weeklyScrap = (this.persistent.weeklyScrap || 0) + amount;
            } else if (currency === 'credits') {
                this.playerStats.credits += amount;
                this.persistent.totalCreditsEarned += amount;
            } else if (currency === 'materials') {
                this.playerStats.materials += amount;
                this.persistent.totalMaterialsCollected += amount;
            }
            
            // Show floating text for currency
            const currencyConfig = CONFIG.CURRENCIES[currency.toUpperCase()];
            this.showFloatingText(x, y - 20, `+${amount} ${currencyConfig.icon}`, currencyConfig.color);
            sfx.loot();
            
            // Spawn skull with random item (not currency) if items available
            if (dropConfig.items && dropConfig.items.length > 0) {
                const item = Phaser.Utils.Array.GetRandom(dropConfig.items);
                let s = this.skulls.create(x, y, 'skull').setScale(0.8);
                s.setData('lootID', item);
            }
        }
        
        savePersistent(this.persistent);
    }

    // ==================== ACID SPIT (Spitter Enemy) ====================
    spawnAcidSpit(fromX, fromY, toX, toY) {
        const acid = this.acidProjectiles.create(fromX, fromY, 'acid');
        if (!acid) return;
        
        acid.hasHit = false;
        acid.setDepth(15);
        
        const angle = Phaser.Math.Angle.Between(fromX, fromY, toX, toY);
        this.physics.velocityFromRotation(angle, CONFIG.ENEMIES.SPITTER.SPIT_SPEED, acid.body.velocity);
        
        // Destroy after 3 seconds if not hit
        this.time.delayedCall(3000, () => {
            if (acid.active) {
                acid.setActive(false);
                acid.setVisible(false);
                acid.body.enable = false;
            }
        });
    }

    // ==================== GRENADE SYSTEM ====================
    throwGrenade() {
        if (this.playerStats.grenades <= 0) {
            this.showFloatingText(this.player.x, this.player.y - 40, "NO GRENADES!", 0xff0000);
            return;
        }
        if (this.isDodging || this.isPinned || this.isReloading) return;

        this.playerStats.grenades--;
        sfx.grenadeThrow();

        const grenade = this.grenades.create(this.player.x, this.player.y, 'grenade');
        if (!grenade) return;

        grenade.setDepth(15);
        grenade.hasExploded = false;

        // Throw toward mouse
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            this.input.activePointer.x, this.input.activePointer.y
        );
        this.physics.velocityFromRotation(angle, CONFIG.GRENADE.THROW_SPEED, grenade.body.velocity);
        
        // Slow down over time (drag)
        grenade.body.setDrag(200, 200);

        // Explode after fuse time
        this.time.delayedCall(CONFIG.GRENADE.FUSE_TIME, () => {
            if (grenade.active && !grenade.hasExploded) {
                this.explodeGrenade(grenade.x, grenade.y);
                grenade.hasExploded = true;
                grenade.destroy();
            }
        });
    }
    
    // ==================== CONSUMABLE SYSTEM ====================
    useConsumable(slot) {
        if (this.isPaused || this.isInventoryOpen || this.isDodging || this.isPinned) return;
        
        // Defensive check for corrupted consumables array
        if (!this.playerStats.consumables || !Array.isArray(this.playerStats.consumables)) {
            this.playerStats.consumables = [null, null, null];
        }
        
        const consumable = this.playerStats.consumables[slot];
        if (!consumable) {
            this.showFloatingText(this.player.x, this.player.y - 40, `SLOT ${slot + 1} EMPTY`, 0xff0000);
            return;
        }
        
        const config = CONFIG.CONSUMABLES[consumable];
        if (!config) return;
        
        // Apply effect based on consumable type
        if (config.effect === 'speed') {
            // Adrenaline - speed boost
            this.speedMultiplier = config.multiplier;
            sfx.useConsumable();
            this.showFloatingText(this.player.x, this.player.y - 40, "ADRENALINE!", 0x00ff00);
            
            // Visual feedback - tint player
            this.player.setTint(0x00ff00);
            
            // End effect after duration
            this.time.delayedCall(config.duration, () => {
                this.speedMultiplier = this.baseSpeedMultiplier; // Return to base (class-modified) speed
                if (this.player.active) {
                    this.player.clearTint();
                    this.showFloatingText(this.player.x, this.player.y - 40, "Speed normal", 0xffffff);
                }
            });
        } else if (config.effect === 'repair') {
            // Armor Patch - instant armor repair
            let repaired = false;
            const slots = ['head', 'body', 'arms', 'feet'];
            for (const armorSlot of slots) {
                if (this.playerStats.armor[armorSlot]) {
                    const armor = this.playerStats.armor[armorSlot];
                    if (armor.durability < armor.maxDurability) {
                        armor.durability = Math.min(armor.durability + config.amount, armor.maxDurability);
                        repaired = true;
                    }
                }
            }
            
            if (repaired) {
                sfx.useConsumable();
                this.showFloatingText(this.player.x, this.player.y - 40, "ARMOR PATCHED!", 0x00aaff);
            } else {
                this.showFloatingText(this.player.x, this.player.y - 40, "No armor to repair!", 0xff0000);
                return; // Don't consume if nothing to repair
            }
        }
        
        // Remove consumable from slot
        this.playerStats.consumables[slot] = null;
    }

    explodeGrenade(x, y) {
        sfx.explosion();
        if (this.gameSettings.screenShake) this.cameras.main.shake(200, 0.02);

        // Visual explosion
        const explosion = this.add.circle(x, y, 10, 0xff4500, 1).setDepth(100);
        this.tweens.add({
            targets: explosion,
            radius: CONFIG.GRENADE.EXPLOSION_RADIUS,
            alpha: 0,
            duration: 300,
            onComplete: () => explosion.destroy()
        });

        // Spawn multiple flash particles
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const dist = 30 + Math.random() * 40;
            this.particles.spawnMuzzleFlash(
                x + Math.cos(angle) * dist,
                y + Math.sin(angle) * dist,
                angle, 1.5
            );
        }

        // Damage enemies in radius and track kills for achievement
        let grenadeKillsThisExplosion = 0;
        const enemiesInRange = [];
        
        // First pass: collect enemies and their HP
        this.enemies.getChildren().forEach(enemy => {
            if (!enemy.active) return;
            const dist = Phaser.Math.Distance.Between(x, y, enemy.x, enemy.y);
            if (dist < CONFIG.GRENADE.EXPLOSION_RADIUS) {
                const damageMult = 1 - (dist / CONFIG.GRENADE.EXPLOSION_RADIUS) * 0.5;
                let damage = Math.ceil(CONFIG.GRENADE.DAMAGE * damageMult);
                // Apply permanent damage boost
                if (this.permanentDamageBoost > 1) {
                    damage = Math.ceil(damage * this.permanentDamageBoost);
                }
                enemiesInRange.push({ enemy, damage, willDie: enemy.hp <= damage });
            }
        });
        
        // Count kills before applying damage
        grenadeKillsThisExplosion = enemiesInRange.filter(e => e.willDie).length;
        
        // Second pass: apply damage
        enemiesInRange.forEach(({ enemy, damage }) => {
            if (enemy.takeDamage) enemy.takeDamage(damage, 'grenade');
            
            // Knockback (only if enemy still alive and has body)
            if (enemy.active && enemy.body) {
                const knockAngle = Phaser.Math.Angle.Between(x, y, enemy.x, enemy.y);
                this.physics.velocityFromRotation(knockAngle, 300, enemy.body.velocity);
            }
        });
        
        // Check grenadier achievement (3+ kills with one grenade)
        if (grenadeKillsThisExplosion >= 3) {
            const newAchievements = checkAchievements(this.persistent, { grenadeMultiKill: grenadeKillsThisExplosion });
            newAchievements.forEach(a => {
                sfx.achievement();
                this.showFloatingText(400, 200, `${a.icon} ${a.name}!`, 0xffd700);
            });
            savePersistent(this.persistent);
        }

        this.showFloatingText(x, y, "BOOM!", 0xff4500);
    }
    
    exploderExplosion(x, y) {
        const cfg = CONFIG.ENEMIES.EXPLODER;
        sfx.exploderExplode();
        if (this.gameSettings.screenShake) this.cameras.main.shake(150, 0.015);

        // Visual explosion - orange
        const explosion = this.add.circle(x, y, 10, 0xff6600, 1).setDepth(100);
        this.tweens.add({
            targets: explosion,
            radius: cfg.EXPLOSION_RADIUS,
            alpha: 0,
            duration: 250,
            onComplete: () => explosion.destroy()
        });

        // Spawn flash particles
        for (let i = 0; i < 6; i++) {
            const angle = (i / 6) * Math.PI * 2;
            const dist = 20 + Math.random() * 30;
            this.particles.spawnMuzzleFlash(
                x + Math.cos(angle) * dist,
                y + Math.sin(angle) * dist,
                angle, 1.2
            );
        }

        // Damage player if in range
        const playerDist = Phaser.Math.Distance.Between(x, y, this.player.x, this.player.y);
        if (playerDist < cfg.EXPLOSION_RADIUS) {
            this.hitPlayer(cfg.DAMAGE, x, y);
        }

        // Damage other enemies in range (chain reactions!)
        this.enemies.getChildren().forEach(enemy => {
            if (!enemy.active) return;
            const dist = Phaser.Math.Distance.Between(x, y, enemy.x, enemy.y);
            if (dist < cfg.EXPLOSION_RADIUS && dist > 0) { // dist > 0 prevents self-damage
                const damageMult = 1 - (dist / cfg.EXPLOSION_RADIUS) * 0.5;
                const damage = Math.ceil(cfg.ENEMY_DAMAGE * damageMult);
                if (enemy.takeDamage) enemy.takeDamage(damage, 'explosion');
                
                // Knockback
                if (enemy.active && enemy.body) {
                    const knockAngle = Phaser.Math.Angle.Between(x, y, enemy.x, enemy.y);
                    this.physics.velocityFromRotation(knockAngle, 200, enemy.body.velocity);
                }
            }
        });

        this.showFloatingText(x, y, "KABOOM!", 0xff6600);
    }
    
    spawnNecroProjectile(fromX, fromY, toX, toY) {
        const cfg = CONFIG.ENEMIES.NECROMANCER;
        // Create a slow-moving projectile
        const proj = this.acidProjectiles.get(fromX, fromY);
        if (proj) {
            proj.body.reset(fromX, fromY);
            proj.body.enable = true;
            proj.setActive(true);
            proj.setVisible(true);
            proj.hasHit = false;
            proj.setTint(0x8800ff); // Purple for necro
            proj.setScale(1.5);
            
            const angle = Phaser.Math.Angle.Between(fromX, fromY, toX, toY);
            this.physics.velocityFromRotation(angle, cfg.PROJECTILE_SPEED, proj.body.velocity);
            proj.setRotation(angle);
        }
    }

    createInventoryUI() {
        this.invContainer = this.add.container(400, 300).setDepth(300).setVisible(false);
        const bg = this.add.rectangle(0, 0, 600, 400, 0x111111, 0.9).setStrokeStyle(4, 0x444444);
        const title = this.add.text(0, -180, "INVENTORY", { fontSize: '32px', fill: '#fff' }).setOrigin(0.5);
        this.invText = this.add.text(-280, -140, "", { fontSize: '18px', fill: '#ccc', lineSpacing: 10 });
        this.armorSlots = {};
        const slots = [
            { id: 'head', x: 150, y: -100, label: 'HEAD' },
            { id: 'body', x: 150, y: 0, label: 'BODY' },
            { id: 'arms', x: 50, y: 0, label: 'ARMS' },
            { id: 'feet', x: 150, y: 100, label: 'FEET' }
        ];
        slots.forEach(s => {
            let slotBg = this.add.rectangle(s.x, s.y, 80, 80, 0x333333).setStrokeStyle(1, 0x666666);
            let lbl = this.add.text(s.x, s.y - 30, s.label, { fontSize: '12px', fill: '#888' }).setOrigin(0.5);
            let itemTxt = this.add.text(s.x, s.y, "EMPTY", { fontSize: '12px', fill: '#555' }).setOrigin(0.5);
            this.invContainer.add([slotBg, lbl, itemTxt]);
            this.armorSlots[s.id] = itemTxt;
        });
        this.invContainer.add([bg, title, this.invText]);
    }

    updateInventoryUI() {
        const weapon = this.playerStats.currentWeapon;
        const mag = this.playerStats.magazines[weapon];
        const modEffects = this.weaponModEffects?.[weapon] || { magSizeMultiplier: 1 };
        const effectiveMagSize = Math.floor(CONFIG.WEAPONS[weapon.toUpperCase()].MAG_SIZE * modEffects.magSizeMultiplier);
        
        // Build mod display string
        const equippedMods = this.playerStats.equippedMods?.[weapon] || [null, null];
        let modText = 'MODS: ';
        const modNames = equippedMods.filter(m => m).map(modId => {
            const mod = Object.values(CONFIG.MODS).find(m => m.id === modId);
            return mod ? `[${mod.icon}]${mod.name}` : modId;
        });
        modText += modNames.length > 0 ? modNames.join(' + ') : 'None';
        
        this.invText.setText(
            `HP: ${this.playerStats.hp}/${this.playerStats.maxHp}\n` +
            `AMMO: ${mag}/${effectiveMagSize} (${this.playerStats.ammo} reserve)\n` +
            `GRENADES: ${this.playerStats.grenades}/${CONFIG.GRENADE.MAX_CARRY}\n` +
            `SCRAP: ${this.playerStats.scrap}\n\n` +
            `WEAPON: ${weapon.toUpperCase()}\n` +
            `${modText}\n` +
            `FLASHLIGHT: ${this.playerStats.hasFlashlight ? "YES" : "NO"}\n` +
            `NVG: ${this.playerStats.hideout.armory.hasNVG ? "EQUIPPED" : "NO"}\n`
        );
        for (const [slot, item] of Object.entries(this.playerStats.armor)) {
            let txtObj = this.armorSlots[slot];
            if (item) {
                txtObj.setText(`${item.name}\n${item.durability}/${item.maxDurability}`);
                txtObj.setColor('#00ff00');
            } else {
                txtObj.setText("EMPTY");
                txtObj.setColor('#555');
            }
        }
    }

    toggleInventory() {
        this.isInventoryOpen = !this.isInventoryOpen;
        if (this.isInventoryOpen) {
            sfx.menuOpen();
            this.updateInventoryUI();
            this.invContainer.setVisible(true);
            this.physics.pause();
            this.isPaused = true;
        } else {
            sfx.menuClose();
            this.invContainer.setVisible(false);
            this.physics.resume();
            this.isPaused = false;
        }
    }

    togglePause() {
        this.isPaused = !this.isPaused;
        if (this.isPaused) {
            sfx.menuOpen();
            this.physics.pause();
            this.pauseText.setVisible(true);
        } else {
            sfx.menuClose();
            this.physics.resume();
            this.pauseText.setVisible(false);
        }
    }

    // =============================================================================
    // ROGUELIKE ROOM SYSTEM
    // =============================================================================
    
    generateRoomGrid(level) {
        const gridConfig = CONFIG.LEVEL_GRIDS[level];
        if (!gridConfig) {
            console.warn(`No grid config for level ${level}, using fallback`);
            return null;
        }
        
        const { cols, rows, theme } = gridConfig;
        const chunks = CONFIG.ROOM_CHUNKS[theme];
        if (!chunks || chunks.length === 0) {
            console.warn(`No room chunks for theme ${theme}, using fallback`);
            return null;
        }
        
        // Create grid structure
        const grid = {
            cols,
            rows,
            theme,
            rooms: [],
            startRoom: 0,
            exitRoom: (cols * rows) - 1,
            currentRoom: 0
        };
        
        // Generate rooms
        const totalRooms = cols * rows;
        for (let i = 0; i < totalRooms; i++) {
            const row = Math.floor(i / cols);
            const col = i % cols;
            
            // Pick a random chunk for this room
            let selectedChunk;
            
            // Boss levels use specific boss room for exit
            const isBossLevel = (level === 5 || level === 7);
            
            if (i === grid.exitRoom && isBossLevel) {
                // Exit room on boss level = boss room
                selectedChunk = chunks.find(c => c.isBossRoom) || chunks[Math.floor(Math.random() * chunks.length)];
            } else {
                // Filter chunks by door compatibility for non-edge rooms
                // Also exclude boss rooms from non-exit rooms on boss levels
                const validChunks = chunks.filter(chunk => {
                    // Exclude boss rooms from non-exit rooms on boss levels
                    if (isBossLevel && chunk.isBossRoom) return false;
                    // Check if chunk can connect to adjacent rooms
                    if (col > 0 && !chunk.doorPositions.west) return false;
                    if (col < cols - 1 && !chunk.doorPositions.east) return false;
                    if (row > 0 && !chunk.doorPositions.north) return false;
                    if (row < rows - 1 && !chunk.doorPositions.south) return false;
                    return true;
                });
                
                // Fallback: non-boss chunks only for boss levels
                const fallbackChunks = isBossLevel 
                    ? chunks.filter(c => !c.isBossRoom) 
                    : chunks;
                
                selectedChunk = validChunks.length > 0 
                    ? validChunks[Math.floor(Math.random() * validChunks.length)]
                    : fallbackChunks[Math.floor(Math.random() * fallbackChunks.length)];
            }
            
            // Determine connections to adjacent rooms
            const connections = {
                north: row > 0 ? i - cols : null,
                south: row < rows - 1 ? i + cols : null,
                east: col < cols - 1 ? i + 1 : null,
                west: col > 0 ? i - 1 : null
            };
            
            grid.rooms.push({
                index: i,
                row,
                col,
                chunk: JSON.parse(JSON.stringify(selectedChunk)), // Deep copy
                connections,
                cleared: false,
                visited: false,
                hasRiskRoom: false, // Will be assigned below (only 1 per level)
                riskRoomCleared: false,
                isStart: i === grid.startRoom,
                isExit: i === grid.exitRoom
            });
        }
        
        // Assign exactly ONE risk room per level (25% chance to have one at all)
        if (Math.random() < CONFIG.RISK_ROOM.SPAWN_CHANCE) {
            // Find eligible rooms (not start, not exit, not boss)
            const eligibleRooms = grid.rooms.filter(room => 
                !room.isStart && 
                !room.isExit && 
                !room.chunk.isBossRoom
            );
            
            if (eligibleRooms.length > 0) {
                // Pick one random eligible room
                const riskRoom = eligibleRooms[Math.floor(Math.random() * eligibleRooms.length)];
                riskRoom.hasRiskRoom = true;
            }
        }
        
        // Mark start room as visited
        grid.rooms[grid.startRoom].visited = true;
        
        return grid;
    }
    
    setupRoom(roomData) {
        // Clear existing room elements (walls, floor)
        if (this.roomFloor) this.roomFloor.destroy();
        if (this.roomOverlay) this.roomOverlay.destroy();
        if (this.roomWalls) {
            this.roomWalls.forEach(w => w.destroy());
        }
        this.roomWalls = [];
        if (this.roomDoors) {
            this.roomDoors.forEach(d => d.destroy());
        }
        this.roomDoors = [];
        if (this.riskDoor) {
            this.riskDoor.destroy();
            this.riskDoor = null;
        }
        if (this.riskDoorIcon) {
            this.riskDoorIcon.destroy();
            this.riskDoorIcon = null;
        }
        if (this.exitLabel) {
            this.exitLabel.destroy();
            this.exitLabel = null;
        }
        if (this.door) {
            this.door.destroy();
            this.door = null;
        }
        
        const chunk = roomData.chunk;
        
        // Create floor
        this.roomFloor = this.add.tileSprite(400, 300, 800, 600, chunk.floor).setDepth(0);
        
        // Create floor overlay if specified (for dark levels like cemetery)
        if (chunk.floorOverlay) {
            this.roomOverlay = this.add.rectangle(400, 300, 800, 600, chunk.floorOverlay.color, chunk.floorOverlay.alpha).setDepth(0);
        }
        
        // Create church visual if specified
        if (chunk.churchVisual) {
            this.add.rectangle(400, 100, 400, 150, 0x222222, 0.5).setDepth(1);
            this.add.text(400, 50, "CHURCH", { fontSize: '18px', fill: '#555' }).setOrigin(0.5).setDepth(2);
        }
        
        // Create walls from chunk template
        chunk.walls.forEach(wallDef => {
            const wall = this.walls.create(wallDef.x, wallDef.y, 'wall');
            wall.setScale(wallDef.scaleX || 1, wallDef.scaleY || 1).refreshBody();
            if (wallDef.tint) wall.setTint(wallDef.tint);
            this.roomWalls.push(wall);
        });
        
        // Create doors to adjacent rooms
        const doorPositions = {
            north: { x: 400, y: 30, angle: 0 },
            south: { x: 400, y: 570, angle: 0 },
            east: { x: 770, y: 300, angle: 90 },
            west: { x: 30, y: 300, angle: 90 }
        };
        
        Object.entries(roomData.connections).forEach(([direction, targetRoom]) => {
            if (targetRoom !== null) {
                const pos = doorPositions[direction];
                const door = this.physics.add.staticSprite(pos.x, pos.y, 'door');
                door.setAngle(pos.angle);
                door.setTint(0x888888); // Gray for room transition doors
                door.doorDirection = direction;
                door.targetRoom = targetRoom;
                door.isRoomDoor = true;
                this.roomDoors.push(door);
            }
        });
        
        // Exit room has the level exit door
        if (roomData.isExit) {
            // For boss levels, door appears after boss defeat
            if (this.currentLevel === 5 || this.currentLevel === 7) {
                // Don't create exit door yet - it spawns after boss
                this.door = this.physics.add.staticSprite(-100, -100, 'door');
            } else {
                // Find a wall side that doesn't have a room door
                // Room doors are placed based on connections, so find a null connection
                const exitPositions = {
                    north: { x: 400, y: 80, labelY: 40, angle: 0 },
                    south: { x: 400, y: 520, labelY: 560, angle: 0 },
                    east: { x: 720, y: 300, labelX: 720, labelY: 250, angle: 90 },
                    west: { x: 80, y: 300, labelX: 80, labelY: 250, angle: 90 }
                };
                
                // Priority order: north, east, west, south (prefer top/sides over bottom)
                const priorities = ['north', 'east', 'west', 'south'];
                let exitDir = null;
                for (const dir of priorities) {
                    if (roomData.connections[dir] === null) {
                        exitDir = dir;
                        break;
                    }
                }
                
                // Fallback to center if somehow all sides have connections
                if (!exitDir) {
                    exitDir = 'north';
                }
                
                const exitPos = exitPositions[exitDir];
                this.door = this.physics.add.staticSprite(exitPos.x, exitPos.y, 'door');
                this.door.setTint(0xFFD700); // Gold for level exit
                this.door.setScale(1.5); // Larger to stand out
                this.door.setDepth(15);
                if (exitPos.angle) this.door.setAngle(exitPos.angle);
                
                // Add EXIT label near door
                const labelX = exitPos.labelX || exitPos.x;
                const labelY = exitPos.labelY || exitPos.y - 45;
                this.exitLabel = this.add.text(labelX, labelY, 'üö™ EXIT', { 
                    fontSize: '20px', 
                    fill: '#FFD700',
                    stroke: '#000',
                    strokeThickness: 3
                }).setOrigin(0.5).setDepth(100);
            }
        } else {
            // Create invisible door placeholder
            this.door = this.physics.add.staticSprite(-100, -100, 'door');
        }
        
        // Create risk room door if this room has one
        if (roomData.hasRiskRoom && !roomData.riskRoomCleared) {
            // Find a wall position to place the risk door
            const riskDoorX = 750;
            const riskDoorY = 500;
            this.riskDoor = this.physics.add.staticSprite(riskDoorX, riskDoorY, 'door');
            this.riskDoor.setTint(0xff0000); // Red tint for danger
            this.riskDoor.setScale(0.8);
            this.riskDoor.isRiskDoor = true;
            
            // Add danger indicator
            this.riskDoorIcon = this.add.text(riskDoorX, riskDoorY - 40, '‚ö†Ô∏è', { fontSize: '24px' }).setOrigin(0.5).setDepth(100);
            
            // Pulsing animation
            this.tweens.add({
                targets: this.riskDoor,
                alpha: { from: 1, to: 0.5 },
                duration: 500,
                yoyo: true,
                repeat: -1
            });
        }
        
        // Update minimap
        this.updateMinimap();
    }
    
    spawnRoomEntities(roomData, isRiskRoom = false) {
        const chunk = roomData.chunk;
        const level = this.currentLevel;
        
        // Determine enemy types based on level
        const levelEnemyTypes = {
            1: ['walker', 'bandit', 'leaper'],
            2: ['bandit', 'leaper', 'walker'],
            3: ['walker', 'spitter', 'bandit'],
            4: ['spitter', 'walker', 'leaper'],
            5: ['spitter', 'walker', 'boss'],
            6: ['exploder', 'walker', 'bandit', 'spitter'],
            7: ['walker', 'necromancer']
        };
        
        // Determine loot pool based on level (map spawns to reveal minimap)
        const levelLootPools = {
            1: ['map', 'key', 'flashlight', 'shotgun', 'ammo', 'ammo', 'helmet', 'vest', 'scrap'],
            2: ['map', 'molotov', 'shotgun', 'ammo', 'ammo', 'scrap', 'helmet', 'vest', 'plug'],
            3: ['map', 'key', 'ammo', 'ammo', 'meds', 'meds', 'scrap', 'grenade'],
            4: ['map', 'key', 'smg', 'ammo', 'ammo', 'ammo', 'grenade', 'grenade', 'meds', 'scrap', 'plug'],
            5: ['map', 'ammo', 'ammo', 'ammo', 'meds', 'meds', 'grenade', 'scrap', 'extended_mag'],
            6: ['map', 'key', 'rifle', 'ammo', 'ammo', 'ammo', 'meds', 'grenade', 'grenade', 'suppressor', 'rapid_fire'],
            7: ['map', 'key', 'crossbow', 'ammo', 'ammo', 'meds', 'meds', 'laser_sight', 'damage_barrel', 'materials']
        };
        
        let enemyTypes = levelEnemyTypes[level] || ['walker'];
        let lootPool = [...(levelLootPools[level] || ['ammo', 'scrap'])];
        
        // Risk room modifications
        let enemyMultiplier = 1;
        let lootMultiplier = 1;
        if (isRiskRoom) {
            enemyMultiplier = CONFIG.RISK_ROOM.ENEMY_MULTIPLIER;
            lootMultiplier = CONFIG.RISK_ROOM.LOOT_MULTIPLIER;
            // Add guaranteed mod drop
            const randomMod = CONFIG.RISK_ROOM.GUARANTEED_DROPS[
                Math.floor(Math.random() * CONFIG.RISK_ROOM.GUARANTEED_DROPS.length)
            ];
            lootPool.push(randomMod);
            // Upgrade enemy types
            enemyTypes = enemyTypes.map(type => CONFIG.RISK_ROOM.ENEMY_UPGRADES[type] || type);
        }
        
        // Spawn enemies at spawn points
        const spawnPoints = [...chunk.spawnPoints];
        Phaser.Utils.Array.Shuffle(spawnPoints);
        
        // Determine enemy count (2-4 per room, modified by level and risk)
        let baseEnemyCount = Math.min(2 + Math.floor(level / 2), spawnPoints.length);
        let enemyCount = Math.floor(baseEnemyCount * enemyMultiplier);
        
        // Boss rooms have special spawning
        if (chunk.isBossRoom) {
            if (level === 5) {
                this.spawnEnemy('boss', 400, 150);
                this.bossBar.setVisible(true);
                this.bossText.setVisible(true);
                this.bossText.setText("PATIENT ZERO");
                this.updateBossBar(CONFIG.ENEMIES.BOSS.HP, CONFIG.ENEMIES.BOSS.HP);
                this.time.delayedCall(500, () => sfx.bossRoar());
                // Support enemies
                enemyCount = 2;
                enemyTypes = ['spitter', 'walker'];
            } else if (level === 7) {
                this.spawnEnemy('necromancer', 400, 80);
                this.bossBar.setVisible(true);
                this.bossText.setVisible(true);
                this.bossText.setText("THE NECROMANCER");
                this.updateBossBar(CONFIG.ENEMIES.NECROMANCER.HP, CONFIG.ENEMIES.NECROMANCER.HP);
                this.time.delayedCall(500, () => sfx.necroSummon());
                
                // Initialize stealth for cemetery
                this.isStealthLevel = true;
                this.detectionMeter = 0;
                this.maxDetection = 100;
                this.detectionRate = 20;
                this.detectionDecay = 10;
                this.stealthAlerted = false;
                this.detectionBar = this.add.graphics().setDepth(150);
                this.detectionText = this.add.text(400, 40, "STEALTH", { fontSize: '16px', fill: '#fff' }).setOrigin(0.5).setDepth(150);
                
                // Patrol enemies
                this.patrolEnemies = [];
                enemyCount = 0; // No random spawns, use patrols
            }
        }
        
        // Spawn regular enemies
        for (let i = 0; i < enemyCount && i < spawnPoints.length; i++) {
            const pos = spawnPoints[i];
            const enemyType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
            // Don't spawn bosses from random pool
            if (enemyType !== 'boss' && enemyType !== 'necromancer') {
                this.spawnEnemy(enemyType, pos.x, pos.y);
            }
        }
        
        // Spawn loot crates - filter out positions near doors
        const doorZones = [
            { x: 400, y: 30 },   // North door
            { x: 400, y: 570 },  // South door
            { x: 770, y: 300 },  // East door
            { x: 30, y: 300 },   // West door
            { x: 400, y: 100 },  // Exit door position
            { x: 750, y: 500 }   // Risk door position
        ];
        const doorClearance = 50; // Minimum distance from doors
        
        let crateSlots = chunk.crateSlots.filter(slot => {
            return !doorZones.some(door => 
                Math.abs(slot.x - door.x) < doorClearance && 
                Math.abs(slot.y - door.y) < doorClearance
            );
        });
        
        // Fallback: if all/most slots filtered out, use original slots sorted by distance (essential items must spawn)
        if (crateSlots.length < 2 && chunk.crateSlots.length > 0) {
            // Sort by distance from nearest door (furthest first) - don't shuffle these
            crateSlots = [...chunk.crateSlots].sort((a, b) => {
                const distA = Math.min(...doorZones.map(d => 
                    Math.sqrt(Math.pow(a.x - d.x, 2) + Math.pow(a.y - d.y, 2))));
                const distB = Math.min(...doorZones.map(d => 
                    Math.sqrt(Math.pow(b.x - d.x, 2) + Math.pow(b.y - d.y, 2))));
                return distB - distA; // Furthest first
            });
        } else {
            Phaser.Utils.Array.Shuffle(crateSlots);
        }
        
        // Essential items tracking
        const levelsNeedingKey = [1, 3, 4, 6]; // Levels that require keys
        const needsKey = levelsNeedingKey.includes(level);
        
        // Track spawning at grid level
        if (this.keySpawned === undefined) this.keySpawned = false;
        if (this.mapSpawned === undefined) this.mapSpawned = false;
        
        // Determine what essential items to spawn in this room
        let essentialItems = [];
        
        // Map spawns in START room (so player gets it early)
        if (!this.mapSpawned && roomData.isStart && lootPool.includes('map')) {
            essentialItems.push('map');
            this.mapSpawned = true;
        }
        
        // Key spawns in first NON-start room (gives reason to explore)
        if (needsKey && !this.keySpawned && !roomData.isStart && lootPool.includes('key')) {
            essentialItems.push('key');
            this.keySpawned = true;
        }
        
        // Build the final loot list for this room
        let roomLoot = [...essentialItems]; // Essential items first
        
        // Add other items (excluding already-spawned essentials)
        let filteredPool = lootPool.filter(item => {
            if (item === 'map' && this.mapSpawned) return false;
            if (item === 'key' && this.keySpawned) return false;
            return true;
        });
        Phaser.Utils.Array.Shuffle(filteredPool);
        roomLoot = roomLoot.concat(filteredPool);
        
        // Calculate crate count - ensure essential items ALWAYS spawn
        let crateCount = Math.floor(Math.min(crateSlots.length, roomLoot.length) * lootMultiplier);
        crateCount = Math.min(crateCount, crateSlots.length); // Can't exceed slots
        crateCount = Math.max(crateCount, Math.min(essentialItems.length, crateSlots.length)); // Must spawn essentials
        
        for (let i = 0; i < crateCount; i++) {
            const pos = crateSlots[i];
            const lootID = roomLoot[i % roomLoot.length];
            this.crates.create(pos.x, pos.y, 'crate').setScale(0.5).refreshBody().setData('lootID', lootID);
        }
        
        // Emergency fallback: if essential items couldn't spawn due to no crate slots, spawn them directly
        if (crateSlots.length === 0 && essentialItems.length > 0) {
            const fallbackPositions = [
                { x: 200, y: 300 }, { x: 600, y: 300 }, { x: 400, y: 400 }
            ];
            for (let i = 0; i < Math.min(essentialItems.length, fallbackPositions.length); i++) {
                const pos = fallbackPositions[i];
                this.crates.create(pos.x, pos.y, 'crate').setScale(0.5).refreshBody().setData('lootID', essentialItems[i]);
            }
        }
    }
    
    transitionToRoom(targetRoomIndex) {
        if (targetRoomIndex === null || targetRoomIndex === undefined) return;
        if (!this.roomGrid || !this.roomGrid.rooms[targetRoomIndex]) return;
        if (this.isTransitioningRoom) return; // Prevent re-entry during transition
        
        this.isTransitioningRoom = true;
        
        const currentRoom = this.roomGrid.rooms[this.roomGrid.currentRoom];
        const targetRoom = this.roomGrid.rooms[targetRoomIndex];
        
        // Mark current room as cleared if all enemies dead
        if (this.enemies.countActive() === 0) {
            currentRoom.cleared = true;
        }
        
        // Save current room state
        currentRoom.enemiesRemaining = this.enemies.countActive();
        
        // Play transition sound
        sfx.doorOpen();
        
        // Fade transition
        this.cameras.main.fadeOut(200, 0, 0, 0);
        
        this.time.delayedCall(200, () => {
            // Clear current room
            this.enemies.clear(true, true);
            this.bullets.clear(true, true);
            this.crates.getChildren().forEach(c => c.destroy());
            this.skulls.clear(true, true);
            
            // Update current room index
            this.roomGrid.currentRoom = targetRoomIndex;
            targetRoom.visited = true;
            
            // Setup new room
            this.setupRoom(targetRoom);
            
            // Only spawn entities if room hasn't been cleared
            if (!targetRoom.cleared) {
                this.spawnRoomEntities(targetRoom, false);
            }
            
            // Position player near the door they entered from
            // entryPositions: where to spawn based on which side the entry door is on
            const entryPositions = {
                north: { x: 400, y: 80 },   // Door on north, spawn near north
                south: { x: 400, y: 520 },  // Door on south, spawn near south
                east: { x: 720, y: 300 },   // Door on east, spawn near east
                west: { x: 80, y: 300 }     // Door on west, spawn near west
            };
            
            // Determine which direction we entered from (which side has the door back)
            // If currentRoom went EAST to reach targetRoom, then targetRoom's WEST door leads back
            let entryDoorSide = null;
            Object.entries(currentRoom.connections).forEach(([dir, roomIdx]) => {
                if (roomIdx === targetRoomIndex) {
                    // We exited currentRoom going this direction
                    // So we entered targetRoom from the opposite side
                    const opposites = { north: 'south', south: 'north', east: 'west', west: 'east' };
                    entryDoorSide = opposites[dir];
                }
            });
            
            if (entryDoorSide && entryPositions[entryDoorSide]) {
                this.player.setPosition(entryPositions[entryDoorSide].x, entryPositions[entryDoorSide].y);
            } else {
                this.player.setPosition(400, 500);
            }
            
            // Fade back in and reset transition flag
            this.cameras.main.fadeIn(200, 0, 0, 0);
            this.isTransitioningRoom = false;
        });
    }
    
    enterRiskRoom() {
        if (!this.roomGrid) return;
        if (this.isTransitioningRoom) return; // Prevent re-entry during transition
        
        const currentRoom = this.roomGrid.rooms[this.roomGrid.currentRoom];
        if (!currentRoom.hasRiskRoom || currentRoom.riskRoomCleared) return;
        
        this.isTransitioningRoom = true;
        sfx.doorOpen();
        this.showFloatingText(400, 300, "ENTERING RISK ROOM!", 0xff0000);
        
        // Fade transition
        this.cameras.main.fadeOut(200, 0, 0, 0);
        
        this.time.delayedCall(200, () => {
            // Clear current room elements completely
            this.enemies.clear(true, true);
            this.bullets.clear(true, true);
            this.crates.getChildren().forEach(c => c.destroy());
            this.skulls.clear(true, true);
            
            // Clear room-specific elements (but DON'T call setupRoom)
            if (this.roomFloor) this.roomFloor.destroy();
            if (this.roomOverlay) this.roomOverlay.destroy();
            if (this.roomWalls) this.roomWalls.forEach(w => w.destroy());
            this.roomWalls = [];
            if (this.roomDoors) this.roomDoors.forEach(d => d.destroy());
            this.roomDoors = []; // NO ROOM DOORS in risk room
            if (this.riskDoor) { this.riskDoor.destroy(); this.riskDoor = null; }
            if (this.riskDoorIcon) { this.riskDoorIcon.destroy(); this.riskDoorIcon = null; }
            if (this.exitLabel) { this.exitLabel.destroy(); this.exitLabel = null; }
            if (this.door) { this.door.destroy(); this.door = null; }
            
            // Hide minimap in risk room
            if (this.minimapGraphics) this.minimapGraphics.clear();
            
            // Create isolated risk room - simple arena with walls around edges
            this.roomFloor = this.add.tileSprite(400, 300, 800, 600, 'floor_sewer').setDepth(0);
            this.roomOverlay = this.add.rectangle(400, 300, 800, 600, 0x330000, 0.3).setDepth(0); // Red tint
            
            // Edge walls to contain the arena (no escape except exit door)
            const wallPositions = [
                { x: 400, y: 20, sx: 25, sy: 1 },   // Top wall
                { x: 400, y: 580, sx: 25, sy: 1 },  // Bottom wall (gap for exit)
                { x: 20, y: 300, sx: 1, sy: 18 },   // Left wall
                { x: 780, y: 300, sx: 1, sy: 18 },  // Right wall
                // Some cover in the arena
                { x: 200, y: 200, sx: 2, sy: 2 },
                { x: 600, y: 200, sx: 2, sy: 2 },
                { x: 400, y: 350, sx: 2, sy: 2 }
            ];
            wallPositions.forEach(wp => {
                const wall = this.walls.create(wp.x, wp.y, 'wall');
                wall.setScale(wp.sx, wp.sy).refreshBody();
                wall.setTint(0x442222);
                this.roomWalls.push(wall);
            });
            
            // Mark that we're in risk room mode
            this.inRiskRoom = true;
            
            // Invisible main door placeholder
            this.door = this.physics.add.staticSprite(-100, -100, 'door');
            
            // Create ONLY exit door at bottom center
            this.riskRoomExitDoor = this.physics.add.staticSprite(400, 560, 'door');
            this.riskRoomExitDoor.setTint(0x00ff00); // Green for exit
            this.riskRoomExitDoor.setScale(1.2);
            this.riskRoomExitDoor.setDepth(15);
            
            // Exit door label
            this.riskRoomExitLabel = this.add.text(400, 520, 'üö™ EXIT (clear enemies first)', { 
                fontSize: '16px', 
                fill: '#00ff00',
                stroke: '#000',
                strokeThickness: 2
            }).setOrigin(0.5).setDepth(200);
            
            // Show risk room indicator
            this.riskRoomText = this.add.text(400, 50, "‚ö†Ô∏è DANGER ZONE ‚ö†Ô∏è", { 
                fontSize: '28px', 
                fill: '#ff0000',
                stroke: '#000',
                strokeThickness: 4
            }).setOrigin(0.5).setDepth(200);
            
            // Spawn harder enemies and better loot
            this.spawnRiskRoomEntities();
            
            // Position player at top (away from exit)
            this.player.setPosition(400, 150);
            
            // Fade back in and reset transition flag
            this.cameras.main.fadeIn(200, 0, 0, 0);
            this.isTransitioningRoom = false;
        });
    }
    
    spawnRiskRoomEntities() {
        const level = this.currentLevel;
        
        // Upgraded enemy types for risk room
        const riskEnemyTypes = {
            1: ['leaper', 'bandit'],
            2: ['bandit', 'leaper', 'spitter'],
            3: ['spitter', 'bandit', 'leaper'],
            4: ['exploder', 'spitter', 'bandit'],
            5: ['spitter', 'bandit', 'exploder'],
            6: ['exploder', 'bandit', 'spitter'],
            7: ['exploder', 'bandit', 'spitter']
        };
        
        const enemyTypes = riskEnemyTypes[level] || ['bandit', 'leaper'];
        
        // Spawn 4-6 enemies in arena positions
        const spawnPoints = [
            { x: 150, y: 300 }, { x: 650, y: 300 },
            { x: 300, y: 150 }, { x: 500, y: 150 },
            { x: 300, y: 450 }, { x: 500, y: 450 }
        ];
        
        const enemyCount = 4 + Math.floor(level / 2);
        for (let i = 0; i < enemyCount && i < spawnPoints.length; i++) {
            const pos = spawnPoints[i];
            const enemyType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
            this.spawnEnemy(enemyType, pos.x, pos.y);
        }
        
        // Spawn guaranteed good loot
        const riskLoot = [
            CONFIG.RISK_ROOM.GUARANTEED_DROPS[Math.floor(Math.random() * CONFIG.RISK_ROOM.GUARANTEED_DROPS.length)],
            'ammo', 'ammo', 'meds', 'grenade', 'scrap'
        ];
        
        const cratePositions = [
            { x: 100, y: 100 }, { x: 700, y: 100 },
            { x: 100, y: 500 }, { x: 700, y: 500 },
            { x: 400, y: 250 }
        ];
        
        cratePositions.forEach((pos, i) => {
            if (i < riskLoot.length) {
                this.crates.create(pos.x, pos.y, 'crate').setScale(0.5).refreshBody().setData('lootID', riskLoot[i]);
            }
        });
    }
    
    exitRiskRoom() {
        if (!this.roomGrid || !this.inRiskRoom) return;
        if (this.isTransitioningRoom) return; // Prevent re-entry during transition
        
        this.isTransitioningRoom = true;
        
        const currentRoom = this.roomGrid.rooms[this.roomGrid.currentRoom];
        currentRoom.riskRoomCleared = true;
        this.inRiskRoom = false;
        
        sfx.doorOpen();
        this.showFloatingText(400, 300, "RISK ROOM CLEARED!", 0x00ff00);
        
        // Fade transition back to main room
        this.cameras.main.fadeOut(200, 0, 0, 0);
        
        this.time.delayedCall(200, () => {
            // Clear risk room entities
            this.enemies.clear(true, true);
            this.bullets.clear(true, true);
            this.crates.getChildren().forEach(c => c.destroy());
            this.skulls.clear(true, true);
            
            // Remove risk room UI elements
            if (this.riskRoomText) { this.riskRoomText.destroy(); this.riskRoomText = null; }
            if (this.riskRoomExitDoor) { this.riskRoomExitDoor.destroy(); this.riskRoomExitDoor = null; }
            if (this.riskRoomExitLabel) { this.riskRoomExitLabel.destroy(); this.riskRoomExitLabel = null; }
            
            // Clear risk room walls and floor
            if (this.roomFloor) this.roomFloor.destroy();
            if (this.roomOverlay) this.roomOverlay.destroy();
            if (this.roomWalls) this.roomWalls.forEach(w => w.destroy());
            this.roomWalls = [];
            if (this.door) { this.door.destroy(); this.door = null; }
            
            // Restore the original room (risk room was cleared, so no risk door will appear)
            this.setupRoom(currentRoom);
            
            // Position player near where risk door was
            this.player.setPosition(700, 450);
            
            // Restore minimap
            this.updateMinimap();
            
            // Fade back in and reset transition flag
            this.cameras.main.fadeIn(200, 0, 0, 0);
            this.isTransitioningRoom = false;
        });
    }
    
    createMinimap() {
        // Create minimap container in bottom-right corner (hidden until map pickup found)
        this.minimapGraphics = this.add.graphics().setDepth(200).setScrollFactor(0);
        this.minimapX = 795;  // Far right edge
        this.minimapY = 595;  // Far bottom edge
        this.minimapRoomSize = 18;  // Slightly smaller rooms
        this.minimapPadding = 2;
        this.hasMap = false;  // Map starts hidden, need pickup to enable
    }
    
    updateMinimap() {
        if (!this.minimapGraphics || !this.roomGrid) return;
        
        this.minimapGraphics.clear();
        
        // Only draw if player has picked up the map and NOT in risk room
        if (!this.hasMap || this.inRiskRoom) return;
        
        const { cols, rows, rooms, currentRoom } = this.roomGrid;
        
        // Background - 50% less opacity (0.35 instead of 0.7)
        const mapWidth = cols * (this.minimapRoomSize + this.minimapPadding) + this.minimapPadding;
        const mapHeight = rows * (this.minimapRoomSize + this.minimapPadding) + this.minimapPadding;
        this.minimapGraphics.fillStyle(0x000000, 0.35);
        this.minimapGraphics.fillRect(this.minimapX - mapWidth - 10, this.minimapY - mapHeight - 10, mapWidth + 20, mapHeight + 20);
        
        // Draw rooms
        rooms.forEach((room, idx) => {
            const x = this.minimapX - mapWidth + this.minimapPadding + room.col * (this.minimapRoomSize + this.minimapPadding);
            const y = this.minimapY - mapHeight + this.minimapPadding + room.row * (this.minimapRoomSize + this.minimapPadding);
            
            // Room color based on state (slightly transparent)
            let color = 0x333333; // Unvisited
            if (room.visited && !room.cleared) color = 0x666666; // Visited but not cleared
            if (room.cleared) color = 0x00aa00; // Cleared
            if (room.isExit) color = room.cleared ? 0x00ff00 : 0xffff00; // Exit
            if (idx === currentRoom) color = 0x00aaff; // Current room
            
            this.minimapGraphics.fillStyle(color, 0.7);
            this.minimapGraphics.fillRect(x, y, this.minimapRoomSize, this.minimapRoomSize);
            
            // Risk room indicator
            if (room.hasRiskRoom && !room.riskRoomCleared) {
                this.minimapGraphics.fillStyle(0xff0000, 0.8);
                this.minimapGraphics.fillCircle(x + this.minimapRoomSize - 4, y + 4, 3);
            }
            
            // Draw connections
            this.minimapGraphics.lineStyle(2, 0x888888, 0.5);
            if (room.connections.east !== null) {
                this.minimapGraphics.moveTo(x + this.minimapRoomSize, y + this.minimapRoomSize / 2);
                this.minimapGraphics.lineTo(x + this.minimapRoomSize + this.minimapPadding, y + this.minimapRoomSize / 2);
                this.minimapGraphics.strokePath();
            }
            if (room.connections.south !== null) {
                this.minimapGraphics.moveTo(x + this.minimapRoomSize / 2, y + this.minimapRoomSize);
                this.minimapGraphics.lineTo(x + this.minimapRoomSize / 2, y + this.minimapRoomSize + this.minimapPadding);
                this.minimapGraphics.strokePath();
            }
        });
    }

    setupMapForLevel(level) {
        if (level === 1) {
            this.add.tileSprite(400, 300, 800, 600, 'floor_grass');
            this.door = this.physics.add.staticSprite(400, 50, 'door');
            this.walls.create(200, 200, 'wall').setScale(1, 4).refreshBody();
            this.walls.create(600, 200, 'wall').setScale(1, 4).refreshBody();
        } else if (level === 2) {
            this.add.tileSprite(400, 300, 800, 600, 'floor_apt');
            this.door = this.physics.add.staticSprite(400, 50, 'door').setTint(0x0000ff);
            this.debrisBlock = this.debris.create(400, 100, 'debris');
            this.walls.create(250, 300, 'wall').setScale(1, 15).refreshBody();
            this.walls.create(550, 300, 'wall').setScale(1, 15).refreshBody();
        } else if (level === 3) {
            this.add.tileSprite(400, 300, 800, 600, 'floor_roof');
            this.door = this.physics.add.staticSprite(400, 50, 'door').setTint(0x00ff00);
        } else if (level === 4) {
            // SEWERS - Dark, tight corridors with toxic spitters
            this.add.tileSprite(400, 300, 800, 600, 'floor_sewer');
            this.door = this.physics.add.staticSprite(750, 300, 'door').setTint(0x00ffff);
            // Sewer pipe walls - narrow corridor maze
            this.walls.create(200, 150, 'wall').setScale(6, 1).refreshBody();
            this.walls.create(600, 150, 'wall').setScale(3, 1).refreshBody();
            this.walls.create(100, 300, 'wall').setScale(1, 4).refreshBody();
            this.walls.create(400, 300, 'wall').setScale(1, 6).refreshBody();
            this.walls.create(200, 450, 'wall').setScale(6, 1).refreshBody();
            this.walls.create(550, 450, 'wall').setScale(4, 1).refreshBody();
            // Water hazard visual (dark area)
            this.add.rectangle(300, 380, 150, 80, 0x003300, 0.5).setDepth(1);
        } else if (level === 5) {
            // HOSPITAL - Open areas, mini boss
            this.add.tileSprite(400, 300, 800, 600, 'floor_hospital');
            this.door = this.physics.add.staticSprite(400, 50, 'door').setTint(0xff00ff);
            // Hospital layout - rooms and corridors
            this.walls.create(150, 200, 'wall').setScale(1, 8).refreshBody();
            this.walls.create(650, 200, 'wall').setScale(1, 8).refreshBody();
            this.walls.create(300, 100, 'wall').setScale(4, 1).refreshBody();
            this.walls.create(500, 100, 'wall').setScale(4, 1).refreshBody();
            this.walls.create(400, 350, 'wall').setScale(8, 1).refreshBody();
        } else if (level === 6) {
            // MALL - Multi-floor combat with balcony enemies
            this.add.tileSprite(400, 300, 800, 600, 'floor_apt'); // Reuse apartment floor for mall
            this.door = this.physics.add.staticSprite(400, 50, 'door').setTint(0xffff00);
            
            // Mall structure - ground floor with upper balcony
            // Ground floor stores (left and right)
            this.walls.create(100, 450, 'wall').setScale(3, 4).refreshBody();
            this.walls.create(700, 450, 'wall').setScale(3, 4).refreshBody();
            
            // Upper floor balcony walls
            this.walls.create(100, 150, 'wall').setScale(4, 1).refreshBody();
            this.walls.create(700, 150, 'wall').setScale(4, 1).refreshBody();
            
            // Central escalator area (narrow paths)
            this.walls.create(300, 250, 'wall').setScale(1, 3).refreshBody();
            this.walls.create(500, 250, 'wall').setScale(1, 3).refreshBody();
            
            // Cover objects (benches, planters)
            this.crates.create(200, 350, 'crate').setScale(0.5).refreshBody().setTint(0x8B4513); // Bench
            this.crates.create(600, 350, 'crate').setScale(0.5).refreshBody().setTint(0x8B4513); // Bench
            this.crates.create(400, 500, 'crate').setScale(0.5).refreshBody().setTint(0x228B22); // Planter
            
            // Visual: Balcony indicator
            this.add.rectangle(400, 100, 600, 80, 0x333333, 0.3).setDepth(1);
            this.add.text(400, 100, "UPPER FLOOR", { fontSize: '14px', fill: '#666' }).setOrigin(0.5).setDepth(2);
        } else if (level === 7) {
            // CEMETERY - Stealth graveyard leading to church boss arena
            this.add.tileSprite(400, 300, 800, 600, 'floor_grass'); // Dark grass
            this.add.rectangle(400, 300, 800, 600, 0x001100, 0.5).setDepth(0); // Dark overlay
            this.door = this.physics.add.staticSprite(-100, -100, 'door'); // No door - boss extraction level
            
            // Graveyard tombstones (cover for stealth)
            const tombPositions = [
                {x: 150, y: 450}, {x: 250, y: 400}, {x: 350, y: 480},
                {x: 450, y: 420}, {x: 550, y: 460}, {x: 650, y: 400},
                {x: 200, y: 300}, {x: 400, y: 320}, {x: 600, y: 280}
            ];
            tombPositions.forEach(pos => {
                const tomb = this.walls.create(pos.x, pos.y, 'wall');
                tomb.setScale(0.5, 1).refreshBody();
                tomb.setTint(0x555555); // Gray tombstone
            });
            
            // Church entrance walls
            this.walls.create(200, 100, 'wall').setScale(4, 1).refreshBody();
            this.walls.create(600, 100, 'wall').setScale(4, 1).refreshBody();
            this.walls.create(100, 150, 'wall').setScale(1, 3).refreshBody();
            this.walls.create(700, 150, 'wall').setScale(1, 3).refreshBody();
            
            // Church interior visual
            this.add.rectangle(400, 100, 400, 150, 0x222222, 0.5).setDepth(1);
            this.add.text(400, 50, "CHURCH", { fontSize: '18px', fill: '#555' }).setOrigin(0.5).setDepth(2);
            
            // Moonlight patches (detection zones - visual only, stealth handles mechanics)
            this.add.circle(300, 380, 40, 0xffffcc, 0.1).setDepth(1);
            this.add.circle(500, 350, 50, 0xffffcc, 0.1).setDepth(1);
        }
    }

    spawnLevelEntities(level) {
        let loot = [], cratePos = [];
        if (level === 1) {
            loot = ['key', 'flashlight', 'shotgun', 'ammo', 'ammo', 'helmet', 'vest', 'scrap'];
            cratePos = [{x:100,y:100}, {x:700,y:500}, {x:50,y:300}, {x:750,y:300}, {x:400,y:400}, {x:200,y:50}, {x:600,y:50}, {x:400,y:500}];
            this.spawnEnemy('walker', 100, 300);
            this.spawnEnemy('bandit', 700, 300);
            this.spawnEnemy('leaper', 200, 200);
        } else if (level === 2) {
            loot = ['molotov', 'shotgun', 'ammo', 'ammo', 'scrap', 'helmet', 'vest', 'plug'];
            cratePos = [{x:100,y:100}, {x:100,y:500}, {x:700,y:100}, {x:700,y:500}, {x:400,y:300}, {x:50,y:250}, {x:750,y:250}, {x:200,y:550}, {x:400,y:550}, {x:600,y:400}];
            this.spawnEnemy('bandit', 100, 100);
            this.spawnEnemy('bandit', 700, 100);
            this.spawnEnemy('leaper', 400, 450);
            this.spawnEnemy('leaper', 400, 150);
        } else if (level === 3) {
            loot = ['key', 'ammo', 'ammo', 'meds', 'meds', 'scrap', 'grenade'];
            cratePos = [{x:100,y:100}, {x:700,y:100}, {x:100,y:500}, {x:700,y:500}, {x:400,y:300}, {x:50,y:300}, {x:750,y:300}];
            this.spawnEnemy('walker', 400, 100);
            this.spawnEnemy('walker', 200, 300);
            this.spawnEnemy('spitter', 600, 300);
            this.spawnEnemy('bandit', 100, 500);
            this.spawnEnemy('bandit', 700, 500);
        } else if (level === 4) {
            // SEWERS - Spitter-heavy with tight corridors
            loot = ['key', 'smg', 'ammo', 'ammo', 'ammo', 'grenade', 'grenade', 'meds', 'scrap', 'plug'];
            cratePos = [{x:50,y:80}, {x:700,y:80}, {x:50,y:520}, {x:700,y:520}, {x:250,y:220}, {x:550,y:220}, {x:250,y:380}, {x:650,y:380}, {x:500,y:550}, {x:150,y:550}];
            // Spitters in the sewers
            this.spawnEnemy('spitter', 300, 250);
            this.spawnEnemy('spitter', 500, 250);
            this.spawnEnemy('spitter', 200, 500);
            // Walkers emerging from pipes
            this.spawnEnemy('walker', 100, 200);
            this.spawnEnemy('walker', 650, 500);
            this.spawnEnemy('leaper', 400, 200);
        } else if (level === 5) {
            // HOSPITAL - Boss fight
            loot = ['ammo', 'ammo', 'ammo', 'meds', 'meds', 'grenade', 'scrap', 'extended_mag'];
            cratePos = [{x:100,y:450}, {x:700,y:450}, {x:100,y:550}, {x:700,y:550}, {x:300,y:550}, {x:500,y:550}, {x:250,y:250}, {x:550,y:250}];
            // Hospital Boss
            this.spawnEnemy('boss', 400, 150);
            this.bossBar.setVisible(true);
            this.bossText.setVisible(true);
            this.bossText.setText("PATIENT ZERO");
            this.updateBossBar(CONFIG.ENEMIES.BOSS.HP, CONFIG.ENEMIES.BOSS.HP);
            // Boss entrance roar
            this.time.delayedCall(500, () => sfx.bossRoar());
            // Support enemies
            this.spawnEnemy('spitter', 200, 200);
            this.spawnEnemy('spitter', 600, 200);
            this.spawnEnemy('walker', 100, 400);
            this.spawnEnemy('walker', 700, 400);
        } else if (level === 6) {
            // MALL - Multi-floor combat with exploders
            loot = ['key', 'rifle', 'ammo', 'ammo', 'ammo', 'meds', 'grenade', 'grenade', 'suppressor', 'rapid_fire'];
            cratePos = [
                {x:100,y:550}, {x:700,y:550}, {x:100,y:350}, {x:700,y:350},
                {x:250,y:150}, {x:550,y:150}, {x:400,y:450}, {x:150,y:200},
                {x:650,y:200}, {x:400,y:250}
            ];
            
            // Ground floor enemies
            this.spawnEnemy('exploder', 150, 400);
            this.spawnEnemy('exploder', 650, 400);
            this.spawnEnemy('walker', 300, 500);
            this.spawnEnemy('walker', 500, 500);
            
            // Upper floor bandits (shooting down)
            this.spawnEnemy('bandit', 200, 100);
            this.spawnEnemy('bandit', 600, 100);
            
            // Spitters in strategic positions
            this.spawnEnemy('spitter', 400, 200);
            
            // Store spawn waves (delayed)
            this.time.delayedCall(5000, () => {
                if (this.currentLevel === 6) {
                    this.showFloatingText(100, 400, "STORE BREACH!", 0xff0000);
                    this.spawnEnemy('exploder', 80, 450);
                    this.spawnEnemy('walker', 80, 480);
                }
            });
            this.time.delayedCall(10000, () => {
                if (this.currentLevel === 6) {
                    this.showFloatingText(700, 400, "STORE BREACH!", 0xff0000);
                    this.spawnEnemy('exploder', 720, 450);
                    this.spawnEnemy('walker', 720, 480);
                }
            });
        } else if (level === 7) {
            // CEMETERY - Stealth section + Necromancer boss
            loot = ['key', 'crossbow', 'ammo', 'ammo', 'meds', 'meds', 'laser_sight', 'damage_barrel', 'materials'];
            cratePos = [
                {x:100,y:550}, {x:700,y:550}, {x:200,y:350}, {x:600,y:350},
                {x:150,y:250}, {x:650,y:250}, {x:400,y:400}, {x:300,y:500},
                {x:500,y:500}
            ];
            
            // Initialize stealth system for this level
            this.isStealthLevel = true;
            this.detectionMeter = 0;
            this.maxDetection = 100;
            this.detectionRate = 20; // Per second when spotted
            this.detectionDecay = 10; // Per second when hidden
            this.stealthAlerted = false;
            
            // Create detection UI
            this.detectionBar = this.add.graphics().setDepth(150);
            this.detectionText = this.add.text(400, 40, "STEALTH", { fontSize: '16px', fill: '#fff' }).setOrigin(0.5).setDepth(150);
            
            // Graveyard patrol enemies (stealth section)
            this.patrolEnemies = [];
            const patrol1 = this.spawnPatrolEnemy('walker', 200, 400, [{x:200,y:400}, {x:200,y:300}, {x:300,y:300}, {x:300,y:400}]);
            const patrol2 = this.spawnPatrolEnemy('walker', 500, 350, [{x:500,y:350}, {x:600,y:350}, {x:600,y:450}, {x:500,y:450}]);
            const patrol3 = this.spawnPatrolEnemy('walker', 350, 450, [{x:350,y:450}, {x:450,y:450}]);
            
            // Necromancer boss in church area
            this.spawnEnemy('necromancer', 400, 80);
            this.bossBar.setVisible(true);
            this.bossText.setVisible(true);
            this.bossText.setText("THE NECROMANCER");
            this.updateBossBar(CONFIG.ENEMIES.NECROMANCER.HP, CONFIG.ENEMIES.NECROMANCER.HP);
            // Boss entrance
            this.time.delayedCall(500, () => sfx.necroSummon());
        }
        Phaser.Utils.Array.Shuffle(loot);
        cratePos.forEach((p, i) => {
            if (i < loot.length) this.crates.create(p.x, p.y, 'crate').setScale(0.5).refreshBody().setData('lootID', loot[i]);
        });
    }

    spawnEnemy(type, x, y) {
        this.enemies.add(new Enemy(this, x, y, this.player, type));
    }
    
    spawnPatrolEnemy(type, x, y, waypoints) {
        const enemy = new Enemy(this, x, y, this.player, type);
        enemy.isPatrol = true;
        enemy.waypoints = waypoints;
        enemy.currentWaypoint = 0;
        enemy.patrolSpeed = 30; // Slower patrol speed
        enemy.visionRange = 150;
        enemy.visionAngle = Math.PI / 3; // 60 degree cone
        this.enemies.add(enemy);
        if (!this.patrolEnemies) this.patrolEnemies = [];
        this.patrolEnemies.push(enemy);
        return enemy;
    }
    
    updatePatrolEnemies(time, delta) {
        if (!this.patrolEnemies) return;
        
        this.patrolEnemies.forEach(enemy => {
            if (!enemy.active || !enemy.isPatrol) return;
            
            // If alerted, chase player instead of patrolling
            if (this.stealthAlerted) {
                enemy.isPatrol = false;
                return;
            }
            
            // Move to current waypoint
            const wp = enemy.waypoints[enemy.currentWaypoint];
            const dist = Phaser.Math.Distance.Between(enemy.x, enemy.y, wp.x, wp.y);
            
            if (dist < 10) {
                // Reached waypoint, move to next
                enemy.currentWaypoint = (enemy.currentWaypoint + 1) % enemy.waypoints.length;
            } else {
                // Move toward waypoint
                this.physics.moveToObject(enemy, wp, enemy.patrolSpeed);
            }
        });
    }
    
    updateStealthMechanics(time, delta) {
        let isDetected = false;
        
        // Check if any patrol enemy can see the player
        if (this.patrolEnemies) {
            this.patrolEnemies.forEach(enemy => {
                if (!enemy.active) return;
                
                const dist = Phaser.Math.Distance.Between(enemy.x, enemy.y, this.player.x, this.player.y);
                // Shadow Step skill: -25% enemy detection range
                const effectiveVisionRange = enemy.visionRange * (1 - (this.shadowStepReduction || 0));
                if (dist > effectiveVisionRange) return;
                
                // Check vision cone
                const angleToPlayer = Phaser.Math.Angle.Between(enemy.x, enemy.y, this.player.x, this.player.y);
                const enemyFacing = Math.atan2(enemy.body.velocity.y, enemy.body.velocity.x);
                let angleDiff = Math.abs(angleToPlayer - enemyFacing);
                if (angleDiff > Math.PI) angleDiff = Math.PI * 2 - angleDiff;
                
                if (angleDiff < enemy.visionAngle) {
                    // Player is in vision cone - check line of sight (simplified)
                    isDetected = true;
                }
            });
        }
        
        // Update detection meter
        const deltaSeconds = delta / 1000;
        if (isDetected) {
            this.detectionMeter += this.detectionRate * deltaSeconds;
            // Play ping sound periodically
            if (Math.floor(this.detectionMeter / 25) !== Math.floor((this.detectionMeter - this.detectionRate * deltaSeconds) / 25)) {
                sfx.detectionPing();
            }
        } else {
            // Ghost skill: Faster detection decay (multiplier)
            const decayRate = this.detectionDecay * (this.ghostDecayMultiplier || 1);
            this.detectionMeter -= decayRate * deltaSeconds;
        }
        this.detectionMeter = Phaser.Math.Clamp(this.detectionMeter, 0, this.maxDetection);
        
        // Update detection UI
        if (this.detectionBar) {
            this.detectionBar.clear();
            // Background
            this.detectionBar.fillStyle(0x333333);
            this.detectionBar.fillRect(300, 55, 200, 15);
            // Fill based on detection
            const fillColor = this.detectionMeter < 50 ? 0x00ff00 : (this.detectionMeter < 80 ? 0xffff00 : 0xff0000);
            this.detectionBar.fillStyle(fillColor);
            this.detectionBar.fillRect(300, 55, 200 * (this.detectionMeter / this.maxDetection), 15);
            // Border
            this.detectionBar.lineStyle(2, 0xffffff);
            this.detectionBar.strokeRect(300, 55, 200, 15);
        }
        
        // Check for full detection
        if (this.detectionMeter >= this.maxDetection && !this.stealthAlerted) {
            this.triggerStealthAlert();
        }
    }
    
    triggerStealthAlert() {
        this.stealthAlerted = true;
        sfx.detectionMax();
        this.showFloatingText(400, 200, "DETECTED!", 0xff0000);
        
        // Update detection text
        if (this.detectionText) {
            this.detectionText.setText("ALERTED!");
            this.detectionText.setColor('#ff0000');
        }
        
        // All patrol enemies become aggressive
        if (this.patrolEnemies) {
            this.patrolEnemies.forEach(enemy => {
                if (enemy.active) {
                    enemy.isPatrol = false;
                }
            });
        }
        
        // Spawn reinforcement horde
        this.showFloatingText(400, 300, "HORDE INCOMING!", 0xff0000);
        this.time.delayedCall(500, () => {
            this.spawnEnemy('walker', 100, 500);
            this.spawnEnemy('walker', 700, 500);
            this.spawnEnemy('walker', 200, 550);
            this.spawnEnemy('walker', 600, 550);
            this.spawnEnemy('leaper', 400, 580);
        });
    }
    
    // Check if player is in shadow (behind tombstone/cover)
    isPlayerInShadow() {
        // Simplified: player is "in shadow" if near a wall/tombstone
        let inShadow = false;
        this.walls.getChildren().forEach(wall => {
            const dist = Phaser.Math.Distance.Between(this.player.x, this.player.y, wall.x, wall.y);
            if (dist < 50) inShadow = true;
        });
        return inShadow;
    }

    spawnSwitch(x, y) {
        this.switches.create(x, y, 'switch');
        this.showFloatingText(x, y, "BOSS DEAD! HIT THE SWITCH!", 0x00ff00);
        this.switchDropped = true;
        this.bossBar.setVisible(false);
        this.bossText.setVisible(false);
    }

    activateExtraction() {
        if (this.extractionActive) return;
        this.extractionActive = true;
        sfx.extractionStart();
        this.tweens.add({ targets: this.darkness, alpha: 0.2, duration: 500, yoyo: true, repeat: -1 });
        this.showFloatingText(400, 300, "BEACON ONLINE! SURVIVE 15s!", 0xff0000);
        this.spawnEnemy('bandit', 100, 100);
        this.spawnEnemy('bandit', 700, 100);
        this.spawnEnemy('leaper', 400, 500);
        this.spawnEnemy('leaper', 100, 500);
        this.extractionTimerEvent = this.time.addEvent({
            delay: 1000,
            callback: () => {
                this.extractionTimer--;
                sfx.extractionTick();
                if (this.extractionTimer <= 0) this.winGame();
            },
            repeat: 14
        });
        this.activeTimerEvents.push(this.extractionTimerEvent);
    }

    cleanupTimerEvents() {
        this.activeTimerEvents.forEach(event => {
            if (event) this.time.removeEvent(event);
        });
        this.activeTimerEvents = [];
        if (this.extractionTimerEvent) {
            this.time.removeEvent(this.extractionTimerEvent);
            this.extractionTimerEvent = null;
        }
        this.cancelReload();
    }

    update(time, delta) {
        // Skip all updates during level transitions
        if (this.isTransitioning) return;
        
        // Input handling (works even when paused for menu/inventory)
        if (Phaser.Input.Keyboard.JustDown(this.keys.tab) || Phaser.Input.Keyboard.JustDown(this.keys.inv)) {
            this.toggleInventory();
        }
        if (Phaser.Input.Keyboard.JustDown(this.keys.esc)) {
            if (this.isInventoryOpen) this.toggleInventory();
            else this.togglePause();
        }

        if (Phaser.Input.Keyboard.JustDown(this.keys.nvg)) {
            if (this.playerStats.hideout.armory.hasNVG) {
                sfx.toggleNVG();
                this.nvgOn = !this.nvgOn;
                if (this.nvgOn) {
                    this.darkness.setVisible(false);
                    this.nvgLayer.setVisible(true);
                    this.cameras.main.setBackgroundColor(0x002200);
                } else {
                    this.darkness.setVisible(true);
                    this.nvgLayer.setVisible(false);
                    this.cameras.main.setBackgroundColor(0x000000);
                }
            } else {
                this.showFloatingText(this.player.x, this.player.y - 40, "NO NVG EQUIPPED", 0xffffff);
            }
        }

        // Laser sight toggle (L key)
        if (Phaser.Input.Keyboard.JustDown(this.keys.laser)) {
            this.laserEnabled = !this.laserEnabled;
            sfx.click();
            this.showFloatingText(this.player.x, this.player.y - 40, this.laserEnabled ? "LASER ON" : "LASER OFF", 0xff0000);
        }

        if (this.isPaused) return;

        this.drawUI();
        this.drawVignette();
        this.drawLaserSight();
        this.enemies.getChildren().forEach(e => e.update(time, delta));
        
        // Update stealth mechanics for Cemetery level
        if (this.isStealthLevel && !this.stealthAlerted) {
            this.updateStealthMechanics(time, delta);
        }
        
        // Update patrol enemies
        if (this.patrolEnemies) {
            this.updatePatrolEnemies(time, delta);
        }
        
        // Update risk room exit label when enemies cleared
        if (this.inRiskRoom && this.riskRoomExitLabel && this.enemies.countActive() === 0) {
            if (this.riskRoomExitLabel.text !== 'üö™ EXIT READY!') {
                this.riskRoomExitLabel.setText('üö™ EXIT READY!');
                this.riskRoomExitLabel.setFill('#00ff00');
                this.showFloatingText(400, 300, "ROOM CLEARED! Exit when ready.", 0x00ff00);
            }
        }

        // Update lighting (with safety check for scene transitions)
        if (this.lightShape && this.lightShape.scene) {
            this.lightShape.clear();
            this.lightShape.fillCircle(this.player.x, this.player.y, CONFIG.PLAYER.LIGHT_RADIUS);
            if (this.playerStats.hasFlashlight) {
                const angle = Phaser.Math.Angle.Between(this.player.x, this.player.y, this.input.activePointer.x, this.input.activePointer.y);
                this.lightShape.fillStyle(0xffffff);
                this.lightShape.slice(this.player.x, this.player.y, CONFIG.PLAYER.FLASHLIGHT_RANGE, angle - CONFIG.PLAYER.FLASHLIGHT_ANGLE, angle + CONFIG.PLAYER.FLASHLIGHT_ANGLE);
                this.lightShape.fill();
            }
        }

        // Auto-recover if pinned enemy dies
        if (this.isPinned) {
            if (!this.pinnedBy || !this.pinnedBy.active) {
                this.recoverFromKnockdown();
            } else {
                this.pinnedBy.setPosition(this.player.x, this.player.y);
                if (Phaser.Input.Keyboard.JustDown(this.keys.space)) this.recoverFromKnockdown();
            }
            return;
        }

        // Dodge roll (SPACE when not pinned)
        if (Phaser.Input.Keyboard.JustDown(this.keys.space) && !this.isDodging) {
            this.performDodgeRoll();
        }
        
        // Reload (R key)
        if (Phaser.Input.Keyboard.JustDown(this.keys.reload)) {
            this.startReload();
        }
        
        // Grenade (G key)
        if (Phaser.Input.Keyboard.JustDown(this.keys.grenade)) {
            this.throwGrenade();
        }
        
        // Consumables (1, 2, 3 keys)
        if (Phaser.Input.Keyboard.JustDown(this.keys.consumable1)) {
            this.useConsumable(0);
        }
        if (Phaser.Input.Keyboard.JustDown(this.keys.consumable2)) {
            this.useConsumable(1);
        }
        if (Phaser.Input.Keyboard.JustDown(this.keys.consumable3)) {
            this.useConsumable(2);
        }

        if (!this.isOpening && !this.debrisBurning && !this.isDodging) {
            this.player.setVelocity(0);
            let speed = CONFIG.PLAYER.WALK_SPEED * this.speedMultiplier;

            if ((this.cursors.shift.isDown || this.wasd.SHIFT.isDown) && this.playerStats.stamina > 0) {
                speed = CONFIG.PLAYER.SPRINT_SPEED * this.speedMultiplier;
                this.playerStats.stamina -= CONFIG.PLAYER.STAMINA_DRAIN;
            } else if (this.playerStats.stamina < this.playerStats.maxStamina) {
                this.playerStats.stamina += CONFIG.PLAYER.STAMINA_REGEN;
            }

            let vx = 0, vy = 0;
            if (this.cursors.left.isDown || this.wasd.A.isDown) vx = -1;
            else if (this.cursors.right.isDown || this.wasd.D.isDown) vx = 1;
            if (this.cursors.up.isDown || this.wasd.W.isDown) vy = -1;
            else if (this.cursors.down.isDown || this.wasd.S.isDown) vy = 1;

            if (vx !== 0 || vy !== 0) {
                const len = Math.sqrt(vx * vx + vy * vy);
                this.player.setVelocity((vx / len) * speed, (vy / len) * speed);
                // Footstep sounds (silent for Scout class)
                if (!this.silentFootsteps) {
                    sfx.footstep(this.time.now, speed === CONFIG.PLAYER.SPRINT_SPEED);
                }
            }

            if (Phaser.Input.Keyboard.JustDown(this.keys.melee)) this.meleeAttack();
            if (Phaser.Input.Keyboard.JustDown(this.keys.switch)) this.switchWeapon();
            if (Phaser.Input.Keyboard.JustDown(this.keys.interact)) {
                if (this.currentLevel === 2 && this.checkDebris()) return;
                if ((this.currentLevel === 5 || this.currentLevel === 7) && this.checkSwitch()) return;
                if (this.checkDoor()) return;
                this.tryInteract();
            }
        } else if (!this.isDodging) {
            this.player.setVelocity(0);
            if (this.openTimerEvent) {
                const p = this.openTimerEvent.getProgress();
                this.uiGraphics.fillStyle(this.debrisBurning ? 0xff4500 : 0xffff00, 1);
                this.uiGraphics.fillRect(this.player.x - 20, this.player.y - 30, 40 * p, 6);
            }
        }
    }

    switchWeapon(direction = 1) {
        this.cancelReload(); // Cancel reload when switching
        
        const weapons = ['pistol'];
        if (this.playerStats.hasShotgun) weapons.push('shotgun');
        if (this.playerStats.hasSMG) weapons.push('smg');
        if (this.playerStats.hasCrossbow) weapons.push('crossbow');
        if (this.playerStats.hasRifle) weapons.push('rifle');
        
        if (weapons.length === 1) return;
        
        const currentIdx = weapons.indexOf(this.playerStats.currentWeapon);
        // direction: 1 = next, -1 = previous
        let nextIdx = currentIdx + direction;
        if (nextIdx < 0) nextIdx = weapons.length - 1;
        if (nextIdx >= weapons.length) nextIdx = 0;
        this.playerStats.currentWeapon = weapons[nextIdx];
        
        this.showFloatingText(this.player.x, this.player.y - 40, this.playerStats.currentWeapon.toUpperCase(), 0xffffff);
        sfx.reload();
    }

    meleeAttack() {
        if (this.isMeleeAttacking) return;
        this.isMeleeAttacking = true;
        this.cancelReload();
        sfx.melee();

        const slash = this.add.sprite(this.player.x, this.player.y, 'slash').setTint(0xffffff).setDepth(20);
        const angle = Phaser.Math.Angle.Between(this.player.x, this.player.y, this.input.activePointer.x, this.input.activePointer.y);
        slash.setRotation(angle);
        const vec = this.physics.velocityFromRotation(angle, 40);
        slash.setPosition(this.player.x + vec.x, this.player.y + vec.y);

        this.tweens.add({ targets: slash, alpha: 0, duration: 200, onComplete: () => slash.destroy() });

        // Calculate melee damage with permanent boost
        let meleeDamage = CONFIG.PLAYER.MELEE_DAMAGE;
        if (this.permanentDamageBoost > 1) {
            meleeDamage = Math.ceil(meleeDamage * this.permanentDamageBoost);
        }
        // Apply Last Stand skill (+50% damage when below 25% HP)
        if (this.lastStandBonus > 0 && this.playerStats.hp / this.playerStats.maxHp <= this.lastStandThreshold) {
            meleeDamage = Math.ceil(meleeDamage * (1 + this.lastStandBonus));
        }
        
        this.enemies.getChildren().forEach(e => {
            if (e.active && Phaser.Math.Distance.Between(slash.x, slash.y, e.x, e.y) < CONFIG.PLAYER.MELEE_RANGE) {
                if (e.enemyType === 'boss') {
                    if (!e.isInvulnerable) e.takeDamage(meleeDamage, 'melee');
                } else if (e.takeDamage) {
                    e.takeDamage(meleeDamage, 'melee');
                }
            }
        });

        this.time.delayedCall(CONFIG.PLAYER.MELEE_COOLDOWN, () => { this.isMeleeAttacking = false; });
    }

    fireBullet(pointer) {
        if (this.isOpening || this.isPaused || this.isInventoryOpen || this.isReloading || this.isDodging) return;

        const weapon = this.playerStats.currentWeapon;
        const wpnConfig = CONFIG.WEAPONS[weapon.toUpperCase()];
        const currentMag = this.playerStats.magazines[weapon];
        
        // Check magazine
        if (currentMag <= 0) {
            sfx.empty();
            // Auto-reload when empty
            this.startReload();
            return;
        }
        
        // Check ammo cost
        if (weapon === 'shotgun' && currentMag < wpnConfig.AMMO_COST) {
            sfx.empty();
            this.startReload();
            return;
        }

        const now = this.time.now;
        const angle = Phaser.Math.Angle.Between(this.player.x, this.player.y, pointer.x, pointer.y);
        
        // Get mod effects for current weapon
        const modEffects = this.weaponModEffects?.[weapon] || { 
            fireRateMultiplier: 1, damageMultiplier: 1, spreadMultiplier: 1, isSilent: false 
        };
        // Calculate effective fire rate (lower multiplier = faster, but we use it as divisor)
        // Positive fireRate bonus = faster shots, so we divide by (1 + bonus)
        // Negative fireRate (from damage barrel) = slower shots
        const effectiveFireRate = Math.max(50, wpnConfig.FIRE_RATE / Math.max(0.5, 1 + modEffects.fireRateMultiplier - 1));

        if (weapon === 'shotgun') {
            if (now - this.lastFired < effectiveFireRate) return;

            if (!modEffects.isSilent) sfx.shootShotgun();
            if (!modEffects.isSilent) this.particles.spawnMuzzleFlash(this.player.x, this.player.y, angle, 1.5, this.muzzleFlashColor);
            
            let pelletsShot = 0;
            const spreadMod = modEffects.spreadMultiplier;
            for (let i = -10; i <= 10; i += wpnConfig.SPREAD_STEP) {
                const b = this.bullets.get(this.player.x, this.player.y);
                if (b) { 
                    b.fire(this.player.x, this.player.y, pointer.x, pointer.y, Math.round(i * spreadMod), false); 
                    b.modDamageMultiplier = modEffects.damageMultiplier;
                    b.isSilent = modEffects.isSilent;
                    pelletsShot++; 
                }
            }
            this.playerStats.magazines[weapon] -= wpnConfig.AMMO_COST;
            this.lastFired = now;
            if (this.gameSettings.screenShake) this.cameras.main.shake(100, 0.005);
            // Track shots (count as 1 shot for shotgun, not per pellet)
            this.persistent.runShotsFired++;
            this.persistent.totalShotsFired++;
        } else if (weapon === 'smg') {
            if (now - this.lastFired < effectiveFireRate) return;

            if (!modEffects.isSilent) sfx.shootSMG();
            if (!modEffects.isSilent) this.particles.spawnMuzzleFlash(this.player.x, this.player.y, angle, 0.6, this.muzzleFlashColor);
            
            const smgSpread = Math.round(wpnConfig.SPREAD * modEffects.spreadMultiplier);
            const spread = Phaser.Math.Between(-smgSpread, smgSpread);
            const b = this.bullets.get(this.player.x, this.player.y);
            if (b) {
                b.fire(this.player.x, this.player.y, pointer.x, pointer.y, spread, false);
                b.modDamageMultiplier = modEffects.damageMultiplier;
                b.isSilent = modEffects.isSilent;
            }
            this.playerStats.magazines[weapon] -= wpnConfig.AMMO_COST;
            this.lastFired = now;
            // Track shots
            this.persistent.runShotsFired++;
            this.persistent.totalShotsFired++;
        } else if (weapon === 'crossbow') {
            // Crossbow - Silent, piercing, high damage
            if (now - this.lastFired < effectiveFireRate) return;

            sfx.shootCrossbow();
            // No muzzle flash for crossbow - it's silent
            
            const b = this.bullets.get(this.player.x, this.player.y);
            if (b) {
                b.fire(this.player.x, this.player.y, pointer.x, pointer.y, 0, false);
                b.setTint(0x8B4513); // Brown bolt color
                b.isPiercing = true; // Mark as piercing
                b.isSilent = true;   // Mark as silent (won't aggro enemies)
                b.crossbowDamage = wpnConfig.DAMAGE; // Store crossbow's high damage
                b.modDamageMultiplier = modEffects.damageMultiplier;
            }
            this.playerStats.magazines[weapon] -= wpnConfig.AMMO_COST;
            this.lastFired = now;
            // Track shots
            this.persistent.runShotsFired++;
            this.persistent.totalShotsFired++;
            // Auto-reload since mag size is 1
            this.startReload();
        } else if (weapon === 'rifle') {
            // Assault Rifle - Accurate, medium fire rate
            if (now - this.lastFired < effectiveFireRate) return;

            if (!modEffects.isSilent) sfx.shootRifle();
            if (!modEffects.isSilent) this.particles.spawnMuzzleFlash(this.player.x, this.player.y, angle, 1.2, this.muzzleFlashColor);
            
            // First shot accuracy bonus when stationary
            const rifleSpread = Math.round(wpnConfig.SPREAD * modEffects.spreadMultiplier);
            let spread = Phaser.Math.Between(-rifleSpread, rifleSpread);
            if (wpnConfig.FIRST_SHOT_BONUS && this.player.body.velocity.length() < 10) {
                spread = 0; // Perfect accuracy when stationary
            }
            
            const b = this.bullets.get(this.player.x, this.player.y);
            if (b) {
                b.fire(this.player.x, this.player.y, pointer.x, pointer.y, spread, false);
                b.rifleDamage = wpnConfig.DAMAGE; // Store rifle's damage multiplier
                b.modDamageMultiplier = modEffects.damageMultiplier;
                b.isSilent = modEffects.isSilent;
            }
            this.playerStats.magazines[weapon] -= wpnConfig.AMMO_COST;
            this.lastFired = now;
            // Track shots
            this.persistent.runShotsFired++;
            this.persistent.totalShotsFired++;
        } else {
            // Pistol
            if (now - this.lastFired < effectiveFireRate) return;

            if (!modEffects.isSilent) sfx.shootPistol();
            if (!modEffects.isSilent) this.particles.spawnMuzzleFlash(this.player.x, this.player.y, angle, 1, this.muzzleFlashColor);
            
            const pistolSpread = Math.round(wpnConfig.SPREAD * modEffects.spreadMultiplier);
            const b = this.bullets.get(this.player.x, this.player.y);
            if (b) {
                b.fire(this.player.x, this.player.y, pointer.x, pointer.y, pistolSpread, false);
                b.modDamageMultiplier = modEffects.damageMultiplier;
                b.isSilent = modEffects.isSilent;
            }
            this.playerStats.magazines[weapon] -= wpnConfig.AMMO_COST;
            this.lastFired = now;
            // Track shots
            this.persistent.runShotsFired++;
            this.persistent.totalShotsFired++;
        }
    }

    hitPlayer(damage, fromX = null, fromY = null) {
        if (this.player.alpha < 1 || this.isPinned || this.isDodging) return;

        // Apply skill damage reduction (Thick Skin / Iron Will)
        if (this.skillDamageReduction > 0) {
            damage = Math.max(1, Math.ceil(damage * (1 - this.skillDamageReduction)));
        }

        // Track damage for stats
        this.persistent.runDamageTaken += damage;
        this.levelDamageTaken += damage;
        
        // Show hit direction indicator if we have source position
        if (fromX !== null && fromY !== null) {
            this.hitIndicators.showHit(fromX, fromY, this.player.x, this.player.y);
        }

        let mitigated = false;
        const slots = ['body', 'head', 'arms', 'feet'];

        for (let slot of slots) {
            if (this.playerStats.armor[slot] && this.playerStats.armor[slot].durability > 0) {
                this.playerStats.armor[slot].durability--;
                this.showFloatingText(this.player.x, this.player.y - 20, "BLOCKED!", 0x00ffff);
                if (this.playerStats.armor[slot].durability <= 0) {
                    this.playerStats.armor[slot] = null;
                    this.showFloatingText(this.player.x, this.player.y - 40, "ARMOR BROKE!", 0xff0000);
                }
                mitigated = true;
                break;
            }
        }

        if (!mitigated) {
            sfx.playerHurt();
            this.playerStats.hp -= damage;
            if (this.gameSettings.screenShake) {
                this.cameras.main.shake(100, 0.01);
            }
            this.player.setAlpha(0.5);
            this.player.setTint(0xff0000);
            this.time.delayedCall(100, () => { if (this.player.active) this.player.clearTint(); });
            this.time.delayedCall(CONFIG.PLAYER.INVULN_TIME, () => this.player.setAlpha(1));
        }

        if (this.playerStats.hp <= 0) {
            this.handlePlayerDeath();
        }
    }

    handlePlayerDeath() {
        if (this.isTransitioning) return;
        
        // Second Wind skill: Survive one lethal hit per run
        if (this.hasSkill('second_wind') && !this.persistent.secondWindUsed) {
            this.persistent.secondWindUsed = true;
            this.playerStats.hp = 1;
            savePersistent(this.persistent);
            
            // Visual feedback
            sfx.success();
            this.showFloatingText(this.player.x, this.player.y - 50, "SECOND WIND!", 0xffff00);
            this.cameras.main.flash(200, 255, 255, 0);
            
            // Brief invulnerability
            this.player.setAlpha(0.5);
            this.time.delayedCall(2000, () => {
                if (this.player.active) this.player.setAlpha(1);
            });
            return; // Don't die
        }
        
        this.isTransitioning = true;
        this.cleanupTimerEvents();
        
        // Track death
        this.persistent.totalDeaths++;
        savePersistent(this.persistent);
        
        sfx.playerDeath();
        this.showFloatingText(400, 300, "YOU DIED", 0xff0000);
        this.physics.pause();
        
        this.time.delayedCall(CONFIG.TIMINGS.DEATH_RESTART, () => {
            this.scene.restart({ level: this.currentLevel, stats: this.checkpointStats });
        });
    }

    triggerKnockdown(leaper) {
        if (this.isPinned || this.isDodging) return;
        this.isPinned = true;
        this.pinnedBy = leaper;
        this.player.setVelocity(0);
        leaper.setVelocity(0);
        leaper.state = 'PINNING';
        this.player.setTint(0x0000ff);
        this.showFloatingText(this.player.x, this.player.y - 50, "PRESS SPACE!", 0xff0000);
        this.cancelReload();
    }

    recoverFromKnockdown() {
        this.isPinned = false;
        this.player.clearTint();
        if (this.pinnedBy && this.pinnedBy.active && this.pinnedBy.body) {
            this.pinnedBy.knockBack();
        }
        this.pinnedBy = null;
    }

    checkDebris() {
        if (this.debrisBlock && this.debrisBlock.active &&
            Phaser.Math.Distance.Between(this.player.x, this.player.y, this.debrisBlock.x, this.debrisBlock.y) < CONFIG.DISTANCES.DEBRIS) {
            if (this.hasMolotov) this.startBurningDebris();
            else this.showFloatingText(this.debrisBlock.x, this.debrisBlock.y, "Need Molotov!", 0xffffff);
            return true;
        }
        return false;
    }

    startBurningDebris() {
        this.debrisBurning = true;
        this.showFloatingText(this.debrisBlock.x, this.debrisBlock.y, "BURNING!", 0xff4500);
        this.debrisBlock.setTint(0xff4500);
        this.openTimerEvent = this.time.addEvent({
            delay: CONFIG.TIMINGS.DEBRIS_BURN,
            callback: () => {
                this.debrisBurning = false;
                if (this.debrisBlock) this.debrisBlock.destroy();
                this.showFloatingText(this.player.x, this.player.y, "CLEARED!", 0x00ff00);
            }
        });
    }

    checkSwitch() {
        // Extraction switches on boss levels (5 and 7)
        if (this.currentLevel !== 5 && this.currentLevel !== 7) return false;
        const s = this.switches.getFirstAlive();
        if (s && Phaser.Math.Distance.Between(this.player.x, this.player.y, s.x, s.y) < CONFIG.DISTANCES.INTERACT) {
            this.activateExtraction();
            s.destroy();
            return true;
        }
        return false;
    }

    checkDoor() {
        // Check room transition doors first (if using room grid system)
        if (this.roomGrid && this.roomDoors) {
            for (const roomDoor of this.roomDoors) {
                if (Phaser.Math.Distance.Between(this.player.x, this.player.y, roomDoor.x, roomDoor.y) < CONFIG.DISTANCES.DOOR) {
                    this.transitionToRoom(roomDoor.targetRoom);
                    return true;
                }
            }
        }
        
        // Check risk room door
        if (this.riskDoor && !this.inRiskRoom) {
            if (Phaser.Math.Distance.Between(this.player.x, this.player.y, this.riskDoor.x, this.riskDoor.y) < CONFIG.DISTANCES.DOOR) {
                this.enterRiskRoom();
                return true;
            }
        }
        
        // Check for risk room exit door (must be near exit and enemies cleared)
        if (this.inRiskRoom && this.riskRoomExitDoor) {
            if (Phaser.Math.Distance.Between(this.player.x, this.player.y, this.riskRoomExitDoor.x, this.riskRoomExitDoor.y) < CONFIG.DISTANCES.DOOR) {
                if (this.enemies.countActive() === 0) {
                    this.exitRiskRoom();
                    return true;
                } else {
                    this.showFloatingText(this.riskRoomExitDoor.x, this.riskRoomExitDoor.y - 40, "Clear enemies first!", 0xff0000);
                    return true;
                }
            }
        }
        
        // Check main level exit door (in exit room only for room grid system)
        if (this.roomGrid) {
            const currentRoom = this.roomGrid.rooms[this.roomGrid.currentRoom];
            if (!currentRoom.isExit) return false; // Can only use exit door in exit room
        }
        
        if (this.currentLevel === 7) return false; // Cemetery is extraction-only (final level)
        if (Phaser.Math.Distance.Between(this.player.x, this.player.y, this.door.x, this.door.y) < CONFIG.DISTANCES.DOOR) {
            if (this.currentLevel === 1) {
                if (this.hasKey) this.nextLevel();
                else this.showFloatingText(this.door.x, this.door.y - 40, "Need Key!", 0xffffff);
            } else if (this.currentLevel === 2) {
                this.nextLevel();
            } else if (this.currentLevel === 3) {
                if (this.hasKey) this.nextLevel();
                else this.showFloatingText(this.door.x, this.door.y - 40, "Need Key!", 0xffffff);
            } else if (this.currentLevel === 4) {
                if (this.hasKey) this.nextLevel();
                else this.showFloatingText(this.door.x, this.door.y - 40, "Need Key!", 0xffffff);
            } else if (this.currentLevel === 5) {
                // Hospital - need to defeat boss first (switch drops)
                if (this.switchDropped) {
                    this.showFloatingText(this.door.x, this.door.y - 40, "Use switch first!", 0xffffff);
                } else {
                    if (this.hasKey) this.nextLevel();
                    else this.showFloatingText(this.door.x, this.door.y - 40, "Need Key!", 0xffffff);
                }
            } else if (this.currentLevel === 6) {
                // Mall - key required
                if (this.hasKey) this.nextLevel();
                else this.showFloatingText(this.door.x, this.door.y - 40, "Need Key!", 0xffffff);
            }
            return true;
        }
        return false;
    }

    nextLevel() {
        if (this.isTransitioning) return;
        this.isTransitioning = true;
        this.cleanupTimerEvents();
        this.physics.pause();
        
        sfx.levelComplete();
        sfx.doorOpen();
        
        // Track run completion for progression
        this.persistent.runsCompleted = (this.persistent.runsCompleted || 0) + 1;
        
        // Calculate and award skill points
        const skillPointsEarned = this.calculateRunSkillPoints();
        if (skillPointsEarned > 0) {
            this.persistent.skillPoints = (this.persistent.skillPoints || 0) + skillPointsEarned;
            this.persistent.totalSkillPoints = (this.persistent.totalSkillPoints || 0) + skillPointsEarned;
            this.showFloatingText(400, 320, `+${skillPointsEarned} SKILL POINT${skillPointsEarned > 1 ? 'S' : ''}!`, 0xaa66ff);
        }
        
        // ===== CHALLENGE TRACKING =====
        // Weekly extractions
        this.persistent.weeklyExtractions = (this.persistent.weeklyExtractions || 0) + 1;
        
        // Weekly unique levels
        if (!this.persistent.weeklyUniqueLevels) this.persistent.weeklyUniqueLevels = [];
        if (!this.persistent.weeklyUniqueLevels.includes(this.currentLevel)) {
            this.persistent.weeklyUniqueLevels.push(this.currentLevel);
        }
        
        // Perfect level tracking (no damage taken)
        if (this.levelDamageTaken === 0) {
            this.persistent.perfectLevels = (this.persistent.perfectLevels || 0) + 1;
        }
        
        // Update challenge progress
        this.updateChallengeProgress();
        
        // Check for completed challenges
        const completedChallenges = checkChallengeCompletion(this.persistent);
        completedChallenges.forEach(c => {
            if (c.type === 'permanent') {
                this.showFloatingText(400, 350, `CHALLENGE: ${c.name}!`, 0xffd700);
            }
        });
        
        // Check untouchable achievement and Scout unlock (no damage this level)
        if (this.levelDamageTaken === 0) {
            const newAchievements = checkAchievements(this.persistent, { levelCompletedNoDamage: true });
            newAchievements.forEach(a => {
                sfx.achievement();
                this.showFloatingText(400, 200, `${a.icon} ${a.name}!`, 0xffd700);
            });
        }
        
        // Unlock the next level
        if (this.playerStats.highestLevelUnlocked < this.currentLevel + 1) {
            this.playerStats.highestLevelUnlocked = this.currentLevel + 1;
        }
        this.playerStats.nextLevel = this.currentLevel + 1;
        
        // Sync highestLevelUnlocked to persistent for upgrade tracking
        if (this.playerStats.highestLevelUnlocked > (this.persistent.highestLevelUnlocked || 0)) {
            this.persistent.highestLevelUnlocked = this.playerStats.highestLevelUnlocked;
        }
        
        // Check for new permanent upgrades
        const newUpgrades = checkUpgrades(this.persistent);
        newUpgrades.forEach(u => {
            sfx.achievement();
            this.showFloatingText(400, 250, `UPGRADE: ${u.name}!`, 0xffaa00);
        });
        
        savePersistent(this.persistent);
        localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.playerStats));
        
        // Show level complete choice screen
        this.showLevelCompleteChoice();
    }
    
    showLevelCompleteChoice() {
        const LEVEL_NAMES = ['', 'Street', 'Apartment', 'Rooftop', 'Sewers', 'Hospital', 'Mall', 'Cemetery'];
        const currentName = LEVEL_NAMES[this.currentLevel];
        const nextName = LEVEL_NAMES[this.currentLevel + 1] || 'Unknown';
        
        // Flag to prevent double-triggering
        this.levelChoiceMade = false;
        
        const doTransition = (toHideout) => {
            if (this.levelChoiceMade) return;
            this.levelChoiceMade = true;
            sfx.click();
            this.cameras.main.fade(CONFIG.TIMINGS.LEVEL_TRANSITION, 0, 0, 0);
            this.time.delayedCall(CONFIG.TIMINGS.LEVEL_TRANSITION, () => {
                if (toHideout) {
                    this.scene.start('HideoutScene', { stats: this.playerStats });
                } else {
                    this.scene.restart({ level: this.currentLevel + 1, stats: this.playerStats, levelDamageTaken: 0 });
                }
            });
        };
        
        // Create overlay
        const overlay = this.add.rectangle(400, 300, 800, 600, 0x000000, 0.85).setDepth(500);
        
        // Title
        const title = this.add.text(400, 180, 'LEVEL COMPLETE!', { 
            fontSize: '48px', fill: '#00ff00', fontStyle: 'bold' 
        }).setOrigin(0.5).setDepth(501);
        
        // Level transition text
        const transitionText = this.add.text(400, 250, `${currentName} -> ${nextName}`, { 
            fontSize: '24px', fill: '#ffffff' 
        }).setOrigin(0.5).setDepth(501);
        
        // Stats summary
        const statsText = this.add.text(400, 295, 
            `HP: ${this.playerStats.hp}/${this.playerStats.maxHp}  |  Ammo: ${this.playerStats.ammo}  |  Scrap: ${this.playerStats.scrap}`, 
            { fontSize: '16px', fill: '#888888' }
        ).setOrigin(0.5).setDepth(501);
        
        // Skill points info
        const skillPtsText = this.add.text(400, 325, 
            `Skill Points: ${this.persistent.skillPoints || 0}`, 
            { fontSize: '16px', fill: '#aa66ff' }
        ).setOrigin(0.5).setDepth(501);
        
        // Continue button
        const continueBtn = this.add.rectangle(300, 400, 200, 60, 0x008800).setInteractive().setDepth(501);
        const continueTxt = this.add.text(300, 400, 'CONTINUE', { 
            fontSize: '24px', fill: '#ffffff' 
        }).setOrigin(0.5).setDepth(502);
        
        continueBtn.on('pointerover', () => { if (!this.levelChoiceMade) continueBtn.setFillStyle(0x00aa00); });
        continueBtn.on('pointerout', () => { if (!this.levelChoiceMade) continueBtn.setFillStyle(0x008800); });
        continueBtn.on('pointerdown', () => doTransition(false));
        
        // Return to hideout button
        const hideoutBtn = this.add.rectangle(500, 400, 200, 60, 0x444488).setInteractive().setDepth(501);
        const hideoutTxt = this.add.text(500, 400, 'HIDEOUT', { 
            fontSize: '24px', fill: '#ffffff' 
        }).setOrigin(0.5).setDepth(502);
        
        hideoutBtn.on('pointerover', () => { if (!this.levelChoiceMade) hideoutBtn.setFillStyle(0x5555aa); });
        hideoutBtn.on('pointerout', () => { if (!this.levelChoiceMade) hideoutBtn.setFillStyle(0x444488); });
        hideoutBtn.on('pointerdown', () => doTransition(true));
        
        // Keyboard shortcuts - use existing keys system instead of adding new ones
        this.levelChoiceEnterHandler = () => doTransition(false);
        this.levelChoiceEscHandler = () => doTransition(true);
        
        this.input.keyboard.on('keydown-ENTER', this.levelChoiceEnterHandler);
        this.input.keyboard.on('keydown-ESC', this.levelChoiceEscHandler);
        
        // Hint text
        const hintText = this.add.text(400, 480, 'ENTER = Continue  |  ESC = Hideout', { 
            fontSize: '14px', fill: '#666666' 
        }).setOrigin(0.5).setDepth(501);
    }

    winGame() {
        if (this.isTransitioning) return;
        this.isTransitioning = true;
        this.cleanupTimerEvents();
        this.extractionActive = false;
        this.physics.pause();
        this.levelText.setText("EXTRACTED!").setAlpha(1);
        if (this.uiGraphics) this.uiGraphics.clear();
        
        sfx.levelComplete();
        sfx.success();
        
        // Track run completion
        this.persistent.runsCompleted++;
        
        // Calculate and award skill points
        const skillPointsEarned = this.calculateRunSkillPoints();
        if (skillPointsEarned > 0) {
            this.persistent.skillPoints = (this.persistent.skillPoints || 0) + skillPointsEarned;
            this.persistent.totalSkillPoints = (this.persistent.totalSkillPoints || 0) + skillPointsEarned;
            this.showFloatingText(400, 320, `+${skillPointsEarned} SKILL POINT${skillPointsEarned > 1 ? 'S' : ''}!`, 0xaa66ff);
        }
        
        // ===== CHALLENGE TRACKING =====
        // Weekly extractions
        this.persistent.weeklyExtractions = (this.persistent.weeklyExtractions || 0) + 1;
        
        // Weekly unique levels (track which levels extracted from this week)
        if (!this.persistent.weeklyUniqueLevels) this.persistent.weeklyUniqueLevels = [];
        if (!this.persistent.weeklyUniqueLevels.includes(this.currentLevel)) {
            this.persistent.weeklyUniqueLevels.push(this.currentLevel);
        }
        
        // Perfect level tracking (no damage taken)
        if (this.levelDamageTaken === 0) {
            this.persistent.perfectLevels = (this.persistent.perfectLevels || 0) + 1;
        }
        
        // Update challenge progress for daily/weekly challenges
        this.updateChallengeProgress();
        
        // Check for completed challenges and show notifications
        const completedChallenges = checkChallengeCompletion(this.persistent);
        completedChallenges.forEach(c => {
            if (c.type === 'permanent') {
                this.showFloatingText(400, 350, `CHALLENGE: ${c.name}!`, 0xffd700);
            }
        });
        
        // Update next level for progression (after level 5 go to 6, after level 7 reset to 1)
        if (this.currentLevel === 7) {
            this.playerStats.nextLevel = 1; // Game complete, reset
            this.playerStats.highestLevelUnlocked = 7; // All levels stay unlocked
            this.showFloatingText(400, 200, "GAME COMPLETE!", 0x00ff00);
        } else {
            this.playerStats.nextLevel = this.currentLevel + 1;
            // Unlock the next level if not already unlocked
            if (this.playerStats.highestLevelUnlocked < this.currentLevel + 1) {
                this.playerStats.highestLevelUnlocked = this.currentLevel + 1;
            }
        }
        
        // Sync highestLevelUnlocked to persistent for upgrade tracking
        if (this.playerStats.highestLevelUnlocked > (this.persistent.highestLevelUnlocked || 0)) {
            this.persistent.highestLevelUnlocked = this.playerStats.highestLevelUnlocked;
        }
        
        // Check achievements
        const newAchievements = checkAchievements(this.persistent, {
            hasAllWeapons: this.playerStats.hasShotgun && this.playerStats.hasSMG
        });
        newAchievements.forEach(a => {
            sfx.achievement();
            this.showFloatingText(400, 250, `${a.icon} ${a.name}!`, 0xffd700);
        });
        
        // Check for new permanent upgrades
        const newUpgrades = checkUpgrades(this.persistent);
        newUpgrades.forEach(u => {
            sfx.achievement();
            this.showFloatingText(400, 280, `UPGRADE: ${u.name}!`, 0xffaa00);
        });
        
        savePersistent(this.persistent);
        localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.playerStats));
        this.time.delayedCall(CONFIG.TIMINGS.DEATH_RESTART, () => {
            this.scene.start('HideoutScene', { stats: this.playerStats });
        });
    }

    tryInteract() {
        const crates = this.crates.getChildren();
        let closest = null;
        let minDst = CONFIG.DISTANCES.INTERACT;

        crates.forEach(c => {
            const d = Phaser.Math.Distance.Between(this.player.x, this.player.y, c.x, c.y);
            if (c.active && d < minDst) { closest = c; minDst = d; }
        });
        if (closest) { this.openCrate(closest); return; }

        const skulls = this.skulls.getChildren();
        closest = null;
        minDst = CONFIG.DISTANCES.INTERACT;

        skulls.forEach(s => {
            const d = Phaser.Math.Distance.Between(this.player.x, this.player.y, s.x, s.y);
            if (s.active && d < minDst) { closest = s; minDst = d; }
        });
        if (closest) {
            const itemID = closest.getData('lootID');
            closest.destroy();
            this.applyLoot(itemID);
        }
    }

    openCrate(crate) {
        const itemID = crate.getData('lootID');
        this.isOpening = true;
        // Apply Quick Hands skill (+25% interact speed = -25% time)
        const openTime = Math.floor(CONFIG.TIMINGS.CRATE_OPEN * (1 - (this.quickHandsBonus || 0)));
        this.openTimerEvent = this.time.addEvent({
            delay: openTime,
            callback: () => {
                this.isOpening = false;
                sfx.crateOpen();
                crate.destroy();
                this.applyLoot(itemID);
            }
        });
    }

    applyLoot(id) {
        let txt = "", col = 0xffffff;

        switch (id) {
            case 'meds':
                sfx.lootHealth();
                const oldMedsHp = this.playerStats.hp;
                this.playerStats.hp = Math.min(this.playerStats.hp + 5, this.playerStats.maxHp);
                const medsHealedAmount = this.playerStats.hp - oldMedsHp;
                if (medsHealedAmount > 0) {
                    this.persistent.totalHPHealed = (this.persistent.totalHPHealed || 0) + medsHealedAmount;
                    // Check medic unlock achievement
                    const medsAchievements = checkAchievements(this.persistent, {});
                    medsAchievements.forEach(a => {
                        sfx.achievement();
                        this.showFloatingText(400, 200, `${a.icon} ${a.name}!`, 0xffd700);
                    });
                    savePersistent(this.persistent);
                }
                txt = "+5 HP"; col = 0xff0000;
                break;
            case 'ammo':
                sfx.lootAmmo();
                this.playerStats.ammo += 5;
                txt = "+5 Ammo"; col = 0xffff00;
                break;
            case 'key':
                sfx.lootKey();
                this.hasKey = true;
                txt = "KEY FOUND!"; col = 0xffd700;
                break;
            case 'map':
                sfx.lootKey();
                this.hasMap = true;
                this.updateMinimap(); // Immediately show minimap
                txt = "MAP FOUND!"; col = 0x00ffaa;
                break;
            case 'flashlight':
                sfx.lootWeapon();
                this.playerStats.hasFlashlight = true;
                txt = "FLASHLIGHT!"; col = 0xffffff;
                break;
            case 'molotov':
                sfx.loot();
                this.hasMolotov = true;
                txt = "MOLOTOV!"; col = 0xff4500;
                break;
            case 'shotgun':
                sfx.lootWeapon();
                this.playerStats.hasShotgun = true;
                txt = "SHOTGUN!"; col = 0xff00ff;
                break;
            case 'smg':
                sfx.lootWeapon();
                this.playerStats.hasSMG = true;
                txt = "SMG!"; col = 0x00ffff;
                break;
            case 'crossbow':
                sfx.lootWeapon();
                this.playerStats.hasCrossbow = true;
                txt = "CROSSBOW!"; col = 0x8B4513;
                break;
            case 'rifle':
                sfx.lootWeapon();
                this.playerStats.hasRifle = true;
                txt = "ASSAULT RIFLE!"; col = 0x556B2F;
                break;
            case 'scrap':
                sfx.loot();
                this.playerStats.scrap += 5;
                this.persistent.totalScrapCollected += 5;
                // Check scavenger achievement
                const scrapAchievements = checkAchievements(this.persistent, {});
                scrapAchievements.forEach(a => {
                    sfx.achievement();
                    this.showFloatingText(400, 200, `${a.icon} ${a.name}!`, 0xffd700);
                });
                savePersistent(this.persistent);
                txt = "+5 SCRAP"; col = 0xaaaaaa;
                break;
            case 'plug':
                sfx.lootKey();
                this.playerStats.hideout.hasSparkPlug = true;
                txt = "SPARK PLUG!"; col = 0x00ffff;
                break;
            case 'helmet':
                sfx.loot();
                this.playerStats.armor.head = { name: 'HELMET', durability: 3, maxDurability: 3 };
                txt = "HELMET EQUIPPED"; col = 0x00ff00;
                break;
            case 'vest':
                sfx.loot();
                this.playerStats.armor.body = { name: 'VEST', durability: 5, maxDurability: 5 };
                txt = "VEST EQUIPPED"; col = 0x00ff00;
                break;
            case 'grenade':
                if (this.playerStats.grenades < CONFIG.GRENADE.MAX_CARRY) {
                    sfx.loot();
                    this.playerStats.grenades++;
                    txt = "+1 GRENADE"; col = 0x556B2F;
                } else {
                    sfx.error();
                    txt = "GRENADES FULL"; col = 0x888888;
                }
                break;
            // Weapon Mods
            case 'extended_mag':
            case 'suppressor':
            case 'laser_sight':
            case 'damage_barrel':
            case 'rapid_fire':
                sfx.lootWeapon();
                if (!this.persistent.modInventory) this.persistent.modInventory = [];
                this.persistent.modInventory.push(id);
                savePersistent(this.persistent);
                const modConfig = Object.values(CONFIG.MODS).find(m => m.id === id);
                txt = `MOD: ${modConfig?.name || id.toUpperCase()}!`; 
                col = 0xff00ff;
                break;
        }

        this.showFloatingText(this.player.x, this.player.y - 30, txt, col);
    }

    showFloatingText(x, y, msg, color) {
        this.floatingText.spawn(x, y, msg, color);
    }

    updateBossBar(hp, max) {
        this.bossBar.clear();
        this.bossBar.fillStyle(0x000000, 1);
        this.bossBar.fillRect(200, 50, 400, 20);
        this.bossBar.fillStyle(0xff0000, 1);
        this.bossBar.fillRect(202, 52, 396 * (hp / max), 16);
    }

    drawUI() {
        if (!this.uiGraphics) return;
        const ui = CONFIG.UI;
        this.uiGraphics.clear();

        // HP Bar
        this.uiGraphics.fillStyle(0x000000, 0.5);
        this.uiGraphics.fillRect(10, 10, ui.HP_BAR_WIDTH + 4, ui.HP_BAR_HEIGHT + 4);
        this.uiGraphics.fillStyle(0xff0000, 1);
        this.uiGraphics.fillRect(12, 12, ui.HP_BAR_WIDTH * (this.playerStats.hp / this.playerStats.maxHp), ui.HP_BAR_HEIGHT);

        // Stamina Bar
        this.uiGraphics.fillStyle(0x000000, 0.5);
        this.uiGraphics.fillRect(10, 40, ui.STAMINA_BAR_WIDTH + 4, ui.STAMINA_BAR_HEIGHT + 4);
        this.uiGraphics.fillStyle(0x0088ff, 1);
        this.uiGraphics.fillRect(12, 42, ui.STAMINA_BAR_WIDTH * (this.playerStats.stamina / this.playerStats.maxStamina), ui.STAMINA_BAR_HEIGHT);

        // Ammo display with magazine
        const weapon = this.playerStats.currentWeapon;
        const mag = this.playerStats.magazines[weapon];
        const maxMag = CONFIG.WEAPONS[weapon.toUpperCase()].MAG_SIZE;
        
        let reloadText = this.isReloading ? " [RELOADING]" : "";
        let timerText = this.extractionActive ? ` | BEACON: ${this.extractionTimer}s` : "";
        if (this.extractionActive) this.levelText.setText(this.extractionTimer).setAlpha(1).setTint(0xff0000);
        
        // Main status line with all currencies
        this.uiText.setText(`${weapon.toUpperCase()}: ${mag}/${maxMag} (${this.playerStats.ammo})${reloadText} | GREN: ${this.playerStats.grenades} | üîß${this.playerStats.scrap} üí∞${this.playerStats.credits} ‚öôÔ∏è${this.playerStats.materials}${timerText}`);

        // Icons
        let iconX = 300;
        if (this.hasKey) {
            this.uiGraphics.fillStyle(0xFFD700, 1);
            this.uiGraphics.fillCircle(iconX, 22, ui.ICON_RADIUS);
            iconX += ui.ICON_SPACING;
        }
        if (this.playerStats.hasFlashlight) {
            this.uiGraphics.fillStyle(0xffffff, 1);
            this.uiGraphics.fillCircle(iconX, 22, ui.ICON_RADIUS);
            iconX += ui.ICON_SPACING;
        }
        if (this.hasMolotov) {
            this.uiGraphics.fillStyle(0xff4500, 1);
            this.uiGraphics.fillCircle(iconX, 22, ui.ICON_RADIUS);
            iconX += ui.ICON_SPACING;
        }
        if (this.playerStats.hideout.hasSparkPlug) {
            this.uiGraphics.fillStyle(0x00ffff, 1);
            this.uiGraphics.fillCircle(iconX, 22, ui.ICON_RADIUS);
            iconX += ui.ICON_SPACING;
        }
        if (this.playerStats.hideout.armory.hasNVG) {
            this.uiGraphics.fillStyle(0x00ff00, 1);
            this.uiGraphics.fillCircle(iconX, 22, ui.ICON_RADIUS);
            iconX += ui.ICON_SPACING;
        }
        if (this.playerStats.grenades > 0) {
            this.uiGraphics.fillStyle(0x556B2F, 1);
            this.uiGraphics.fillCircle(iconX, 22, ui.ICON_RADIUS);
            // Show count
            this.uiGraphics.fillStyle(0xffffff, 1);
        }
        
        // Dodge cooldown indicator
        const dodgeCooldownRemaining = CONFIG.PLAYER.DODGE_COOLDOWN - (this.time.now - this.lastDodgeTime);
        if (dodgeCooldownRemaining > 0) {
            const cooldownPercent = dodgeCooldownRemaining / CONFIG.PLAYER.DODGE_COOLDOWN;
            this.uiGraphics.fillStyle(0x444444, 0.8);
            this.uiGraphics.fillRect(10, 56, 50, 8);
            this.uiGraphics.fillStyle(0x00ffff, 1);
            this.uiGraphics.fillRect(10, 56, 50 * (1 - cooldownPercent), 8);
        }
        
        // Consumable slots (bottom-left)
        const slotSize = 35;
        const slotSpacing = 5;
        const slotY = 560;
        // Defensive check for consumables array
        if (!this.playerStats.consumables || !Array.isArray(this.playerStats.consumables)) {
            this.playerStats.consumables = [null, null, null];
        }
        
        for (let i = 0; i < 3; i++) {
            const slotX = 15 + i * (slotSize + slotSpacing);
            const consumable = this.playerStats.consumables[i];
            
            // Slot background
            this.uiGraphics.fillStyle(0x222222, 0.8);
            this.uiGraphics.fillRect(slotX, slotY, slotSize, slotSize);
            this.uiGraphics.lineStyle(2, consumable ? 0x00ff00 : 0x444444);
            this.uiGraphics.strokeRect(slotX, slotY, slotSize, slotSize);
            
            // Slot number
            if (!this.consumableSlotTexts) {
                this.consumableSlotTexts = [];
                for (let j = 0; j < 3; j++) {
                    const numText = this.add.text(20 + j * (slotSize + slotSpacing), slotY + slotSize + 2, `${j + 1}`, 
                        { fontSize: '12px', fill: '#888' }).setDepth(101);
                    this.consumableSlotTexts.push(numText);
                    
                    const iconText = this.add.text(20 + j * (slotSize + slotSpacing) + slotSize/2 - 8, slotY + 8, '', 
                        { fontSize: '18px' }).setDepth(101);
                    this.consumableSlotTexts.push(iconText);
                }
            }
            
            // Update slot icon
            const iconTextIdx = i * 2 + 1;
            if (this.consumableSlotTexts && this.consumableSlotTexts[iconTextIdx]) {
                if (consumable && CONFIG.CONSUMABLES[consumable]) {
                    this.consumableSlotTexts[iconTextIdx].setText(CONFIG.CONSUMABLES[consumable].icon);
                } else {
                    this.consumableSlotTexts[iconTextIdx].setText('');
                }
            }
        }
    }
    
    drawLaserSight() {
        if (!this.laserGraphics) return;
        this.laserGraphics.clear();
        
        // Check if laser is toggled on
        if (!this.laserEnabled) return;
        
        // Check if current weapon has laser sight mod
        const weapon = this.playerStats.currentWeapon;
        const modEffects = this.weaponModEffects?.[weapon];
        if (!modEffects || !modEffects.hasLaser) return;
        
        // Draw laser line from player to mouse pointer
        const pointer = this.input.activePointer;
        const angle = Phaser.Math.Angle.Between(this.player.x, this.player.y, pointer.x, pointer.y);
        
        // Calculate laser endpoint (limited range of 300 pixels)
        const laserRange = 300;
        const endX = this.player.x + Math.cos(angle) * laserRange;
        const endY = this.player.y + Math.sin(angle) * laserRange;
        
        // Draw the laser beam
        this.laserGraphics.lineStyle(1, 0xff0000, 0.8);
        this.laserGraphics.beginPath();
        this.laserGraphics.moveTo(this.player.x, this.player.y);
        this.laserGraphics.lineTo(endX, endY);
        this.laserGraphics.strokePath();
        
        // Draw small dot at end
        this.laserGraphics.fillStyle(0xff0000, 1);
        this.laserGraphics.fillCircle(endX, endY, 3);
    }
    
    shutdown() {
        // Clean up keyboard handlers from level complete choice
        if (this.levelChoiceEnterHandler) {
            this.input.keyboard.off('keydown-ENTER', this.levelChoiceEnterHandler);
            this.levelChoiceEnterHandler = null;
        }
        if (this.levelChoiceEscHandler) {
            this.input.keyboard.off('keydown-ESC', this.levelChoiceEscHandler);
            this.levelChoiceEscHandler = null;
        }
        
        // Clean up timer events
        this.cleanupTimerEvents();
        
        // Clear consumable slot texts reference
        this.consumableSlotTexts = null;
    }
}

// =============================================================================
// GAME CONFIGURATION
// =============================================================================
const config = {
    type: Phaser.AUTO,
    width: 800,
    height: 600,
    backgroundColor: '#000000',
    parent: 'game-container',
    physics: {
        default: 'arcade',
        arcade: { gravity: { y: 0 } }
    },
    scene: [MainMenuScene, GameScene, HideoutScene],
    scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH
    }
};

const game = new Phaser.Game(config);
</script>
</body>
</html>
