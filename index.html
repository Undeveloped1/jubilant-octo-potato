<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zombies - File System 16.0 (Content Expansion)</title>
    <style>
        body { margin: 0; padding: 0; background-color: #000000; overflow: hidden; }
        canvas { display: block; margin: 0 auto; }
        #instructions {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            color: #444; font-family: sans-serif; pointer-events: none; opacity: 0.5;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>
<body>
<div id="instructions">WASD: Move | Mouse: Aim/Fire | SPACE: Dodge | R: Reload | G: Grenade | TAB: Inventory | N: NVG | F: Interact | Q: Switch | E: Melee | 1/2/3: Consumables</div>
<script>

// =============================================================================
// CONFIGURATION - All magic numbers centralized here
// =============================================================================
const CONFIG = {
    // Save system
    SAVE_KEY: 'zombie_save_v16',
    SETTINGS_KEY: 'zombie_settings_v16',
    
    // Player settings
    PLAYER: {
        WALK_SPEED: 160,
        SPRINT_SPEED: 280,
        STAMINA_DRAIN: 0.5,
        STAMINA_REGEN: 0.2,
        INVULN_TIME: 1000,
        MELEE_COOLDOWN: 500,
        MELEE_RANGE: 60,
        MELEE_DAMAGE: 2,
        LIGHT_RADIUS: 60,
        FLASHLIGHT_RANGE: 300,
        FLASHLIGHT_ANGLE: 0.5,
        // Dodge roll settings
        DODGE_SPEED: 400,
        DODGE_DURATION: 200,
        DODGE_COOLDOWN: 800,
        DODGE_STAMINA_COST: 20,
        // Low HP threshold for vignette
        LOW_HP_THRESHOLD: 0.3
    },
    
    // Weapon settings
    WEAPONS: {
        PISTOL: {
            FIRE_RATE: 300,
            AMMO_COST: 1,
            SPREAD: 0,
            MAG_SIZE: 12,
            RELOAD_TIME: 1000
        },
        SHOTGUN: {
            FIRE_RATE: 1000,
            AMMO_COST: 2,
            PELLETS: 5,
            SPREAD_STEP: 5,
            MAG_SIZE: 6,
            RELOAD_TIME: 1500
        },
        SMG: {
            FIRE_RATE: 100,
            AMMO_COST: 1,
            SPREAD: 8,
            MAG_SIZE: 30,
            RELOAD_TIME: 1800
        },
        CROSSBOW: {
            FIRE_RATE: 1500,      // Slow reload between shots
            AMMO_COST: 1,
            DAMAGE: 3,            // High damage (one-shots walkers)
            MAG_SIZE: 1,          // Single bolt
            RELOAD_TIME: 2000,
            PIERCING: true,       // Passes through first target
            SILENT: true          // Doesn't alert nearby enemies
        },
        RIFLE: {
            FIRE_RATE: 200,       // Medium rate
            AMMO_COST: 1,
            DAMAGE: 1.5,          // Slightly higher than pistol
            SPREAD: 3,            // Tight spread
            MAG_SIZE: 25,
            RELOAD_TIME: 1500,
            FIRST_SHOT_BONUS: true // Extra accuracy when stationary
        },
        BULLET_SPEED: 500
    },
    
    // Enemy configurations
    ENEMIES: {
        WALKER: {
            HP: 2,
            SPEED: 60,
            DAMAGE: 2,
            AGGRO_RANGE: 300,
            TEXTURE: 'zombie'
        },
        LEAPER: {
            HP: 1,
            SPEED: 110,
            DAMAGE: 2,
            LEAP_RANGE: 180,
            LEAP_SPEED: 450,
            PREPARE_TIME: 500,
            LEAP_DURATION: 600,
            COOLDOWN_TIME: 1500,
            KNOCKBACK_SPEED: 250,
            TEXTURE: 'leaper'
        },
        BANDIT: {
            HP: 3,
            SPEED: 90,
            DAMAGE: 1,
            AMMO: 10,
            FIRE_RANGE: 350,
            FIRE_RATE: 2000,
            MELEE_SPEED: 120,
            SPREAD: 5,
            TEXTURE: 'bandit'
        },
        BOSS: {
            HP: 5,
            SPEED: 85,
            DAMAGE: 10,
            SCALE: 3,
            INVULN_TIME: 500,
            TEXTURE: 'zombie'
        },
        SPITTER: {
            HP: 2,
            SPEED: 50,
            DAMAGE: 1,
            SPIT_RANGE: 280,
            SPIT_COOLDOWN: 2500,
            SPIT_SPEED: 200,
            TEXTURE: 'spitter'
        },
        EXPLODER: {
            HP: 2,
            SPEED: 100,           // Fast
            DAMAGE: 3,            // Explosion damage to player
            EXPLOSION_RADIUS: 80,
            ENEMY_DAMAGE: 5,      // Damage to other enemies (chain reactions!)
            TEXTURE: 'zombie'     // Reuse zombie texture with orange tint
        },
        NECROMANCER: {
            HP: 8,
            SPEED: 60,
            DAMAGE: 2,
            SUMMON_COUNT: 4,        // Zombies per summon
            VULNERABLE_TIME: 10000, // 10 sec window
            PROJECTILE_SPEED: 150,
            PROJECTILE_DAMAGE: 2,
            TELEPORT_COOLDOWN: 5000,
            TEXTURE: 'zombie'     // Will use custom tint
        },
        KNOCKBACK_SPEED: 100
    },
    
    // Grenade settings
    GRENADE: {
        THROW_SPEED: 350,
        FUSE_TIME: 1500,
        EXPLOSION_RADIUS: 100,
        DAMAGE: 5,
        MAX_CARRY: 3
    },
    
    // Interaction distances
    DISTANCES: {
        INTERACT: 60,
        DEBRIS: 80,
        DOOR: 60
    },
    
    // Timings (in ms)
    TIMINGS: {
        CRATE_OPEN: 1000,
        DEBRIS_BURN: 5000,
        EXTRACTION: 15000,
        DEATH_RESTART: 2000,
        LEVEL_TRANSITION: 1000,
        NVG_CRAFT: 90000
    },
    
    // UI settings
    UI: {
        HP_BAR_WIDTH: 200,
        HP_BAR_HEIGHT: 20,
        STAMINA_BAR_WIDTH: 150,
        STAMINA_BAR_HEIGHT: 10,
        ICON_RADIUS: 12,
        ICON_SPACING: 30,
        // Hit direction indicator settings
        HIT_INDICATOR_DURATION: 500,
        HIT_INDICATOR_SIZE: 60,
        HIT_INDICATOR_DISTANCE: 80
    },
    
    // Loot tables
    LOOT: {
        BANDIT: ['ammo', 'ammo', 'scrap', 'meds', 'helmet', 'vest', 'grenade'],
        ZOMBIE: ['ammo', 'scrap', 'meds', 'ammo'],
        SPITTER: ['ammo', 'scrap', 'meds', 'grenade'],
        EXPLODER: ['ammo', 'scrap', 'grenade'],
        NECROMANCER: ['materials', 'materials', 'grenade', 'meds']
    },
    
    // Achievements
    ACHIEVEMENTS: {
        FIRST_BLOOD: { id: 'first_blood', name: 'First Blood', desc: 'Kill your first enemy', icon: 'üíÄ' },
        EXTERMINATOR: { id: 'exterminator', name: 'Exterminator', desc: 'Kill 50 enemies total', icon: '‚ò†Ô∏è' },
        SHARPSHOOTER: { id: 'sharpshooter', name: 'Sharpshooter', desc: 'Achieve 50% accuracy in a run', icon: 'üéØ' },
        MELEE_MASTER: { id: 'melee_master', name: 'Melee Master', desc: 'Kill a boss with melee only', icon: 'üó°Ô∏è' },
        SURVIVOR: { id: 'survivor', name: 'Survivor', desc: 'Complete your first extraction', icon: 'üèÜ' },
        VETERAN: { id: 'veteran', name: 'Veteran', desc: 'Complete 5 extractions', icon: '‚≠ê' },
        GRENADIER: { id: 'grenadier', name: 'Grenadier', desc: 'Kill 3 enemies with one grenade', icon: 'üí£' },
        UNTOUCHABLE: { id: 'untouchable', name: 'Untouchable', desc: 'Complete a level without taking damage', icon: 'üõ°Ô∏è' },
        SCAVENGER: { id: 'scavenger', name: 'Scavenger', desc: 'Collect 100 scrap total', icon: 'üîß' },
        FULLY_LOADED: { id: 'fully_loaded', name: 'Fully Loaded', desc: 'Own all weapons at once', icon: 'üî´' }
    },
    
    // Hideout upgrade costs
    HIDEOUT: {
        WORKBENCH_COST: 15,
        WORKBENCH_DAMAGE_BONUS: 0.25, // +25% damage
        REPAIR_STATION_COST: 20,
        REPAIR_COST_PER_POINT: 1 // 1 scrap per durability point
    },
    
    // Currency system
    CURRENCIES: {
        SCRAP: { name: 'Scrap', icon: 'üîß', color: 0xaaaaaa },
        CREDITS: { name: 'Credits', icon: 'üí∞', color: 0xffd700 },
        MATERIALS: { name: 'Materials', icon: '‚öôÔ∏è', color: 0x00aaff }
    },
    
    // Trader configuration
    TRADER: {
        HIDEOUT_STOCK: [
            { id: 'ammo_bundle', name: 'Ammo Bundle', type: 'ammo', amount: 50, cost: 15, currency: 'credits' },
            { id: 'med_kit', name: 'Med Kit', type: 'heal', amount: 5, cost: 20, currency: 'credits' },
            { id: 'grenade', name: 'Grenade', type: 'grenade', amount: 1, cost: 25, currency: 'credits' },
            { id: 'adrenaline', name: 'Adrenaline Shot', type: 'consumable', effect: 'speed', cost: 30, currency: 'credits' },
            { id: 'armor_patch', name: 'Armor Patch', type: 'consumable', effect: 'repair', cost: 25, currency: 'credits' }
        ],
        SELL_RATE: 0.5
    },
    
    // Consumables configuration
    CONSUMABLES: {
        adrenaline: { name: 'Adrenaline', effect: 'speed', multiplier: 1.5, duration: 10000, icon: 'üíâ' },
        armor_patch: { name: 'Armor Patch', effect: 'repair', amount: 20, duration: 0, icon: 'ü©π' }
    },
    
    // Enemy drop configuration (currency auto-collects, items go to skull)
    ENEMY_DROPS: {
        WALKER: { currency: 'scrap', min: 1, max: 3, items: ['ammo', 'meds'] },
        SPITTER: { currency: 'scrap', min: 2, max: 4, items: ['ammo', 'meds', 'grenade'] },
        BANDIT: { currency: 'credits', min: 5, max: 15, items: ['ammo', 'helmet', 'vest'] },
        BOSS: { currency: 'materials', min: 5, max: 15, items: ['grenade', 'meds'] },
        LEAPER: { currency: 'scrap', min: 1, max: 2, items: ['ammo'] },
        EXPLODER: { currency: 'scrap', min: 2, max: 5, items: ['ammo', 'grenade'] },
        NECROMANCER: { currency: 'materials', min: 10, max: 20, items: ['grenade', 'meds', 'crossbow'] }
    }
};

const DEFAULT_STATS = { 
    hp: 10, maxHp: 10, stamina: 100, maxStamina: 100, ammo: 30, scrap: 0,
    credits: 0,
    materials: 0,
    grenades: 0,
    nextLevel: 1,  // Track which level to start on after extraction
    highestLevelUnlocked: 1,  // Track progression (1-7) for mission map
    consumables: [null, null, null],  // 3 slots for hotkeys 1, 2, 3
    hasFlashlight: false, hasShotgun: false, hasSMG: false, hasCrossbow: false, hasRifle: false, currentWeapon: 'pistol',
    // Magazine tracking - current rounds in each weapon's magazine
    magazines: {
        pistol: CONFIG.WEAPONS.PISTOL.MAG_SIZE,
        shotgun: CONFIG.WEAPONS.SHOTGUN.MAG_SIZE,
        smg: CONFIG.WEAPONS.SMG.MAG_SIZE,
        crossbow: CONFIG.WEAPONS.CROSSBOW.MAG_SIZE,
        rifle: CONFIG.WEAPONS.RIFLE.MAG_SIZE
    },
    armor: { head: null, body: null, arms: null, feet: null },
    hideout: { 
        restAreaLvl: 0, 
        generatorLvl: 0, 
        hasSparkPlug: false,
        armory: { crafting: null, hasNVG: false },
        workbenchLvl: 0,  // Weapon damage upgrade
        repairStationLvl: 0  // Armor repair
    }
};

// Persistent stats that survive across all runs (stored separately)
const DEFAULT_PERSISTENT = {
    // Lifetime stats
    totalKills: 0,
    totalDeaths: 0,
    runsCompleted: 0,
    runsStarted: 0,
    totalShotsFired: 0,
    totalShotsHit: 0,
    totalScrapCollected: 0,
    totalCreditsEarned: 0,
    totalMaterialsCollected: 0,
    totalGrenadeKills: 0,
    bossesKilled: 0,
    meleeKills: 0,
    itemsSold: 0,
    itemsBought: 0,
    // Current run stats (reset each run)
    runKills: 0,
    runShotsFired: 0,
    runShotsHit: 0,
    runDamageTaken: 0,
    runGrenadeKills: 0,
    runMeleeKills: 0,
    bossHitWithGun: false, // For melee master achievement
    // Achievements unlocked
    achievements: []
};

const PERSISTENT_KEY = 'zombie_persistent_v16';

// Default settings
const DEFAULT_SETTINGS = {
    masterVolume: 0.3,
    sfxVolume: 1.0,
    musicVolume: 0.5,
    screenShake: true,
    hitIndicators: true
};

// =============================================================================
// SETTINGS MANAGER
// =============================================================================
function loadSettings() {
    const saved = localStorage.getItem(CONFIG.SETTINGS_KEY);
    if (saved) {
        return { ...JSON.parse(JSON.stringify(DEFAULT_SETTINGS)), ...JSON.parse(saved) };
    }
    return JSON.parse(JSON.stringify(DEFAULT_SETTINGS));
}

function saveSettings(settings) {
    localStorage.setItem(CONFIG.SETTINGS_KEY, JSON.stringify(settings));
}

// =============================================================================
// AUDIO MANAGER (PROCEDURAL SOUNDS WITH VOLUME CONTROL)
// =============================================================================
class SoundManager {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.settings = loadSettings();
        
        // Create gain nodes for volume control
        this.masterGain = this.ctx.createGain();
        this.sfxGain = this.ctx.createGain();
        this.musicGain = this.ctx.createGain();
        
        // Connect gain chain
        this.sfxGain.connect(this.masterGain);
        this.musicGain.connect(this.masterGain);
        this.masterGain.connect(this.ctx.destination);
        
        this.updateVolumes();
        
        // Footstep timing
        this.lastFootstep = 0;
        this.footstepInterval = 250; // ms between footsteps
    }
    
    updateVolumes() {
        this.masterGain.gain.value = this.settings.masterVolume;
        this.sfxGain.gain.value = this.settings.sfxVolume;
        this.musicGain.gain.value = this.settings.musicVolume;
    }
    
    setMasterVolume(vol) {
        this.settings.masterVolume = vol;
        this.updateVolumes();
        saveSettings(this.settings);
    }
    
    setSfxVolume(vol) {
        this.settings.sfxVolume = vol;
        this.updateVolumes();
        saveSettings(this.settings);
    }
    
    setMusicVolume(vol) {
        this.settings.musicVolume = vol;
        this.updateVolumes();
        saveSettings(this.settings);
    }
    
    reloadSettings() {
        this.settings = loadSettings();
        this.updateVolumes();
    }

    resume() { if (this.ctx.state === 'suspended') this.ctx.resume(); }

    playTone(freq, type, duration, vol = 1) {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.sfxGain);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }
    
    // Pitch variation helper
    playToneVaried(freq, type, duration, vol = 1, variance = 0.1) {
        const variedFreq = freq * (1 + (Math.random() - 0.5) * variance * 2);
        this.playTone(variedFreq, type, duration, vol);
    }

    playNoise(duration, vol = 1) {
        const bufferSize = this.ctx.sampleRate * duration;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        noise.connect(gain);
        gain.connect(this.sfxGain);
        noise.start();
    }
    
    // Filtered noise for variety
    playFilteredNoise(duration, vol = 1, filterFreq = 1000, filterType = 'lowpass') {
        const bufferSize = this.ctx.sampleRate * duration;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        
        const filter = this.ctx.createBiquadFilter();
        filter.type = filterType;
        filter.frequency.value = filterFreq;
        
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.sfxGain);
        noise.start();
    }

    // ==================== WEAPON SOUNDS (with variation) ====================
    shootPistol() { 
        this.playToneVaried(600, 'sawtooth', 0.1, 0.5, 0.1); 
        this.playNoise(0.1, 0.3); 
    }
    
    shootShotgun() { 
        this.playToneVaried(200, 'square', 0.3, 0.6, 0.05); 
        this.playNoise(0.3, 0.6); 
        this.playTone(100, 'sawtooth', 0.15, 0.3); // Extra bass
    }
    
    shootSMG() { 
        this.playToneVaried(800, 'sawtooth', 0.05, 0.4, 0.15); 
        this.playNoise(0.05, 0.2); 
    }
    
    // Crossbow - quiet twang
    shootCrossbow() {
        this.playToneVaried(300, 'triangle', 0.15, 0.2, 0.1);
        this.playToneVaried(150, 'sine', 0.1, 0.15, 0.1);
    }
    
    // Assault Rifle - medium crack
    shootRifle() {
        this.playToneVaried(400, 'sawtooth', 0.15, 0.5, 0.08);
        this.playNoise(0.15, 0.4);
        this.playTone(150, 'square', 0.1, 0.25);
    }
    
    // ==================== EXPLODER SOUNDS ====================
    exploderWarning() {
        // Ticking/bubbling sound as it charges
        this.playTone(200, 'sine', 0.1, 0.2);
        this.playTone(250, 'sine', 0.08, 0.15);
    }
    
    exploderExplode() {
        // Meaty explosion
        this.playTone(80, 'sawtooth', 0.4, 0.7);
        this.playNoise(0.35, 0.6);
        this.playTone(40, 'square', 0.3, 0.4);
    }
    
    // ==================== STEALTH SOUNDS ====================
    detectionPing() {
        // Soft ping when detection rises
        this.playTone(600, 'sine', 0.1, 0.2);
    }
    
    detectionMax() {
        // Alarm sound when fully detected
        this.playTone(800, 'square', 0.3, 0.5);
        this.playTone(600, 'square', 0.2, 0.4);
        this.playTone(800, 'square', 0.3, 0.5);
    }
    
    stealthKill() {
        // Satisfying quiet kill
        this.playTone(100, 'triangle', 0.15, 0.3);
        this.playFilteredNoise(0.1, 0.2, 800, 'lowpass');
    }
    
    // ==================== NECROMANCER SOUNDS ====================
    necroSummon() {
        // Ethereal chanting
        this.playTone(150, 'sine', 0.5, 0.3);
        this.playTone(200, 'sine', 0.4, 0.25);
        this.playTone(175, 'triangle', 0.3, 0.2);
    }
    
    necroVulnerable() {
        // Shield break sound
        this.playTone(400, 'sawtooth', 0.2, 0.4);
        this.playNoise(0.15, 0.3);
        this.playTone(200, 'square', 0.3, 0.3);
    }
    
    necroTeleport() {
        // Whoosh
        this.playFilteredNoise(0.2, 0.3, 2000, 'highpass');
        this.playTone(500, 'sine', 0.15, 0.2);
    }
    
    necroProjectile() {
        // Ghostly whistle
        this.playTone(600, 'sine', 0.2, 0.25);
        this.playTone(650, 'sine', 0.15, 0.2);
    }
    
    necroDeath() {
        // Dramatic echo fade
        this.playTone(200, 'sawtooth', 0.5, 0.5);
        this.playTone(150, 'sawtooth', 0.6, 0.4);
        this.playTone(100, 'sawtooth', 0.7, 0.3);
        this.playFilteredNoise(0.4, 0.4, 500, 'lowpass');
    }
    
    // ==================== HIT/DAMAGE SOUNDS ====================
    enemyHit() { 
        const pitch = 80 + Math.random() * 40;
        this.playTone(pitch, 'sawtooth', 0.1, 0.5); 
    }
    
    enemyDeath() {
        this.playTone(60, 'sawtooth', 0.2, 0.4);
        this.playFilteredNoise(0.3, 0.3, 500, 'lowpass');
    }
    
    playerHurt() { 
        this.playTone(50, 'sawtooth', 0.3, 0.8);
        this.playTone(70, 'square', 0.2, 0.4);
    }
    
    playerDeath() {
        this.playTone(40, 'sawtooth', 0.5, 0.6);
        this.playTone(30, 'square', 0.6, 0.4);
        this.playFilteredNoise(0.4, 0.5, 300, 'lowpass');
    }
    
    // ==================== UI SOUNDS ====================
    click() { 
        this.playTone(800, 'sine', 0.05, 0.3); 
    }
    
    menuOpen() {
        this.playTone(600, 'sine', 0.08, 0.2);
        this.playTone(800, 'sine', 0.08, 0.15);
    }
    
    menuClose() {
        this.playTone(800, 'sine', 0.08, 0.2);
        this.playTone(600, 'sine', 0.08, 0.15);
    }
    
    error() {
        this.playTone(200, 'square', 0.1, 0.4);
        this.playTone(150, 'square', 0.15, 0.3);
    }
    
    success() {
        this.playTone(800, 'sine', 0.1, 0.3);
        this.playTone(1000, 'sine', 0.1, 0.25);
        this.playTone(1200, 'sine', 0.15, 0.2);
    }
    
    // ==================== PICKUP SOUNDS ====================
    loot() { 
        this.playTone(1200, 'square', 0.1, 0.2); 
        this.playTone(1600, 'square', 0.1, 0.2); 
    }
    
    lootHealth() {
        this.playTone(600, 'sine', 0.1, 0.3);
        this.playTone(800, 'sine', 0.15, 0.25);
        this.playTone(1000, 'sine', 0.1, 0.2);
    }
    
    lootAmmo() {
        this.playTone(400, 'triangle', 0.08, 0.3);
        this.playFilteredNoise(0.1, 0.2, 2000, 'highpass');
    }
    
    lootWeapon() {
        this.playTone(500, 'square', 0.1, 0.3);
        this.playTone(700, 'square', 0.1, 0.25);
        this.playTone(900, 'square', 0.15, 0.3);
        this.playNoise(0.1, 0.2);
    }
    
    lootKey() {
        this.playTone(1000, 'sine', 0.15, 0.3);
        this.playTone(1500, 'sine', 0.2, 0.25);
        this.playTone(2000, 'sine', 0.1, 0.2);
    }
    
    // ==================== EQUIPMENT SOUNDS ====================
    toggleNVG() { 
        this.playTone(2000, 'sine', 0.2, 0.1); 
        this.playFilteredNoise(0.1, 0.1, 4000, 'highpass');
    }
    
    reload() { 
        this.playTone(400, 'triangle', 0.2, 0.4); 
        this.playFilteredNoise(0.1, 0.2, 1500, 'lowpass');
    }
    
    reloadFinish() { 
        this.playTone(600, 'triangle', 0.1, 0.5); 
        this.playTone(800, 'triangle', 0.1, 0.3); 
        this.playFilteredNoise(0.08, 0.15, 2000, 'highpass');
    }
    
    // ==================== MOVEMENT SOUNDS ====================
    dodge() { 
        this.playNoise(0.15, 0.3); 
        this.playTone(300, 'sine', 0.1, 0.2); 
    }
    
    footstep(time, isRunning = false) {
        if (time - this.lastFootstep < this.footstepInterval / (isRunning ? 1.5 : 1)) return;
        this.lastFootstep = time;
        
        const vol = isRunning ? 0.15 : 0.1;
        const pitch = 100 + Math.random() * 50;
        this.playFilteredNoise(0.05, vol, pitch * 10, 'lowpass');
    }
    
    // ==================== COMBAT SOUNDS ====================
    empty() { 
        this.playTone(200, 'square', 0.05, 0.3); 
    }
    
    melee() {
        this.playNoise(0.1, 0.4);
        this.playTone(250, 'sawtooth', 0.08, 0.3);
    }
    
    spit() { 
        this.playTone(150, 'sawtooth', 0.2, 0.4); 
        this.playNoise(0.15, 0.2); 
    }
    
    grenadeThrow() { 
        this.playTone(400, 'sine', 0.1, 0.3); 
        this.playNoise(0.08, 0.15);
    }
    
    explosion() { 
        this.playNoise(0.4, 0.8); 
        this.playTone(60, 'square', 0.3, 0.6); 
        this.playTone(40, 'sawtooth', 0.4, 0.5); 
        this.playFilteredNoise(0.5, 0.4, 200, 'lowpass');
    }
    
    // ==================== ENEMY SOUNDS ====================
    zombieGrowl() {
        const pitch = 80 + Math.random() * 40;
        this.playTone(pitch, 'sawtooth', 0.3, 0.2);
        this.playFilteredNoise(0.2, 0.15, 300, 'lowpass');
    }
    
    leaperPrepare() {
        this.playTone(200, 'sawtooth', 0.2, 0.3);
        this.playTone(300, 'square', 0.15, 0.2);
    }
    
    leaperLeap() {
        this.playTone(400, 'sawtooth', 0.15, 0.4);
        this.playNoise(0.2, 0.3);
    }
    
    banditShout() {
        this.playTone(150, 'square', 0.2, 0.25);
        this.playFilteredNoise(0.15, 0.2, 800, 'bandpass');
    }
    
    bossRoar() {
        this.playTone(50, 'sawtooth', 0.5, 0.5);
        this.playTone(70, 'square', 0.4, 0.4);
        this.playFilteredNoise(0.5, 0.4, 200, 'lowpass');
    }
    
    // ==================== LEVEL SOUNDS ====================
    levelStart() {
        this.playTone(400, 'sine', 0.2, 0.25);
        this.playTone(600, 'sine', 0.2, 0.2);
        this.playTone(800, 'sine', 0.3, 0.15);
    }
    
    levelComplete() {
        this.playTone(600, 'sine', 0.15, 0.3);
        this.playTone(800, 'sine', 0.15, 0.25);
        this.playTone(1000, 'sine', 0.15, 0.2);
        this.playTone(1200, 'sine', 0.3, 0.25);
    }
    
    extractionStart() {
        this.playTone(800, 'square', 0.3, 0.3);
        this.playTone(1000, 'square', 0.3, 0.25);
    }
    
    extractionTick() {
        this.playTone(600, 'sine', 0.1, 0.2);
    }
    
    achievement() {
        this.playTone(800, 'sine', 0.1, 0.3);
        this.playTone(1000, 'sine', 0.1, 0.25);
        this.playTone(1200, 'sine', 0.1, 0.2);
        this.playTone(1600, 'sine', 0.2, 0.3);
    }
    
    // ==================== DOOR/INTERACT SOUNDS ====================
    doorOpen() {
        this.playFilteredNoise(0.3, 0.3, 500, 'lowpass');
        this.playTone(200, 'triangle', 0.2, 0.2);
    }
    
    crateOpen() {
        this.playFilteredNoise(0.2, 0.25, 800, 'lowpass');
        this.playTone(300, 'triangle', 0.15, 0.2);
    }
    
    // ==================== TRADER SOUNDS ====================
    purchase() {
        this.playTone(800, 'sine', 0.1, 0.3);
        this.playTone(1000, 'sine', 0.15, 0.25);
        this.playTone(1200, 'sine', 0.1, 0.2);
    }
    
    sell() {
        this.playTone(600, 'sine', 0.1, 0.25);
        this.playTone(400, 'sine', 0.1, 0.2);
        this.playFilteredNoise(0.1, 0.15, 1000, 'highpass');
    }
    
    useConsumable() {
        this.playTone(1200, 'sine', 0.1, 0.3);
        this.playTone(1400, 'sine', 0.08, 0.25);
        this.playNoise(0.05, 0.15);
    }
}

const sfx = new SoundManager();

// =============================================================================
// PERSISTENT STATS & ACHIEVEMENTS MANAGER
// =============================================================================
function loadPersistent() {
    const saved = localStorage.getItem(PERSISTENT_KEY);
    if (saved) {
        const data = JSON.parse(saved);
        // Merge with defaults to handle new fields
        return { ...JSON.parse(JSON.stringify(DEFAULT_PERSISTENT)), ...data };
    }
    return JSON.parse(JSON.stringify(DEFAULT_PERSISTENT));
}

function savePersistent(data) {
    localStorage.setItem(PERSISTENT_KEY, JSON.stringify(data));
}

function resetRunStats(persistent) {
    persistent.runKills = 0;
    persistent.runShotsFired = 0;
    persistent.runShotsHit = 0;
    persistent.runDamageTaken = 0;
    persistent.runGrenadeKills = 0;
    persistent.runMeleeKills = 0;
    persistent.bossHitWithGun = false;
    return persistent;
}

function checkAchievements(persistent, context = {}) {
    const newAchievements = [];
    const a = CONFIG.ACHIEVEMENTS;
    
    // First Blood - kill first enemy
    if (!persistent.achievements.includes(a.FIRST_BLOOD.id) && persistent.totalKills >= 1) {
        persistent.achievements.push(a.FIRST_BLOOD.id);
        newAchievements.push(a.FIRST_BLOOD);
    }
    
    // Exterminator - kill 50 enemies
    if (!persistent.achievements.includes(a.EXTERMINATOR.id) && persistent.totalKills >= 50) {
        persistent.achievements.push(a.EXTERMINATOR.id);
        newAchievements.push(a.EXTERMINATOR);
    }
    
    // Sharpshooter - 50% accuracy in a run (min 20 shots)
    if (!persistent.achievements.includes(a.SHARPSHOOTER.id) && persistent.runShotsFired >= 20) {
        const accuracy = persistent.runShotsHit / persistent.runShotsFired;
        if (accuracy >= 0.5) {
            persistent.achievements.push(a.SHARPSHOOTER.id);
            newAchievements.push(a.SHARPSHOOTER);
        }
    }
    
    // Melee Master - kill boss with melee only (no gun hits on boss)
    if (!persistent.achievements.includes(a.MELEE_MASTER.id) && context.bossKilledMelee) {
        persistent.achievements.push(a.MELEE_MASTER.id);
        newAchievements.push(a.MELEE_MASTER);
    }
    
    // Survivor - complete first extraction
    if (!persistent.achievements.includes(a.SURVIVOR.id) && persistent.runsCompleted >= 1) {
        persistent.achievements.push(a.SURVIVOR.id);
        newAchievements.push(a.SURVIVOR);
    }
    
    // Veteran - complete 5 extractions
    if (!persistent.achievements.includes(a.VETERAN.id) && persistent.runsCompleted >= 5) {
        persistent.achievements.push(a.VETERAN.id);
        newAchievements.push(a.VETERAN);
    }
    
    // Grenadier - kill 3+ enemies with one grenade
    if (!persistent.achievements.includes(a.GRENADIER.id) && context.grenadeMultiKill >= 3) {
        persistent.achievements.push(a.GRENADIER.id);
        newAchievements.push(a.GRENADIER);
    }
    
    // Untouchable - complete level without damage
    if (!persistent.achievements.includes(a.UNTOUCHABLE.id) && context.levelCompletedNoDamage) {
        persistent.achievements.push(a.UNTOUCHABLE.id);
        newAchievements.push(a.UNTOUCHABLE);
    }
    
    // Scavenger - collect 100 scrap total
    if (!persistent.achievements.includes(a.SCAVENGER.id) && persistent.totalScrapCollected >= 100) {
        persistent.achievements.push(a.SCAVENGER.id);
        newAchievements.push(a.SCAVENGER);
    }
    
    // Fully Loaded - own all weapons
    if (!persistent.achievements.includes(a.FULLY_LOADED.id) && context.hasAllWeapons) {
        persistent.achievements.push(a.FULLY_LOADED.id);
        newAchievements.push(a.FULLY_LOADED);
    }
    
    return newAchievements;
}

// =============================================================================
// FLOATING TEXT POOL - Reuses text objects for performance
// =============================================================================
class FloatingTextPool {
    constructor(scene, poolSize = 20) {
        this.scene = scene;
        this.pool = [];
        for (let i = 0; i < poolSize; i++) {
            const text = scene.add.text(0, 0, '', {
                font: '16px Arial',
                stroke: '#000',
                strokeThickness: 3
            }).setOrigin(0.5).setDepth(101).setVisible(false);
            this.pool.push({ text, active: false });
        }
    }

    spawn(x, y, msg, color) {
        let item = this.pool.find(p => !p.active);
        if (!item) {
            const text = this.scene.add.text(x, y, msg, {
                font: '16px Arial',
                stroke: '#000',
                strokeThickness: 3
            }).setTint(color).setOrigin(0.5).setDepth(101);
            this.scene.tweens.add({
                targets: text,
                y: y - 50,
                alpha: 0,
                duration: 1500,
                onComplete: () => text.destroy()
            });
            return;
        }

        item.active = true;
        item.text.setPosition(x, y).setText(msg).setTint(color).setAlpha(1).setVisible(true);
        
        this.scene.tweens.add({
            targets: item.text,
            y: y - 50,
            alpha: 0,
            duration: 1500,
            onComplete: () => {
                item.text.setVisible(false);
                item.active = false;
            }
        });
    }
}

// =============================================================================
// PARTICLE POOL - For muzzle flashes and effects
// =============================================================================
class ParticlePool {
    constructor(scene, poolSize = 30) {
        this.scene = scene;
        this.pool = [];
        for (let i = 0; i < poolSize; i++) {
            const particle = scene.add.circle(0, 0, 8, 0xffff00)
                .setDepth(50).setVisible(false).setAlpha(0);
            this.pool.push({ particle, active: false });
        }
    }

    spawnMuzzleFlash(x, y, angle, size = 1) {
        // Spawn 3-5 particles for a flash effect
        const count = 3 + Math.floor(Math.random() * 3);
        for (let i = 0; i < count; i++) {
            let item = this.pool.find(p => !p.active);
            if (!item) continue;

            item.active = true;
            const spread = (Math.random() - 0.5) * 0.5;
            const dist = 20 + Math.random() * 15 * size;
            const px = x + Math.cos(angle + spread) * dist;
            const py = y + Math.sin(angle + spread) * dist;
            
            item.particle.setPosition(px, py)
                .setRadius(4 + Math.random() * 6 * size)
                .setFillStyle(Math.random() > 0.5 ? 0xffff00 : 0xffaa00)
                .setVisible(true)
                .setAlpha(1);

            this.scene.tweens.add({
                targets: item.particle,
                alpha: 0,
                scaleX: 0.1,
                scaleY: 0.1,
                duration: 80 + Math.random() * 40,
                onComplete: () => {
                    item.particle.setVisible(false).setScale(1);
                    item.active = false;
                }
            });
        }
    }
}

// =============================================================================
// HIT DIRECTION INDICATOR POOL
// =============================================================================
class HitIndicatorPool {
    constructor(scene, poolSize = 8) {
        this.scene = scene;
        this.pool = [];
        this.settings = loadSettings();
        
        for (let i = 0; i < poolSize; i++) {
            // Create arrow-shaped indicator
            const graphics = scene.add.graphics().setDepth(104).setVisible(false);
            this.pool.push({ graphics, active: false });
        }
    }
    
    // Show hit indicator from a specific direction (in radians)
    showHit(fromX, fromY, playerX, playerY) {
        if (!this.settings.hitIndicators) return;
        
        let item = this.pool.find(p => !p.active);
        if (!item) return;
        
        item.active = true;
        const g = item.graphics;
        g.clear();
        g.setVisible(true);
        g.setAlpha(0.8);
        
        // Calculate angle from player to damage source
        const angle = Phaser.Math.Angle.Between(playerX, playerY, fromX, fromY);
        
        // Draw directional indicator (arrow pointing toward damage source)
        const dist = CONFIG.UI.HIT_INDICATOR_DISTANCE;
        const size = CONFIG.UI.HIT_INDICATOR_SIZE;
        
        // Center of screen
        const cx = 400;
        const cy = 300;
        
        // Position the indicator on the edge of the screen based on angle
        const indicatorX = cx + Math.cos(angle) * dist * 2;
        const indicatorY = cy + Math.sin(angle) * dist * 2;
        
        // Draw red arrow/chevron pointing inward
        g.lineStyle(4, 0xff0000, 1);
        g.fillStyle(0xff0000, 0.6);
        
        // Arrow shape pointing toward center
        const tipX = indicatorX - Math.cos(angle) * size * 0.5;
        const tipY = indicatorY - Math.sin(angle) * size * 0.5;
        
        const leftX = indicatorX + Math.cos(angle + Math.PI * 0.7) * size * 0.4;
        const leftY = indicatorY + Math.sin(angle + Math.PI * 0.7) * size * 0.4;
        
        const rightX = indicatorX + Math.cos(angle - Math.PI * 0.7) * size * 0.4;
        const rightY = indicatorY + Math.sin(angle - Math.PI * 0.7) * size * 0.4;
        
        g.beginPath();
        g.moveTo(tipX, tipY);
        g.lineTo(leftX, leftY);
        g.lineTo(indicatorX, indicatorY);
        g.lineTo(rightX, rightY);
        g.closePath();
        g.fillPath();
        g.strokePath();
        
        // Fade out
        this.scene.tweens.add({
            targets: g,
            alpha: 0,
            duration: CONFIG.UI.HIT_INDICATOR_DURATION,
            onComplete: () => {
                g.setVisible(false);
                g.clear();
                item.active = false;
            }
        });
    }
    
    reloadSettings() {
        this.settings = loadSettings();
    }
}

// =============================================================================
// MAIN MENU SCENE
// =============================================================================
class MainMenuScene extends Phaser.Scene {
    constructor() { super('MainMenuScene'); }
    
    create() {
        this.input.on('pointerdown', () => sfx.resume());

        this.add.rectangle(400, 300, 800, 600, 0x111111);
        this.add.grid(400, 300, 800, 600, 64, 64, 0x222222).setAlpha(0.2);
        this.add.text(400, 100, "ZOMBIE EXTRACTION", { fontSize: '64px', fill: '#00ff00', fontStyle: 'bold' }).setOrigin(0.5);
        this.add.text(400, 160, "BUILD 18.0 (MISSION MAP)", { fontSize: '24px', fill: '#555' }).setOrigin(0.5);

        this.createButton(400, 240, "NEW RUN", 0x880000, () => {
            if(confirm("Start a new run? This overwrites current auto-save.")) {
                localStorage.removeItem(CONFIG.SAVE_KEY);
                sfx.levelStart();
                this.scene.start('GameScene', { level: 1, stats: JSON.parse(JSON.stringify(DEFAULT_STATS)) });
            }
        });

        this.createButton(400, 300, "CONTINUE", 0x004488, () => {
            let saved = localStorage.getItem(CONFIG.SAVE_KEY);
            if (saved) {
                try {
                    let stats = JSON.parse(saved);
                    // Validate critical fields exist
                    if (stats.hp === undefined || stats.hideout === undefined) {
                        throw new Error("Invalid save data");
                    }
                    // Ensure magazines exist for old saves
                    if (!stats.magazines) {
                        stats.magazines = {
                            pistol: CONFIG.WEAPONS.PISTOL.MAG_SIZE,
                            shotgun: CONFIG.WEAPONS.SHOTGUN.MAG_SIZE,
                            smg: CONFIG.WEAPONS.SMG.MAG_SIZE,
                            crossbow: CONFIG.WEAPONS.CROSSBOW.MAG_SIZE,
                            rifle: CONFIG.WEAPONS.RIFLE.MAG_SIZE
                        };
                    }
                    // Ensure new weapon magazines exist
                    if (stats.magazines.crossbow === undefined) stats.magazines.crossbow = CONFIG.WEAPONS.CROSSBOW.MAG_SIZE;
                    if (stats.magazines.rifle === undefined) stats.magazines.rifle = CONFIG.WEAPONS.RIFLE.MAG_SIZE;
                    // Ensure new weapon flags exist
                    if (stats.hasCrossbow === undefined) stats.hasCrossbow = false;
                    if (stats.hasRifle === undefined) stats.hasRifle = false;
                    // Ensure currentWeapon is valid (fixes null rendering)
                    if (!stats.currentWeapon) stats.currentWeapon = 'pistol';
                    // Ensure nextLevel exists
                    if (stats.nextLevel === undefined) stats.nextLevel = 1;
                    // Ensure highestLevelUnlocked exists (default to nextLevel for old saves)
                    if (stats.highestLevelUnlocked === undefined) {
                        stats.highestLevelUnlocked = stats.nextLevel || 1;
                    }
                    // Ensure consumables is a valid array
                    if (!stats.consumables || !Array.isArray(stats.consumables)) {
                        stats.consumables = [null, null, null];
                    }
                    while (stats.consumables.length < 3) {
                        stats.consumables.push(null);
                    }
                    sfx.menuOpen();
                    this.scene.start('HideoutScene', { stats });
                } catch (e) {
                    sfx.error();
                    alert("Save data corrupted. Please start a new game.");
                    localStorage.removeItem(CONFIG.SAVE_KEY);
                }
            } else {
                sfx.error();
                alert("No save found!");
            }
        });
        
        this.createButton(400, 360, "SETTINGS", 0x555555, () => {
            sfx.menuOpen();
            this.showSettingsMenu();
        });

        this.createButton(400, 440, "EXPORT SAVE TO FILE", 0x444444, () => {
            let saved = localStorage.getItem(CONFIG.SAVE_KEY);
            if (!saved) { sfx.error(); alert("No save data to export."); return; }
            
            const blob = new Blob([saved], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `zombie_save_${new Date().toISOString().slice(0,10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            sfx.success();
        });

        this.createButton(400, 500, "IMPORT SAVE FROM FILE", 0x444444, () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const json = JSON.parse(event.target.result);
                        if (json.hp !== undefined && json.hideout !== undefined) {
                            localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(json));
                            sfx.success();
                            alert("Save imported successfully!");
                        } else {
                            sfx.error();
                            alert("Invalid save file format.");
                        }
                    } catch (err) {
                        sfx.error();
                        alert("Error reading file.");
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        });

        const cheatBtn = this.add.text(10, 570, "[ CHEAT CODE ]", { fontSize: '16px', fill: '#444' }).setInteractive();
        cheatBtn.on('pointerdown', () => {
            sfx.click();
            const code = prompt("ENTER CHEAT CODE:");
            if (code === 'god mode') this.activateGodMode();
        });
        
        // Level select for testing
        const levelBtn = this.add.text(790, 570, "[ LEVEL SELECT ]", { fontSize: '16px', fill: '#444' }).setOrigin(1, 0).setInteractive();
        levelBtn.on('pointerdown', () => {
            sfx.click();
            this.showLevelSelect();
        });
    }
    
    showSettingsMenu() {
        const settings = loadSettings();
        const elements = [];
        
        // Overlay background
        const overlay = this.add.rectangle(400, 300, 500, 400, 0x111111, 0.95).setDepth(500);
        elements.push(overlay);
        
        const title = this.add.text(400, 130, "SETTINGS", { fontSize: '32px', fill: '#fff' }).setOrigin(0.5).setDepth(501);
        elements.push(title);
        
        // Master Volume Slider
        const masterLabel = this.add.text(200, 180, "MASTER VOLUME", { fontSize: '16px', fill: '#aaa' }).setDepth(501);
        elements.push(masterLabel);
        
        const masterSliderBg = this.add.rectangle(400, 210, 300, 20, 0x333333).setDepth(501);
        elements.push(masterSliderBg);
        
        const masterSliderFill = this.add.rectangle(250 + settings.masterVolume * 150, 210, settings.masterVolume * 300, 16, 0x00ff00).setOrigin(0, 0.5).setDepth(502);
        masterSliderFill.setPosition(250, 210);
        masterSliderFill.width = settings.masterVolume * 300;
        elements.push(masterSliderFill);
        
        const masterPercent = this.add.text(560, 210, `${Math.round(settings.masterVolume * 100)}%`, { fontSize: '14px', fill: '#fff' }).setOrigin(0, 0.5).setDepth(501);
        elements.push(masterPercent);
        
        masterSliderBg.setInteractive();
        masterSliderBg.on('pointerdown', (pointer) => {
            const relX = (pointer.x - 250) / 300;
            const newVol = Phaser.Math.Clamp(relX, 0, 1);
            settings.masterVolume = newVol;
            sfx.setMasterVolume(newVol);
            masterSliderFill.width = newVol * 300;
            masterPercent.setText(`${Math.round(newVol * 100)}%`);
            sfx.click();
        });
        
        // SFX Volume Slider
        const sfxLabel = this.add.text(200, 250, "SFX VOLUME", { fontSize: '16px', fill: '#aaa' }).setDepth(501);
        elements.push(sfxLabel);
        
        const sfxSliderBg = this.add.rectangle(400, 280, 300, 20, 0x333333).setDepth(501);
        elements.push(sfxSliderBg);
        
        const sfxSliderFill = this.add.rectangle(250, 280, settings.sfxVolume * 300, 16, 0x00aaff).setOrigin(0, 0.5).setDepth(502);
        elements.push(sfxSliderFill);
        
        const sfxPercent = this.add.text(560, 280, `${Math.round(settings.sfxVolume * 100)}%`, { fontSize: '14px', fill: '#fff' }).setOrigin(0, 0.5).setDepth(501);
        elements.push(sfxPercent);
        
        sfxSliderBg.setInteractive();
        sfxSliderBg.on('pointerdown', (pointer) => {
            const relX = (pointer.x - 250) / 300;
            const newVol = Phaser.Math.Clamp(relX, 0, 1);
            settings.sfxVolume = newVol;
            sfx.setSfxVolume(newVol);
            sfxSliderFill.width = newVol * 300;
            sfxPercent.setText(`${Math.round(newVol * 100)}%`);
            sfx.click();
        });
        
        // Screen Shake Toggle
        const shakeLabel = this.add.text(200, 330, "SCREEN SHAKE", { fontSize: '16px', fill: '#aaa' }).setDepth(501);
        elements.push(shakeLabel);
        
        const shakeToggle = this.add.rectangle(500, 330, 80, 30, settings.screenShake ? 0x00ff00 : 0x444444).setDepth(501).setInteractive();
        elements.push(shakeToggle);
        
        const shakeText = this.add.text(500, 330, settings.screenShake ? "ON" : "OFF", { fontSize: '14px', fill: '#fff' }).setOrigin(0.5).setDepth(502);
        elements.push(shakeText);
        
        shakeToggle.on('pointerdown', () => {
            settings.screenShake = !settings.screenShake;
            shakeToggle.setFillStyle(settings.screenShake ? 0x00ff00 : 0x444444);
            shakeText.setText(settings.screenShake ? "ON" : "OFF");
            saveSettings(settings);
            sfx.click();
        });
        
        // Hit Indicators Toggle
        const hitLabel = this.add.text(200, 380, "HIT INDICATORS", { fontSize: '16px', fill: '#aaa' }).setDepth(501);
        elements.push(hitLabel);
        
        const hitToggle = this.add.rectangle(500, 380, 80, 30, settings.hitIndicators ? 0x00ff00 : 0x444444).setDepth(501).setInteractive();
        elements.push(hitToggle);
        
        const hitText = this.add.text(500, 380, settings.hitIndicators ? "ON" : "OFF", { fontSize: '14px', fill: '#fff' }).setOrigin(0.5).setDepth(502);
        elements.push(hitText);
        
        hitToggle.on('pointerdown', () => {
            settings.hitIndicators = !settings.hitIndicators;
            hitToggle.setFillStyle(settings.hitIndicators ? 0x00ff00 : 0x444444);
            hitText.setText(settings.hitIndicators ? "ON" : "OFF");
            saveSettings(settings);
            sfx.click();
        });
        
        // Close button
        const closeBtn = this.add.text(400, 460, "[ CLOSE ]", { fontSize: '18px', fill: '#ff4444' }).setOrigin(0.5).setDepth(501).setInteractive();
        elements.push(closeBtn);
        
        closeBtn.on('pointerdown', () => {
            sfx.menuClose();
            elements.forEach(e => e.destroy());
        });
    }
    
    showLevelSelect() {
        // Create level select overlay
        const overlay = this.add.rectangle(400, 300, 500, 450, 0x111111, 0.95).setDepth(500);
        const title = this.add.text(400, 100, "SELECT LEVEL", { fontSize: '32px', fill: '#fff' }).setOrigin(0.5).setDepth(501);
        const subtitle = this.add.text(400, 135, "(starts with full gear)", { fontSize: '14px', fill: '#888' }).setOrigin(0.5).setDepth(501);
        
        const levels = [
            { num: 1, name: "Street", color: 0x2d5a27 },
            { num: 2, name: "Apartment", color: 0x444444 },
            { num: 3, name: "Rooftop", color: 0x1a1a2e },
            { num: 4, name: "Sewers", color: 0x2a3a2a },
            { num: 5, name: "Hospital", color: 0xddeedd },
            { num: 6, name: "Mall", color: 0x8B4513 },
            { num: 7, name: "Cemetery", color: 0x1a1a1a }
        ];
        
        const elements = [overlay, title, subtitle];
        
        levels.forEach((lvl, i) => {
            const btn = this.add.rectangle(400, 170 + i * 45, 300, 38, lvl.color).setInteractive().setDepth(501);
            const txt = this.add.text(400, 170 + i * 45, `${lvl.num}. ${lvl.name}`, { fontSize: '18px', fill: '#fff' }).setOrigin(0.5).setDepth(502);
            btn.on('pointerdown', () => {
                sfx.click();
                this.startAtLevel(lvl.num);
            });
            btn.on('pointerover', () => btn.setAlpha(0.7));
            btn.on('pointerout', () => btn.setAlpha(1));
            elements.push(btn, txt);
        });
        
        const closeBtn = this.add.text(400, 510, "[ CANCEL ]", { fontSize: '16px', fill: '#ff4444' }).setOrigin(0.5).setDepth(501).setInteractive();
        closeBtn.on('pointerdown', () => {
            sfx.click();
            elements.forEach(e => e.destroy());
            closeBtn.destroy();
        });
    }
    
    startAtLevel(level) {
        // Create stats with full gear for testing
        const testStats = {
            hp: 20, maxHp: 20, stamina: 100, maxStamina: 100, ammo: 200, scrap: 50,
            credits: 100, materials: 50,
            grenades: CONFIG.GRENADE.MAX_CARRY,
            nextLevel: level,
            highestLevelUnlocked: 7,  // All levels unlocked for testing
            consumables: ['adrenaline', 'armor_patch', null],  // Include test consumables
            hasFlashlight: true, hasShotgun: true, hasSMG: true, hasCrossbow: true, hasRifle: true, currentWeapon: 'shotgun',
            magazines: {
                pistol: CONFIG.WEAPONS.PISTOL.MAG_SIZE,
                shotgun: CONFIG.WEAPONS.SHOTGUN.MAG_SIZE,
                smg: CONFIG.WEAPONS.SMG.MAG_SIZE,
                crossbow: CONFIG.WEAPONS.CROSSBOW.MAG_SIZE,
                rifle: CONFIG.WEAPONS.RIFLE.MAG_SIZE
            },
            armor: {
                head: { name: 'HELMET', durability: 3, maxDurability: 3 },
                body: { name: 'VEST', durability: 5, maxDurability: 5 },
                arms: null,
                feet: null
            },
            hideout: {
                restAreaLvl: 1, generatorLvl: 1, hasSparkPlug: true,
                armory: { crafting: null, hasNVG: true },
                workbenchLvl: 1, repairStationLvl: 1
            }
        };
        this.scene.start('GameScene', { level: level, stats: testStats });
    }

    createButton(x, y, text, color, callback) {
        let btn = this.add.rectangle(x, y, 350, 50, color).setInteractive();
        this.add.text(x, y, text, { fontSize: '24px', fill: '#fff' }).setOrigin(0.5);
        btn.on('pointerdown', () => { sfx.click(); callback(); });
        btn.on('pointerover', () => btn.setAlpha(0.8));
        btn.on('pointerout', () => btn.setAlpha(1));
    }

    activateGodMode() {
        const godStats = {
            hp: 20, maxHp: 20, stamina: 100, maxStamina: 100, ammo: 999, scrap: 999,
            credits: 999, materials: 999,
            grenades: CONFIG.GRENADE.MAX_CARRY,
            nextLevel: 1,
            highestLevelUnlocked: 7,  // All levels unlocked in god mode
            consumables: ['adrenaline', 'armor_patch', 'adrenaline'],  // Full consumables
            hasFlashlight: true, hasShotgun: true, hasSMG: true, hasCrossbow: true, hasRifle: true, currentWeapon: 'shotgun',
            magazines: {
                pistol: CONFIG.WEAPONS.PISTOL.MAG_SIZE,
                shotgun: CONFIG.WEAPONS.SHOTGUN.MAG_SIZE,
                smg: CONFIG.WEAPONS.SMG.MAG_SIZE,
                crossbow: CONFIG.WEAPONS.CROSSBOW.MAG_SIZE,
                rifle: CONFIG.WEAPONS.RIFLE.MAG_SIZE
            },
            armor: {
                head: { name: 'GOD HELM', durability: 100, maxDurability: 100 },
                body: { name: 'GOD VEST', durability: 100, maxDurability: 100 },
                arms: { name: 'GOD ARMS', durability: 100, maxDurability: 100 },
                feet: { name: 'GOD BOOTS', durability: 100, maxDurability: 100 }
            },
            hideout: {
                restAreaLvl: 2, generatorLvl: 1, hasSparkPlug: true,
                armory: { crafting: null, hasNVG: true },
                workbenchLvl: 1, repairStationLvl: 1
            }
        };
        localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(godStats));
        alert("GOD MODE ACTIVATED");
        this.scene.start('HideoutScene', { stats: godStats });
    }
}

// =============================================================================
// BULLET CLASS
// =============================================================================
class Bullet extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y) { 
        super(scene, x, y, 'bullet'); 
    }
    
    fire(x, y, targetX, targetY, spreadAngle = 0, isEnemy = false) {
        this.body.reset(x, y);
        this.body.enable = true; 
        this.setActive(true);
        this.setVisible(true);
        this.hasHit = false;
        this.isEnemyBullet = isEnemy; 
        this.setTint(isEnemy ? 0xff0000 : 0xffff00);
        
        // Reset pooled bullet properties
        this.hitEnemies = new Set();
        this.isPiercing = false;
        this.pierceCount = 0;
        this.crossbowDamage = 0;
        this.rifleDamage = 0;
        
        if (isEnemy) sfx.shootPistol();

        let baseAngle = Phaser.Math.Angle.Between(x, y, targetX, targetY);
        let finalAngle = baseAngle + Phaser.Math.DegToRad(spreadAngle);
        this.scene.physics.velocityFromRotation(finalAngle, CONFIG.WEAPONS.BULLET_SPEED, this.body.velocity);
        this.setRotation(finalAngle);
    }
    
    preUpdate(time, delta) {
        super.preUpdate(time, delta);
        if (this.y < -50 || this.y > 650 || this.x < -50 || this.x > 850) {
            this.setActive(false);
            this.setVisible(false);
            this.body.enable = false;
        }
    }
}

// =============================================================================
// ENEMY CLASS
// =============================================================================
class Enemy extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y, target, type) {
        const cfg = CONFIG.ENEMIES[type.toUpperCase()] || CONFIG.ENEMIES.WALKER;
        super(scene, x, y, cfg.TEXTURE);
        
        scene.add.existing(this);
        scene.physics.add.existing(this);
        
        this.target = target;
        this.enemyType = type;
        this.config = cfg;
        this.canTakeDamage = true;
        this.healthBar = scene.add.graphics().setDepth(100).setVisible(false);
        this.lastFired = 0;
        this.isInvulnerable = false;

        this.hp = cfg.HP;
        this.maxHp = cfg.HP;
        this.speed = cfg.SPEED;
        this.damage = cfg.DAMAGE;

        if (type === 'boss') {
            this.setScale(cfg.SCALE);
            this.setTint(0xff0000);
        } else if (type === 'leaper') {
            this.state = 'CHASE';
            this.leapTimer = 0;
        } else if (type === 'bandit') {
            this.ammo = cfg.AMMO;
            this.state = 'CHASE';
        } else if (type === 'spitter') {
            this.lastSpit = 0;
            this.setTint(0x00ff00); // Green tint for toxic look
        } else if (type === 'exploder') {
            this.setTint(0xff6600); // Orange tint for explosive look
            this.setScale(1.2); // Slightly bloated
            // Pulsing effect
            this.scene.tweens.add({
                targets: this,
                scaleX: 1.3,
                scaleY: 1.3,
                duration: 500,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });
        } else if (type === 'necromancer') {
            this.setTint(0x8800ff); // Purple tint
            this.setScale(1.5);
            this.phase = 'SUMMON'; // SUMMON, VULNERABLE, ATTACK
            this.phaseTimer = 0;
            this.lastTeleport = 0;
            this.summonedMinions = [];
            this.isInvulnerable = true; // Starts invulnerable
        }
    }
    
    takeDamage(amount, killSource = 'gun') {
        if (!this.active || !this.canTakeDamage || this.isInvulnerable) return;
        
        this.lastDamageSource = killSource; // Track what damaged us
        this.hp -= amount;
        sfx.enemyHit();
        this.setTint(0xffffff);
        this.scene.time.delayedCall(50, () => { if (this.active) this.clearTint(); });
        this.updateHealthBar();
        
        if (this.enemyType === 'boss' || this.enemyType === 'necromancer') {
            this.scene.updateBossBar(this.hp, this.maxHp);
            this.canTakeDamage = false;
            this.isInvulnerable = true;
            this.flashTween = this.scene.tweens.add({
                targets: this,
                alpha: 0.5,
                duration: 100,
                yoyo: true,
                repeat: 4,
                onComplete: () => {
                    if (this.active) {
                        this.setAlpha(1);
                        this.canTakeDamage = true;
                        this.isInvulnerable = false;
                    }
                }
            });
        }
        
            if (this.hp <= 0) {
            // Check for melee-only boss kill achievement
            const bossKilledMelee = this.enemyType === 'boss' && !this.scene.persistent.bossHitWithGun;
            
            // Play death sound
            sfx.enemyDeath();
            
            // Exploder explosion on death
            if (this.enemyType === 'exploder') {
                this.scene.exploderExplosion(this.x, this.y);
            }
            
            // Necromancer special death
            if (this.enemyType === 'necromancer') {
                sfx.necroDeath();
                this.scene.showFloatingText(this.x, this.y, "VANQUISHED!", 0x8800ff);
                // Kill any remaining minions
                this.summonedMinions.forEach(m => {
                    if (m.active) m.takeDamage(100);
                });
            }
            
            if (this.enemyType === 'boss' && this.scene.currentLevel === 5) {
                this.scene.spawnSwitch(this.x, this.y);
            }
            
            // Necromancer on level 7 spawns switch
            if (this.enemyType === 'necromancer' && this.scene.currentLevel === 7) {
                this.scene.spawnSwitch(this.x, this.y);
            }
            
            this.scene.spawnLootSkull(this.x, this.y, this.enemyType, this.lastDamageSource);
            
            // Check melee master achievement for boss
            if (bossKilledMelee && this.lastDamageSource === 'melee') {
                const newAchievements = checkAchievements(this.scene.persistent, { bossKilledMelee: true });
                newAchievements.forEach(a => {
                    sfx.achievement();
                    this.scene.showFloatingText(400, 200, `${a.icon} ${a.name}!`, 0xffd700);
                });
                savePersistent(this.scene.persistent);
            }
            
            this.destroy();
        }
    }
    
    updateHealthBar() {
        if (this.hp <= 0) { this.healthBar.setVisible(false); return; }
        this.healthBar.setVisible(true);
        this.healthBar.clear();
        const w = 40, h = 6, x = -w / 2, y = -40;
        this.healthBar.fillStyle(0xff0000);
        this.healthBar.fillRect(x, y, w, h);
        this.healthBar.fillStyle(0x00ff00);
        this.healthBar.fillRect(x, y, w * (this.hp / this.maxHp), h);
    }
    
    knockBack() {
        const speed = (this.enemyType === 'leaper') ? CONFIG.ENEMIES.LEAPER.KNOCKBACK_SPEED : CONFIG.ENEMIES.KNOCKBACK_SPEED;
        if (this.enemyType === 'leaper') {
            this.state = 'COOLDOWN';
            this.leapTimer = CONFIG.ENEMIES.LEAPER.COOLDOWN_TIME;
        }
        const angle = Phaser.Math.Angle.Between(this.target.x, this.target.y, this.x, this.y);
        this.scene.physics.velocityFromRotation(angle, speed, this.body.velocity);
    }
    
    update(time, delta) {
        if (!this.active || !this.body) return;
        if (this.healthBar) this.healthBar.setPosition(this.x, this.y);

        const cfg = this.config;

        if (this.enemyType === 'bandit') {
            const dist = Phaser.Math.Distance.Between(this.x, this.y, this.target.x, this.target.y);
            if (this.ammo > 0) {
                if (dist < cfg.FIRE_RANGE) {
                    this.setVelocity(0);
                    if (time - this.lastFired > cfg.FIRE_RATE) {
                        const b = this.scene.bullets.get(this.x, this.y);
                        if (b) {
                            b.fire(this.x, this.y, this.target.x, this.target.y, Phaser.Math.Between(-cfg.SPREAD, cfg.SPREAD), true);
                            this.ammo--;
                            this.lastFired = time;
                        }
                    }
                } else {
                    this.scene.physics.moveToObject(this, this.target, this.speed);
                }
            } else {
                this.scene.physics.moveToObject(this, this.target, cfg.MELEE_SPEED);
            }
            return;
        }

        if (this.enemyType === 'spitter') {
            const dist = Phaser.Math.Distance.Between(this.x, this.y, this.target.x, this.target.y);
            if (dist < cfg.SPIT_RANGE) {
                this.setVelocity(0);
                if (time - this.lastSpit > cfg.SPIT_COOLDOWN) {
                    // Spit acid at player
                    this.scene.spawnAcidSpit(this.x, this.y, this.target.x, this.target.y);
                    this.lastSpit = time;
                    sfx.spit();
                    // Visual feedback - flash when spitting
                    this.setTint(0xffff00);
                    this.scene.time.delayedCall(100, () => { if (this.active) this.setTint(0x00ff00); });
                }
            } else {
                this.scene.physics.moveToObject(this, this.target, this.speed);
            }
            return;
        }

        if (this.enemyType === 'boss') {
            this.scene.physics.moveToObject(this, this.target, this.speed);
        } else if (this.enemyType === 'walker') {
            // Patrol enemies are handled separately
            if (this.isPatrol) return;
            if (Phaser.Math.Distance.Between(this.x, this.y, this.target.x, this.target.y) < cfg.AGGRO_RANGE) {
                this.scene.physics.moveToObject(this, this.target, this.speed);
            }
        } else if (this.enemyType === 'leaper') {
            const dist = Phaser.Math.Distance.Between(this.x, this.y, this.target.x, this.target.y);
            switch (this.state) {
                case 'CHASE':
                    this.scene.physics.moveToObject(this, this.target, cfg.SPEED);
                    if (dist < cfg.LEAP_RANGE) {
                        this.state = 'PREPARE';
                        this.setVelocity(0);
                        this.setTint(0xffaa00);
                        this.leapTimer = cfg.PREPARE_TIME;
                        sfx.leaperPrepare();
                    }
                    break;
                case 'PREPARE':
                    this.leapTimer -= delta;
                    if (this.leapTimer <= 0) {
                        this.state = 'LEAP';
                        this.clearTint();
                        this.scene.physics.moveToObject(this, this.target, cfg.LEAP_SPEED);
                        this.leapTimer = cfg.LEAP_DURATION;
                        sfx.leaperLeap();
                    }
                    break;
                case 'LEAP':
                    this.leapTimer -= delta;
                    if (this.leapTimer <= 0) {
                        this.state = 'COOLDOWN';
                        this.setVelocity(0);
                        this.leapTimer = cfg.COOLDOWN_TIME;
                    }
                    break;
                case 'PINNING':
                    break;
                case 'COOLDOWN':
                    this.leapTimer -= delta;
                    if (this.leapTimer <= 0) this.state = 'CHASE';
                    break;
            }
        } else if (this.enemyType === 'exploder') {
            // Exploder just charges directly at player at high speed
            this.scene.physics.moveToObject(this, this.target, this.speed);
            // Play warning sound periodically
            if (!this.lastWarning || time - this.lastWarning > 1000) {
                sfx.exploderWarning();
                this.lastWarning = time;
            }
        } else if (this.enemyType === 'necromancer') {
            // Necromancer boss phases
            this.updateNecromancerAI(time, delta);
        }
    }
    
    updateNecromancerAI(time, delta) {
        const cfg = CONFIG.ENEMIES.NECROMANCER;
        
        switch (this.phase) {
            case 'SUMMON':
                this.setVelocity(0);
                if (!this.hasSummoned) {
                    this.hasSummoned = true;
                    // Summon minions
                    for (let i = 0; i < cfg.SUMMON_COUNT; i++) {
                        const angle = (i / cfg.SUMMON_COUNT) * Math.PI * 2;
                        const spawnX = this.x + Math.cos(angle) * 100;
                        const spawnY = this.y + Math.sin(angle) * 100;
                        const minion = new Enemy(this.scene, spawnX, spawnY, this.target, 'walker');
                        this.scene.enemies.add(minion);
                        this.summonedMinions.push(minion);
                        // Summon visual effect
                        this.scene.showFloatingText(spawnX, spawnY, "RISE!", 0x8800ff);
                    }
                    sfx.necroSummon();
                    this.isInvulnerable = true;
                    this.setTint(0x8800ff);
                }
                // Check if all minions are dead
                this.summonedMinions = this.summonedMinions.filter(m => m.active);
                if (this.summonedMinions.length === 0) {
                    this.phase = 'VULNERABLE';
                    this.phaseTimer = cfg.VULNERABLE_TIME;
                    this.isInvulnerable = false;
                    this.setTint(0xff00ff); // Bright purple when vulnerable
                    sfx.necroVulnerable();
                    this.scene.showFloatingText(this.x, this.y - 40, "VULNERABLE!", 0xff00ff);
                }
                break;
                
            case 'VULNERABLE':
                this.phaseTimer -= delta;
                // Attack while vulnerable
                if (time - this.lastFired > 1500) {
                    this.fireNecroProjectile();
                    this.lastFired = time;
                }
                // Teleport periodically
                if (time - this.lastTeleport > cfg.TELEPORT_COOLDOWN) {
                    this.teleport();
                    this.lastTeleport = time;
                }
                if (this.phaseTimer <= 0) {
                    this.phase = 'SUMMON';
                    this.hasSummoned = false;
                    this.isInvulnerable = true;
                    this.setTint(0x8800ff);
                }
                break;
        }
    }
    
    fireNecroProjectile() {
        const cfg = CONFIG.ENEMIES.NECROMANCER;
        const angle = Phaser.Math.Angle.Between(this.x, this.y, this.target.x, this.target.y);
        // Create acid-like projectile
        this.scene.spawnNecroProjectile(this.x, this.y, this.target.x, this.target.y);
        sfx.necroProjectile();
    }
    
    teleport() {
        // Teleport to random position in arena
        const newX = Phaser.Math.Between(150, 650);
        const newY = Phaser.Math.Between(100, 300);
        
        // Teleport effect
        this.scene.tweens.add({
            targets: this,
            alpha: 0,
            duration: 200,
            onComplete: () => {
                this.setPosition(newX, newY);
                this.scene.tweens.add({
                    targets: this,
                    alpha: 1,
                    duration: 200
                });
            }
        });
        sfx.necroTeleport();
    }
    
    destroy(fromScene) {
        if (this.healthBar) this.healthBar.destroy();
        if (this.flashTween) this.flashTween.stop();
        super.destroy(fromScene);
    }
}

// =============================================================================
// HIDEOUT SCENE
// =============================================================================
class HideoutScene extends Phaser.Scene {
    constructor() { super('HideoutScene'); }
    
    create(data) {
        // Clean up any lingering references from previous scene
        this.mapNodes = null;
        this.mapElements = null;
        this.mapInfoText = null;
        this.mapStatusText = null;
        this.selectedLevel = null;
        
        this.stats = data.stats;
        // Ensure magazines exist
        if (!this.stats.magazines) {
            this.stats.magazines = {
                pistol: CONFIG.WEAPONS.PISTOL.MAG_SIZE,
                shotgun: CONFIG.WEAPONS.SHOTGUN.MAG_SIZE,
                smg: CONFIG.WEAPONS.SMG.MAG_SIZE,
                crossbow: CONFIG.WEAPONS.CROSSBOW.MAG_SIZE,
                rifle: CONFIG.WEAPONS.RIFLE.MAG_SIZE
            };
        }
        // Ensure new weapon magazines exist
        if (this.stats.magazines.crossbow === undefined) this.stats.magazines.crossbow = CONFIG.WEAPONS.CROSSBOW.MAG_SIZE;
        if (this.stats.magazines.rifle === undefined) this.stats.magazines.rifle = CONFIG.WEAPONS.RIFLE.MAG_SIZE;
        // Ensure new weapon flags exist
        if (this.stats.hasCrossbow === undefined) this.stats.hasCrossbow = false;
        if (this.stats.hasRifle === undefined) this.stats.hasRifle = false;
        // Ensure grenades exist for old saves
        if (this.stats.grenades === undefined) {
            this.stats.grenades = 0;
        }
        // Ensure new hideout fields exist
        if (this.stats.hideout.workbenchLvl === undefined) {
            this.stats.hideout.workbenchLvl = 0;
        }
        if (this.stats.hideout.repairStationLvl === undefined) {
            this.stats.hideout.repairStationLvl = 0;
        }
        // Ensure new currency fields exist
        if (this.stats.credits === undefined) {
            this.stats.credits = 0;
        }
        if (this.stats.materials === undefined) {
            this.stats.materials = 0;
        }
        // Ensure consumables is a valid array
        if (!this.stats.consumables || !Array.isArray(this.stats.consumables)) {
            this.stats.consumables = [null, null, null];
        }
        while (this.stats.consumables.length < 3) {
            this.stats.consumables.push(null);
        }
        // Ensure nextLevel exists for old saves
        if (this.stats.nextLevel === undefined) {
            this.stats.nextLevel = 1;
        }
        // Ensure highestLevelUnlocked exists (default to nextLevel for old saves)
        if (this.stats.highestLevelUnlocked === undefined) {
            this.stats.highestLevelUnlocked = this.stats.nextLevel || 1;
        }
        
        // Load persistent stats
        this.persistent = loadPersistent();
        
        localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));

        this.add.rectangle(400, 300, 800, 600, 0x1a1a1a);
        this.add.grid(400, 300, 800, 600, 32, 32, 0x222222).setAlpha(0.5);
        this.add.text(40, 40, "THE HIDEOUT", { fontSize: '48px', fill: '#00ff00', fontStyle: 'bold' });
        
        this.statText = this.add.text(40, 100, "", { fontSize: '16px', fill: '#cccccc', lineSpacing: 8 });
        this.updateStatText();

        this.createUpgradeCard(40, 200, "REST AREA", 
            () => `LVL: ${this.stats.hideout.restAreaLvl}\nEffect: ${this.getRestEffect()}`,
            () => {
                const cost = (this.stats.hideout.restAreaLvl + 1) * 5;
                if (this.stats.scrap >= cost) {
                    this.stats.scrap -= cost;
                    this.stats.hideout.restAreaLvl++;
                    if (this.stats.hideout.restAreaLvl > 0) this.stats.hp = this.stats.maxHp;
                    if (this.stats.hideout.restAreaLvl > 1) this.stats.maxHp += 2;
                    this.updateStatText();
                    localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));
                    return true;
                }
                return false;
            },
            () => `UPGRADE (${(this.stats.hideout.restAreaLvl + 1) * 5} SCRAP)`
        );

        this.createUpgradeCard(270, 200, "GENERATOR", 
            () => {
                if (this.stats.hideout.generatorLvl === 0) return "LVL: 0 (Offline)\nNeed: Spark Plug + Scrap";
                return "LVL: 1 (Online)\nEffect: Auto-Flashlight";
            },
            () => {
                if (this.stats.hideout.generatorLvl === 0) {
                    if (this.stats.scrap >= 10 && this.stats.hideout.hasSparkPlug) {
                        this.stats.scrap -= 10;
                        this.stats.hideout.generatorLvl = 1;
                        this.stats.hideout.hasSparkPlug = false;
                        this.stats.hasFlashlight = true;
                        this.updateStatText();
                        localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));
                        return true;
                    }
                }
                return false;
            },
            () => this.stats.hideout.generatorLvl === 0 ? "BUILD (10 SCRAP + PLUG)" : "MAX LEVEL"
        );

        this.createArmoryCard(500, 200);
        
        // Second row of upgrades
        this.createWorkbenchCard(40, 375);
        this.createRepairStationCard(270, 375);

        // Mission Map button (replaces old Deploy)
        const missionBtn = this.add.rectangle(650, 500, 200, 60, 0x006688).setInteractive();
        this.add.text(650, 500, "MISSION MAP", { fontSize: '22px', fill: '#fff', fontStyle: 'bold' }).setOrigin(0.5);
        missionBtn.on('pointerdown', () => { sfx.menuOpen(); this.showMissionMap(); });
        missionBtn.on('pointerover', () => missionBtn.setFillStyle(0x0088aa));
        missionBtn.on('pointerout', () => missionBtn.setFillStyle(0x006688));

        const menuBtn = this.add.rectangle(100, 550, 150, 40, 0x444444).setInteractive();
        this.add.text(100, 550, "MAIN MENU", { fontSize: '16px', fill: '#fff' }).setOrigin(0.5);
        menuBtn.on('pointerdown', () => { sfx.menuClose(); this.scene.start('MainMenuScene'); });
        
        // Stats & Achievements button
        const statsBtn = this.add.rectangle(300, 550, 150, 40, 0x444488).setInteractive();
        this.add.text(300, 550, "STATS", { fontSize: '14px', fill: '#fff' }).setOrigin(0.5);
        statsBtn.on('pointerdown', () => { sfx.menuOpen(); this.showStatsPanel(); });
        
        // Settings button
        const settingsBtn = this.add.rectangle(500, 550, 150, 40, 0x555555).setInteractive();
        this.add.text(500, 550, "SETTINGS", { fontSize: '14px', fill: '#fff' }).setOrigin(0.5);
        settingsBtn.on('pointerdown', () => { sfx.menuOpen(); this.showSettingsMenu(); });
        
        // Trader button - positioned to the right of Repair Station
        const traderBtn = this.add.rectangle(600, 435, 180, 50, 0xffd700).setInteractive();
        this.add.text(600, 435, "TRADER", { fontSize: '20px', fill: '#000', fontStyle: 'bold' }).setOrigin(0.5);
        traderBtn.on('pointerdown', () => { sfx.menuOpen(); this.showTraderModal(); });
        traderBtn.on('pointerover', () => traderBtn.setAlpha(0.8));
        traderBtn.on('pointerout', () => traderBtn.setAlpha(1));
    }
    
    showSettingsMenu() {
        const settings = loadSettings();
        const elements = [];
        
        // Overlay background
        const overlay = this.add.rectangle(400, 300, 500, 400, 0x111111, 0.95).setDepth(500);
        elements.push(overlay);
        
        const title = this.add.text(400, 130, "SETTINGS", { fontSize: '32px', fill: '#fff' }).setOrigin(0.5).setDepth(501);
        elements.push(title);
        
        // Master Volume Slider
        const masterLabel = this.add.text(200, 180, "MASTER VOLUME", { fontSize: '16px', fill: '#aaa' }).setDepth(501);
        elements.push(masterLabel);
        
        const masterSliderBg = this.add.rectangle(400, 210, 300, 20, 0x333333).setDepth(501);
        elements.push(masterSliderBg);
        
        const masterSliderFill = this.add.rectangle(250, 210, settings.masterVolume * 300, 16, 0x00ff00).setOrigin(0, 0.5).setDepth(502);
        elements.push(masterSliderFill);
        
        const masterPercent = this.add.text(560, 210, `${Math.round(settings.masterVolume * 100)}%`, { fontSize: '14px', fill: '#fff' }).setOrigin(0, 0.5).setDepth(501);
        elements.push(masterPercent);
        
        masterSliderBg.setInteractive();
        masterSliderBg.on('pointerdown', (pointer) => {
            const relX = (pointer.x - 250) / 300;
            const newVol = Phaser.Math.Clamp(relX, 0, 1);
            settings.masterVolume = newVol;
            sfx.setMasterVolume(newVol);
            masterSliderFill.width = newVol * 300;
            masterPercent.setText(`${Math.round(newVol * 100)}%`);
            sfx.click();
        });
        
        // SFX Volume Slider
        const sfxLabel = this.add.text(200, 250, "SFX VOLUME", { fontSize: '16px', fill: '#aaa' }).setDepth(501);
        elements.push(sfxLabel);
        
        const sfxSliderBg = this.add.rectangle(400, 280, 300, 20, 0x333333).setDepth(501);
        elements.push(sfxSliderBg);
        
        const sfxSliderFill = this.add.rectangle(250, 280, settings.sfxVolume * 300, 16, 0x00aaff).setOrigin(0, 0.5).setDepth(502);
        elements.push(sfxSliderFill);
        
        const sfxPercent = this.add.text(560, 280, `${Math.round(settings.sfxVolume * 100)}%`, { fontSize: '14px', fill: '#fff' }).setOrigin(0, 0.5).setDepth(501);
        elements.push(sfxPercent);
        
        sfxSliderBg.setInteractive();
        sfxSliderBg.on('pointerdown', (pointer) => {
            const relX = (pointer.x - 250) / 300;
            const newVol = Phaser.Math.Clamp(relX, 0, 1);
            settings.sfxVolume = newVol;
            sfx.setSfxVolume(newVol);
            sfxSliderFill.width = newVol * 300;
            sfxPercent.setText(`${Math.round(newVol * 100)}%`);
            sfx.click();
        });
        
        // Screen Shake Toggle
        const shakeLabel = this.add.text(200, 330, "SCREEN SHAKE", { fontSize: '16px', fill: '#aaa' }).setDepth(501);
        elements.push(shakeLabel);
        
        const shakeToggle = this.add.rectangle(500, 330, 80, 30, settings.screenShake ? 0x00ff00 : 0x444444).setDepth(501).setInteractive();
        elements.push(shakeToggle);
        
        const shakeText = this.add.text(500, 330, settings.screenShake ? "ON" : "OFF", { fontSize: '14px', fill: '#fff' }).setOrigin(0.5).setDepth(502);
        elements.push(shakeText);
        
        shakeToggle.on('pointerdown', () => {
            settings.screenShake = !settings.screenShake;
            shakeToggle.setFillStyle(settings.screenShake ? 0x00ff00 : 0x444444);
            shakeText.setText(settings.screenShake ? "ON" : "OFF");
            saveSettings(settings);
            sfx.click();
        });
        
        // Hit Indicators Toggle
        const hitLabel = this.add.text(200, 380, "HIT INDICATORS", { fontSize: '16px', fill: '#aaa' }).setDepth(501);
        elements.push(hitLabel);
        
        const hitToggle = this.add.rectangle(500, 380, 80, 30, settings.hitIndicators ? 0x00ff00 : 0x444444).setDepth(501).setInteractive();
        elements.push(hitToggle);
        
        const hitText = this.add.text(500, 380, settings.hitIndicators ? "ON" : "OFF", { fontSize: '14px', fill: '#fff' }).setOrigin(0.5).setDepth(502);
        elements.push(hitText);
        
        hitToggle.on('pointerdown', () => {
            settings.hitIndicators = !settings.hitIndicators;
            hitToggle.setFillStyle(settings.hitIndicators ? 0x00ff00 : 0x444444);
            hitText.setText(settings.hitIndicators ? "ON" : "OFF");
            saveSettings(settings);
            sfx.click();
        });
        
        // Close button
        const closeBtn = this.add.text(400, 460, "[ CLOSE ]", { fontSize: '18px', fill: '#ff4444' }).setOrigin(0.5).setDepth(501).setInteractive();
        elements.push(closeBtn);
        
        closeBtn.on('pointerdown', () => {
            sfx.menuClose();
            elements.forEach(e => e.destroy());
        });
    }
    
    createWorkbenchCard(x, y) {
        this.add.rectangle(x + 100, y + 60, 220, 130, 0x333333).setStrokeStyle(2, 0x555555);
        this.add.text(x + 10, y + 10, "WORKBENCH", { fontSize: '18px', fill: '#ff8800' });
        this.workbenchDesc = this.add.text(x + 10, y + 35, "", { fontSize: '12px', fill: '#aaa' });
        const btn = this.add.rectangle(x + 100, y + 100, 200, 25, 0x555555).setInteractive();
        this.workbenchBtnText = this.add.text(x + 100, y + 100, "", { fontSize: '12px', fill: '#fff' }).setOrigin(0.5);
        
        this.updateWorkbenchUI();
        
        btn.on('pointerdown', () => {
            if (this.stats.hideout.workbenchLvl === 0 && this.stats.scrap >= CONFIG.HIDEOUT.WORKBENCH_COST) {
                sfx.success();
                this.stats.scrap -= CONFIG.HIDEOUT.WORKBENCH_COST;
                this.stats.hideout.workbenchLvl = 1;
                this.updateStatText();
                this.updateWorkbenchUI();
                localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));
                this.cameras.main.flash(100, 255, 136, 0);
            } else {
                sfx.error();
                this.cameras.main.shake(100, 0.005);
            }
        });
    }
    
    updateWorkbenchUI() {
        if (this.stats.hideout.workbenchLvl === 0) {
            this.workbenchDesc.setText(`Upgrade weapons\n+${CONFIG.HIDEOUT.WORKBENCH_DAMAGE_BONUS * 100}% damage`);
            this.workbenchBtnText.setText(`BUILD (${CONFIG.HIDEOUT.WORKBENCH_COST} SCRAP)`);
        } else {
            this.workbenchDesc.setText(`ACTIVE\n+${CONFIG.HIDEOUT.WORKBENCH_DAMAGE_BONUS * 100}% weapon damage`);
            this.workbenchBtnText.setText("UPGRADED");
        }
    }
    
    createRepairStationCard(x, y) {
        this.add.rectangle(x + 100, y + 60, 220, 130, 0x333333).setStrokeStyle(2, 0x555555);
        this.add.text(x + 10, y + 10, "REPAIR STATION", { fontSize: '18px', fill: '#00aaff' });
        this.repairDesc = this.add.text(x + 10, y + 35, "", { fontSize: '12px', fill: '#aaa' });
        const btn = this.add.rectangle(x + 100, y + 100, 200, 25, 0x555555).setInteractive();
        this.repairBtnText = this.add.text(x + 100, y + 100, "", { fontSize: '12px', fill: '#fff' }).setOrigin(0.5);
        
        this.updateRepairUI();
        
        btn.on('pointerdown', () => {
            if (this.stats.hideout.repairStationLvl === 0 && this.stats.scrap >= CONFIG.HIDEOUT.REPAIR_STATION_COST) {
                // Build repair station
                sfx.success();
                this.stats.scrap -= CONFIG.HIDEOUT.REPAIR_STATION_COST;
                this.stats.hideout.repairStationLvl = 1;
                this.updateStatText();
                this.updateRepairUI();
                localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));
                this.cameras.main.flash(100, 0, 170, 255);
            } else if (this.stats.hideout.repairStationLvl > 0) {
                // Repair armor
                this.repairArmor();
            } else {
                sfx.error();
                this.cameras.main.shake(100, 0.005);
            }
        });
    }
    
    repairArmor() {
        let repaired = false;
        const slots = ['head', 'body', 'arms', 'feet'];
        for (const slot of slots) {
            const armor = this.stats.armor[slot];
            if (armor && armor.durability < armor.maxDurability) {
                const needed = armor.maxDurability - armor.durability;
                const cost = needed * CONFIG.HIDEOUT.REPAIR_COST_PER_POINT;
                if (this.stats.scrap >= cost) {
                    this.stats.scrap -= cost;
                    armor.durability = armor.maxDurability;
                    repaired = true;
                }
            }
        }
        if (repaired) {
            sfx.success();
            this.updateStatText();
            this.updateRepairUI();
            localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));
            this.cameras.main.flash(100, 0, 255, 0);
        } else {
            sfx.error();
            this.cameras.main.shake(100, 0.005);
        }
    }
    
    updateRepairUI() {
        if (this.stats.hideout.repairStationLvl === 0) {
            this.repairDesc.setText(`Repair damaged armor\n${CONFIG.HIDEOUT.REPAIR_COST_PER_POINT} scrap per point`);
            this.repairBtnText.setText(`BUILD (${CONFIG.HIDEOUT.REPAIR_STATION_COST} SCRAP)`);
        } else {
            // Calculate total repair cost
            let totalCost = 0;
            const slots = ['head', 'body', 'arms', 'feet'];
            for (const slot of slots) {
                const armor = this.stats.armor[slot];
                if (armor && armor.durability < armor.maxDurability) {
                    totalCost += (armor.maxDurability - armor.durability) * CONFIG.HIDEOUT.REPAIR_COST_PER_POINT;
                }
            }
            if (totalCost > 0) {
                this.repairDesc.setText(`Armor needs repair\nCost: ${totalCost} scrap`);
                this.repairBtnText.setText("REPAIR ALL");
            } else {
                this.repairDesc.setText("All armor at full\ndurability");
                this.repairBtnText.setText("NO REPAIRS NEEDED");
            }
        }
    }
    
    showMissionMap() {
        const elements = [];
        this.selectedLevel = this.stats.nextLevel || 1;
        
        // Level configuration
        const LEVELS = {
            1: { x: 150, y: 140, name: "Street", color: 0x2d5a27 },
            2: { x: 300, y: 100, name: "Apartment", color: 0x666666 },
            3: { x: 450, y: 140, name: "Rooftop", color: 0x334455 },
            4: { x: 180, y: 240, name: "Sewers", color: 0x2a3a2a },
            5: { x: 350, y: 220, name: "Hospital", color: 0xdddddd },
            6: { x: 450, y: 320, name: "Mall", color: 0x8B4513 },
            7: { x: 600, y: 360, name: "Cemetery", color: 0x1a1a1a }
        };
        
        // Road connections
        const ROADS = [[1,2], [2,3], [1,4], [4,5], [3,5], [5,6], [6,7]];
        
        // Dark overlay
        const overlay = this.add.rectangle(400, 300, 800, 600, 0x000000, 0.9).setDepth(500);
        elements.push(overlay);
        
        // Title
        const title = this.add.text(400, 40, "MISSION SELECT", { 
            fontSize: '36px', fill: '#00ff00', fontStyle: 'bold' 
        }).setOrigin(0.5).setDepth(501);
        elements.push(title);
        
        // City grid background
        const mapBg = this.add.rectangle(400, 250, 700, 350, 0x111122).setDepth(501);
        elements.push(mapBg);
        
        // Grid lines
        const graphics = this.add.graphics().setDepth(502);
        graphics.lineStyle(1, 0x222233, 0.5);
        for (let x = 50; x <= 750; x += 40) {
            graphics.moveTo(x, 75);
            graphics.lineTo(x, 425);
        }
        for (let y = 75; y <= 425; y += 35) {
            graphics.moveTo(50, y);
            graphics.lineTo(750, y);
        }
        graphics.strokePath();
        elements.push(graphics);
        
        // Draw roads first (under nodes)
        const roadGraphics = this.add.graphics().setDepth(503);
        roadGraphics.lineStyle(4, 0x444444);
        ROADS.forEach(([from, to]) => {
            const fromLevel = LEVELS[from];
            const toLevel = LEVELS[to];
            roadGraphics.moveTo(fromLevel.x, fromLevel.y);
            roadGraphics.lineTo(toLevel.x, toLevel.y);
        });
        roadGraphics.strokePath();
        elements.push(roadGraphics);
        
        // Store node references for updates
        this.mapNodes = {};
        
        // Draw level nodes
        for (let i = 1; i <= 7; i++) {
            const level = LEVELS[i];
            const isUnlocked = i <= this.stats.highestLevelUnlocked;
            const isCleared = i < this.stats.highestLevelUnlocked;
            const isSelected = i === this.selectedLevel;
            const isNext = i === this.stats.nextLevel;
            
            // Node background
            let nodeColor = 0x333333; // Locked
            if (isCleared) nodeColor = 0x006600; // Cleared
            if (isNext && !isCleared) nodeColor = 0xaa6600; // Current target
            if (isSelected) nodeColor = 0x0066aa; // Selected
            
            const node = this.add.circle(level.x, level.y, 28, nodeColor).setDepth(504);
            if (isUnlocked) {
                node.setInteractive({ useHandCursor: true });
                node.on('pointerover', () => {
                    if (this.selectedLevel !== i) node.setFillStyle(0x0088cc);
                });
                node.on('pointerout', () => {
                    this.updateMapNodeColor(i);
                });
                node.on('pointerdown', () => {
                    sfx.click();
                    this.selectedLevel = i;
                    this.updateMapSelection();
                });
            }
            
            // Level number
            const numText = this.add.text(level.x, level.y, `${i}`, { 
                fontSize: '20px', fill: isUnlocked ? '#ffffff' : '#555555', fontStyle: 'bold' 
            }).setOrigin(0.5).setDepth(505);
            
            // Status icon
            let icon = '';
            if (!isUnlocked) icon = 'üîí';
            else if (isCleared) icon = '‚úì';
            else if (isNext) icon = '‚Üí';
            
            const iconText = this.add.text(level.x + 20, level.y - 20, icon, { 
                fontSize: '14px' 
            }).setOrigin(0.5).setDepth(506);
            
            // Level name
            const nameText = this.add.text(level.x, level.y + 40, level.name, { 
                fontSize: '12px', fill: isUnlocked ? '#cccccc' : '#555555' 
            }).setOrigin(0.5).setDepth(505);
            
            this.mapNodes[i] = { node, numText, iconText, nameText };
            elements.push(node, numText, iconText, nameText);
        }
        
        // Selected level info panel
        const infoPanel = this.add.rectangle(400, 480, 400, 80, 0x222233).setDepth(501);
        elements.push(infoPanel);
        
        this.mapInfoText = this.add.text(400, 465, '', { 
            fontSize: '18px', fill: '#ffffff', align: 'center' 
        }).setOrigin(0.5).setDepth(502);
        elements.push(this.mapInfoText);
        
        this.mapStatusText = this.add.text(400, 490, '', { 
            fontSize: '14px', fill: '#888888', align: 'center' 
        }).setOrigin(0.5).setDepth(502);
        elements.push(this.mapStatusText);
        
        // Deploy button
        const deployBtn = this.add.rectangle(550, 540, 150, 45, 0x008800).setInteractive().setDepth(501);
        const deployTxt = this.add.text(550, 540, "DEPLOY", { 
            fontSize: '20px', fill: '#ffffff', fontStyle: 'bold' 
        }).setOrigin(0.5).setDepth(502);
        elements.push(deployBtn, deployTxt);
        
        deployBtn.on('pointerover', () => deployBtn.setFillStyle(0x00aa00));
        deployBtn.on('pointerout', () => deployBtn.setFillStyle(0x008800));
        deployBtn.on('pointerdown', () => {
            sfx.success();
            // Apply hideout bonuses before deploying
            if (this.stats.hideout.restAreaLvl > 0) {
                const heal = this.stats.hideout.restAreaLvl >= 2 ? this.stats.maxHp : Math.floor(this.stats.maxHp / 2);
                this.stats.hp = Math.min(this.stats.hp + heal, this.stats.maxHp);
            }
            if (this.stats.hideout.generatorLvl > 0) this.stats.hasFlashlight = true;
            // Refill magazines
            this.stats.magazines.pistol = CONFIG.WEAPONS.PISTOL.MAG_SIZE;
            this.stats.magazines.shotgun = CONFIG.WEAPONS.SHOTGUN.MAG_SIZE;
            this.stats.magazines.smg = CONFIG.WEAPONS.SMG.MAG_SIZE;
            this.stats.magazines.crossbow = CONFIG.WEAPONS.CROSSBOW.MAG_SIZE;
            this.stats.magazines.rifle = CONFIG.WEAPONS.RIFLE.MAG_SIZE;
            // Update nextLevel to selected level
            this.stats.nextLevel = this.selectedLevel;
            localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));
            
            this.cameras.main.fade(500, 0, 0, 0);
            this.time.delayedCall(500, () => { 
                this.scene.start('GameScene', { level: this.selectedLevel, stats: this.stats }); 
            });
        });
        
        // Close button
        const closeBtn = this.add.rectangle(250, 540, 150, 45, 0x444444).setInteractive().setDepth(501);
        const closeTxt = this.add.text(250, 540, "BACK", { 
            fontSize: '20px', fill: '#ffffff' 
        }).setOrigin(0.5).setDepth(502);
        elements.push(closeBtn, closeTxt);
        
        closeBtn.on('pointerover', () => closeBtn.setFillStyle(0x555555));
        closeBtn.on('pointerout', () => closeBtn.setFillStyle(0x444444));
        closeBtn.on('pointerdown', () => {
            sfx.menuClose();
            elements.forEach(e => e.destroy());
        });
        
        // Store elements for cleanup
        this.mapElements = elements;
        
        // Initial selection update
        this.updateMapSelection();
    }
    
    updateMapNodeColor(levelNum) {
        if (!this.mapNodes || !this.mapNodes[levelNum] || !this.mapNodes[levelNum].node) return;
        if (!this.mapNodes[levelNum].node.active) return;
        
        const isUnlocked = levelNum <= this.stats.highestLevelUnlocked;
        const isCleared = levelNum < this.stats.highestLevelUnlocked;
        const isSelected = levelNum === this.selectedLevel;
        const isNext = levelNum === this.stats.nextLevel;
        
        let nodeColor = 0x333333; // Locked
        if (isCleared) nodeColor = 0x006600; // Cleared
        if (isNext && !isCleared) nodeColor = 0xaa6600; // Current target
        if (isSelected) nodeColor = 0x0066aa; // Selected
        
        this.mapNodes[levelNum].node.setFillStyle(nodeColor);
    }
    
    updateMapSelection() {
        // Guard against destroyed UI
        if (!this.mapInfoText || !this.mapStatusText) return;
        
        const LEVEL_NAMES = ['', 'Street', 'Apartment', 'Rooftop', 'Sewers', 'Hospital', 'Mall', 'Cemetery'];
        const LEVEL_DESC = [
            '',
            'Urban streets with scattered zombies',
            'Multi-floor building, find the key',
            'Night sky, collect molotov, burn debris',
            'Dark tunnels, need flashlight',
            'BOSS FIGHT - Heavy zombie',
            'Shopping center with breach waves',
            'FINAL BOSS - Necromancer awaits'
        ];
        
        // Update all node colors
        for (let i = 1; i <= 7; i++) {
            this.updateMapNodeColor(i);
        }
        
        // Update info panel
        const levelName = LEVEL_NAMES[this.selectedLevel] || '';
        const levelDesc = LEVEL_DESC[this.selectedLevel] || '';
        const isCleared = this.selectedLevel < this.stats.highestLevelUnlocked;
        
        if (this.mapInfoText.active) {
            this.mapInfoText.setText(`${this.selectedLevel}. ${levelName}`);
        }
        if (this.mapStatusText.active) {
            this.mapStatusText.setText(isCleared ? `CLEARED - ${levelDesc}` : levelDesc);
        }
    }
    
    showStatsPanel() {
        // Create overlay
        const overlay = this.add.rectangle(400, 300, 700, 500, 0x111111, 0.95).setDepth(500);
        const title = this.add.text(400, 80, "STATS & ACHIEVEMENTS", { fontSize: '28px', fill: '#ffd700' }).setOrigin(0.5).setDepth(501);
        
        const p = this.persistent;
        const accuracy = p.totalShotsFired > 0 ? Math.round((p.totalShotsHit / p.totalShotsFired) * 100) : 0;
        
        // Stats column
        const statsText = this.add.text(100, 120, 
            `LIFETIME STATS\n\n` +
            `Kills: ${p.totalKills}\n` +
            `Deaths: ${p.totalDeaths}\n` +
            `Extractions: ${p.runsCompleted}\n` +
            `Runs Started: ${p.runsStarted}\n` +
            `Accuracy: ${accuracy}%\n` +
            `(${p.totalShotsHit}/${p.totalShotsFired} shots)\n` +
            `Scrap Collected: ${p.totalScrapCollected}\n` +
            `Credits Earned: ${p.totalCreditsEarned || 0}\n` +
            `Materials Found: ${p.totalMaterialsCollected || 0}\n` +
            `Items Bought: ${p.itemsBought || 0}\n` +
            `Items Sold: ${p.itemsSold || 0}\n` +
            `Melee Kills: ${p.meleeKills}\n` +
            `Grenade Kills: ${p.totalGrenadeKills}\n` +
            `Bosses Killed: ${p.bossesKilled}`,
            { fontSize: '13px', fill: '#ccc', lineSpacing: 5 }
        ).setDepth(501);
        
        // Achievements column
        const achTitle = this.add.text(420, 120, "ACHIEVEMENTS", { fontSize: '16px', fill: '#ffd700' }).setDepth(501);
        let achY = 150;
        const allAchievements = Object.values(CONFIG.ACHIEVEMENTS);
        allAchievements.forEach(ach => {
            const unlocked = p.achievements.includes(ach.id);
            const color = unlocked ? '#00ff00' : '#555555';
            const icon = unlocked ? ach.icon : 'üîí';
            this.add.text(420, achY, `${icon} ${ach.name}`, { fontSize: '14px', fill: color }).setDepth(501);
            this.add.text(440, achY + 16, ach.desc, { fontSize: '11px', fill: unlocked ? '#888' : '#444' }).setDepth(501);
            achY += 40;
        });
        
        // Close button
        const closeBtn = this.add.text(400, 530, "[ CLOSE ]", { fontSize: '18px', fill: '#ff4444' }).setOrigin(0.5).setDepth(501).setInteractive();
        const elements = [overlay, title, statsText, achTitle, closeBtn];
        
        closeBtn.on('pointerdown', () => {
            sfx.menuClose();
            elements.forEach(e => e.destroy());
            // Destroy achievement texts too
            this.children.list.filter(c => c.depth === 501).forEach(c => c.destroy());
        });
    }
    
    showTraderModal() {
        const elements = [];
        this.traderTab = 'buy'; // Track current tab
        
        // Dark overlay - click to close
        const overlay = this.add.rectangle(400, 300, 800, 600, 0x000000, 0.7).setDepth(499).setInteractive();
        elements.push(overlay);
        overlay.on('pointerdown', () => this.closeTraderModal(elements));
        
        // Modal background
        const modalBg = this.add.rectangle(400, 300, 600, 480, 0x1a1a1a, 0.98).setDepth(500).setStrokeStyle(3, 0xffd700);
        elements.push(modalBg);
        
        // Title
        const title = this.add.text(400, 85, "TRADER", { fontSize: '36px', fill: '#ffd700', fontStyle: 'bold' }).setOrigin(0.5).setDepth(501);
        elements.push(title);
        
        // Currency display
        const currencyText = this.add.text(400, 120, 
            `üí∞ Credits: ${this.stats.credits}  |  üîß Scrap: ${this.stats.scrap}  |  ‚öôÔ∏è Materials: ${this.stats.materials}`,
            { fontSize: '14px', fill: '#ccc' }
        ).setOrigin(0.5).setDepth(501);
        elements.push(currencyText);
        this.traderCurrencyText = currencyText;
        
        // Tab buttons
        const buyTab = this.add.rectangle(300, 155, 150, 35, 0xffd700).setDepth(501).setInteractive();
        const buyTabText = this.add.text(300, 155, "BUY", { fontSize: '18px', fill: '#000', fontStyle: 'bold' }).setOrigin(0.5).setDepth(502);
        elements.push(buyTab, buyTabText);
        
        const sellTab = this.add.rectangle(500, 155, 150, 35, 0x444444).setDepth(501).setInteractive();
        const sellTabText = this.add.text(500, 155, "SELL", { fontSize: '18px', fill: '#fff' }).setOrigin(0.5).setDepth(502);
        elements.push(sellTab, sellTabText);
        
        // Content area
        const contentBg = this.add.rectangle(400, 350, 560, 280, 0x222222).setDepth(500);
        elements.push(contentBg);
        
        // Store item elements reference for tab switching
        this.traderItemElements = [];
        
        // Tab click handlers
        buyTab.on('pointerdown', () => {
            sfx.click();
            this.traderTab = 'buy';
            buyTab.setFillStyle(0xffd700);
            buyTabText.setColor('#000');
            sellTab.setFillStyle(0x444444);
            sellTabText.setColor('#fff');
            this.renderTraderItems(elements);
        });
        
        sellTab.on('pointerdown', () => {
            sfx.click();
            this.traderTab = 'sell';
            sellTab.setFillStyle(0xffd700);
            sellTabText.setColor('#000');
            buyTab.setFillStyle(0x444444);
            buyTabText.setColor('#fff');
            this.renderTraderItems(elements);
        });
        
        // Close button
        const closeBtn = this.add.text(400, 520, "[ CLOSE ]", { fontSize: '18px', fill: '#ff4444' }).setOrigin(0.5).setDepth(501).setInteractive();
        elements.push(closeBtn);
        closeBtn.on('pointerdown', () => this.closeTraderModal(elements));
        
        // Store elements reference
        this.traderElements = elements;
        
        // Render initial items
        this.renderTraderItems(elements);
    }
    
    renderTraderItems(elements) {
        // Clear previous item elements
        if (this.traderItemElements) {
            this.traderItemElements.forEach(e => e.destroy());
        }
        this.traderItemElements = [];
        
        const startY = 195;
        const itemHeight = 45;
        
        if (this.traderTab === 'buy') {
            // Render buy items
            CONFIG.TRADER.HIDEOUT_STOCK.forEach((item, i) => {
                const y = startY + i * itemHeight;
                
                // Item name
                const nameText = this.add.text(150, y, item.name, { fontSize: '16px', fill: '#fff' }).setDepth(501);
                this.traderItemElements.push(nameText);
                
                // Item description
                let desc = '';
                if (item.type === 'ammo') desc = `+${item.amount} ammo`;
                else if (item.type === 'heal') desc = `+${item.amount} HP`;
                else if (item.type === 'grenade') desc = `+${item.amount} grenade`;
                else if (item.type === 'consumable') desc = CONFIG.CONSUMABLES[item.id]?.icon || '';
                
                const descText = this.add.text(320, y, desc, { fontSize: '14px', fill: '#888' }).setDepth(501);
                this.traderItemElements.push(descText);
                
                // Cost
                const currIcon = CONFIG.CURRENCIES[item.currency.toUpperCase()].icon;
                const costText = this.add.text(450, y, `${item.cost} ${currIcon}`, { fontSize: '14px', fill: '#ffd700' }).setDepth(501);
                this.traderItemElements.push(costText);
                
                // Buy button
                const canAfford = this.stats[item.currency] >= item.cost;
                const buyBtn = this.add.rectangle(600, y + 8, 70, 28, canAfford ? 0x00aa00 : 0x444444).setDepth(501).setInteractive();
                const buyBtnText = this.add.text(600, y + 8, "BUY", { fontSize: '14px', fill: '#fff' }).setOrigin(0.5).setDepth(502);
                this.traderItemElements.push(buyBtn, buyBtnText);
                
                if (canAfford) {
                    buyBtn.on('pointerdown', () => {
                        if (this.purchaseItem(item)) {
                            this.updateTraderCurrency();
                            this.renderTraderItems(elements);
                        }
                    });
                    buyBtn.on('pointerover', () => buyBtn.setAlpha(0.8));
                    buyBtn.on('pointerout', () => buyBtn.setAlpha(1));
                }
            });
        } else {
            // Render sell items
            let y = startY;
            const sellItems = [];
            
            // Add armor pieces that can be sold
            const armorSlots = ['head', 'body', 'arms', 'feet'];
            armorSlots.forEach(slot => {
                if (this.stats.armor[slot]) {
                    sellItems.push({
                        type: 'armor',
                        slot: slot,
                        name: this.stats.armor[slot].name,
                        value: Math.floor(20 * CONFIG.TRADER.SELL_RATE)
                    });
                }
            });
            
            // Add consumables that can be sold
            this.stats.consumables.forEach((cons, idx) => {
                if (cons) {
                    const config = CONFIG.CONSUMABLES[cons];
                    sellItems.push({
                        type: 'consumable',
                        slot: idx,
                        name: config.name,
                        value: Math.floor(25 * CONFIG.TRADER.SELL_RATE)
                    });
                }
            });
            
            if (sellItems.length === 0) {
                const noItems = this.add.text(400, 300, "Nothing to sell", { fontSize: '18px', fill: '#666' }).setOrigin(0.5).setDepth(501);
                this.traderItemElements.push(noItems);
            } else {
                sellItems.forEach((item, i) => {
                    const itemY = startY + i * itemHeight;
                    
                    const nameText = this.add.text(150, itemY, item.name, { fontSize: '16px', fill: '#fff' }).setDepth(501);
                    this.traderItemElements.push(nameText);
                    
                    const valueText = this.add.text(450, itemY, `+${item.value} üí∞`, { fontSize: '14px', fill: '#00ff00' }).setDepth(501);
                    this.traderItemElements.push(valueText);
                    
                    const sellBtn = this.add.rectangle(600, itemY + 8, 70, 28, 0xaa0000).setDepth(501).setInteractive();
                    const sellBtnText = this.add.text(600, itemY + 8, "SELL", { fontSize: '14px', fill: '#fff' }).setOrigin(0.5).setDepth(502);
                    this.traderItemElements.push(sellBtn, sellBtnText);
                    
                    sellBtn.on('pointerdown', () => {
                        this.sellItem(item);
                        this.updateTraderCurrency();
                        this.renderTraderItems(elements);
                    });
                    sellBtn.on('pointerover', () => sellBtn.setAlpha(0.8));
                    sellBtn.on('pointerout', () => sellBtn.setAlpha(1));
                });
            }
        }
    }
    
    updateTraderCurrency() {
        if (this.traderCurrencyText) {
            this.traderCurrencyText.setText(
                `üí∞ Credits: ${this.stats.credits}  |  üîß Scrap: ${this.stats.scrap}  |  ‚öôÔ∏è Materials: ${this.stats.materials}`
            );
        }
        this.updateStatText();
    }
    
    closeTraderModal(elements) {
        sfx.menuClose();
        if (this.traderItemElements) {
            this.traderItemElements.forEach(e => e.destroy());
            this.traderItemElements = [];
        }
        elements.forEach(e => e.destroy());
        localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));
    }
    
    purchaseItem(item) {
        const currency = item.currency;
        const cost = item.cost;
        
        // Check if player can afford
        if (this.stats[currency] < cost) {
            sfx.error();
            return false;
        }
        
        // For consumables, check if there's an empty slot
        if (item.type === 'consumable') {
            const emptySlot = this.stats.consumables.findIndex(c => c === null);
            if (emptySlot === -1) {
                sfx.error();
                // Show feedback somehow
                return false;
            }
        }
        
        // For grenades, check max carry
        if (item.type === 'grenade' && this.stats.grenades >= CONFIG.GRENADE.MAX_CARRY) {
            sfx.error();
            return false;
        }
        
        // Deduct cost
        this.stats[currency] -= cost;
        this.persistent.itemsBought++;
        
        // Apply item effect
        switch (item.type) {
            case 'ammo':
                this.stats.ammo += item.amount;
                break;
            case 'heal':
                this.stats.hp = Math.min(this.stats.hp + item.amount, this.stats.maxHp);
                break;
            case 'grenade':
                this.stats.grenades = Math.min(this.stats.grenades + item.amount, CONFIG.GRENADE.MAX_CARRY);
                break;
            case 'consumable':
                this.addConsumable(item.id);
                break;
        }
        
        sfx.purchase();
        savePersistent(this.persistent);
        localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));
        return true;
    }
    
    addConsumable(consumableId) {
        const emptySlot = this.stats.consumables.findIndex(c => c === null);
        if (emptySlot !== -1) {
            this.stats.consumables[emptySlot] = consumableId;
            return true;
        }
        return false;
    }
    
    sellItem(item) {
        if (item.type === 'armor') {
            // Remove armor and add credits
            this.stats.armor[item.slot] = null;
            this.stats.credits += item.value;
        } else if (item.type === 'consumable') {
            // Remove consumable and add credits
            this.stats.consumables[item.slot] = null;
            this.stats.credits += item.value;
        }
        
        this.persistent.itemsSold++;
        sfx.sell();
        savePersistent(this.persistent);
        localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));
        return true;
    }

    update(time, delta) {
        if (this.armoryTimerText && this.stats.hideout.armory.crafting) {
            let remaining = this.stats.hideout.armory.crafting.finishTime - Date.now();
            if (remaining > 0) {
                let seconds = Math.floor(remaining / 1000);
                this.armoryTimerText.setText(`CRAFTING: ${Math.floor(seconds/60)}:${(seconds%60).toString().padStart(2,'0')}`);
                this.armoryBtnText.setText("WAIT...");
            } else {
                this.armoryTimerText.setText("COMPLETE!");
                this.armoryBtnText.setText("CLAIM NVG");
                this.armoryBtn.setInteractive();
            }
        }
    }

    createArmoryCard(x, y) {
        this.add.rectangle(x + 100, y + 75, 220, 160, 0x333333).setStrokeStyle(2, 0x555555);
        this.add.text(x + 10, y + 10, "ARMORY", { fontSize: '20px', fill: '#ff00ff' });
        this.armoryDesc = this.add.text(x + 10, y + 40, "", { fontSize: '14px', fill: '#aaa' });
        this.armoryTimerText = this.add.text(x + 10, y + 80, "", { fontSize: '14px', fill: '#00ff00' });
        this.armoryBtn = this.add.rectangle(x + 100, y + 130, 200, 30, 0x555555).setInteractive();
        this.armoryBtnText = this.add.text(x + 100, y + 130, "", { fontSize: '14px', fill: '#fff' }).setOrigin(0.5);
        const ammoBtn = this.add.rectangle(x + 100, y + 165, 200, 20, 0x444444).setInteractive();
        this.add.text(x + 100, y + 165, "AMMO PRESS (1 SCRAP -> 4 AMMO)", { fontSize: '10px', fill: '#fff' }).setOrigin(0.5);

        this.updateArmoryUI();

        this.armoryBtn.on('pointerdown', () => {
            let armory = this.stats.hideout.armory;
            if (armory.hasNVG) return;
            if (armory.crafting && Date.now() >= armory.crafting.finishTime) {
                sfx.lootWeapon();
                armory.hasNVG = true;
                armory.crafting = null;
                this.updateArmoryUI();
                localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));
                return;
            }
            if (armory.crafting) return;
            if (this.stats.scrap >= 3) {
                sfx.success();
                this.stats.scrap -= 3;
                armory.crafting = { item: 'nvg', finishTime: Date.now() + CONFIG.TIMINGS.NVG_CRAFT };
                this.updateStatText();
                this.updateArmoryUI();
                localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));
            } else {
                sfx.error();
                this.cameras.main.shake(100, 0.005);
            }
        });

        ammoBtn.on('pointerdown', () => {
            if (this.stats.scrap >= 1) {
                sfx.lootAmmo();
                this.stats.scrap -= 1;
                this.stats.ammo += 4;
                this.updateStatText();
                localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.stats));
                this.cameras.main.flash(100, 0, 255, 0);
            } else {
                sfx.error();
            }
        });
    }

    updateArmoryUI() {
        let armory = this.stats.hideout.armory;
        if (armory.hasNVG) {
            this.armoryDesc.setText("NVG UNLOCKED\nPress [N] in game.");
            this.armoryBtnText.setText("EQUIPPED");
            this.armoryTimerText.setText("");
            this.armoryBtn.disableInteractive();
            this.armoryBtn.setFillStyle(0x222222);
        } else if (armory.crafting) {
            this.armoryDesc.setText("Fabricating NVG...");
            this.armoryBtn.disableInteractive();
        } else {
            this.armoryDesc.setText("Craft Night Vision\nCost: 3 Scrap\nTime: 1m 30s");
            this.armoryBtnText.setText("CRAFT (3 SCRAP)");
            this.armoryTimerText.setText("");
            this.armoryBtn.setInteractive();
        }
    }

    getRestEffect() {
        if (this.stats.hideout.restAreaLvl === 0) return "Sleep on floor (No Heal)";
        if (this.stats.hideout.restAreaLvl === 1) return "Mattress (+50% HP)";
        return "Med Bay (+100% HP, +Max HP)";
    }

    updateStatText() {
        let plugStatus = this.stats.hideout.hasSparkPlug ? "YES" : "NO";
        // Count consumables
        const consumableCount = this.stats.consumables.filter(c => c !== null).length;
        this.statText.setText(
            `HP: ${this.stats.hp}/${this.stats.maxHp}\n` +
            `AMMO: ${this.stats.ammo}\n` +
            `üîß SCRAP: ${this.stats.scrap}\n` +
            `üí∞ CREDITS: ${this.stats.credits}\n` +
            `‚öôÔ∏è MATERIALS: ${this.stats.materials}\n` +
            `CONSUMABLES: ${consumableCount}/3\n` +
            `SPARK PLUG: ${plugStatus}`
        );
    }

    createUpgradeCard(x, y, title, descFn, actionFn, costFn) {
        this.add.rectangle(x + 100, y + 75, 220, 160, 0x333333).setStrokeStyle(2, 0x555555);
        this.add.text(x + 10, y + 10, title, { fontSize: '20px', fill: '#ffff00' });
        const descText = this.add.text(x + 10, y + 40, descFn(), { fontSize: '14px', fill: '#aaa' });
        const btn = this.add.rectangle(x + 100, y + 130, 200, 30, 0x555555).setInteractive();
        const btnText = this.add.text(x + 100, y + 130, costFn(), { fontSize: '14px', fill: '#fff' }).setOrigin(0.5);
        btn.on('pointerdown', () => {
            if (actionFn()) {
                sfx.success();
                descText.setText(descFn());
                btnText.setText(costFn());
                this.cameras.main.flash(100, 0, 255, 0);
            } else {
                sfx.error();
                this.cameras.main.shake(100, 0.005);
                btn.setFillStyle(0xff0000);
                this.time.delayedCall(200, () => btn.setFillStyle(0x555555));
            }
        });
    }
}

// =============================================================================
// GAME SCENE
// =============================================================================
class GameScene extends Phaser.Scene {
    constructor() { super('GameScene'); }
    
    preload() {
        const graphics = this.make.graphics({ x: 0, y: 0, add: false });
        
        graphics.fillStyle(0x00ff00, 1); graphics.fillRect(0,0,32,32); graphics.generateTexture('player', 32,32);
        graphics.fillStyle(0x8B4513, 1); graphics.fillRect(0,0,32,32); graphics.generateTexture('crate', 32,32);
        graphics.fillStyle(0x663399, 1); graphics.fillRect(0,0,32,32); graphics.generateTexture('zombie', 32,32);
        graphics.fillStyle(0xFF4500, 1); graphics.fillRect(0,0,32,32); graphics.generateTexture('leaper', 32,32);
        graphics.fillStyle(0x0000FF, 1); graphics.fillRect(0,0,32,32); graphics.generateTexture('bandit', 32,32);
        graphics.fillStyle(0x00AA00, 1); graphics.fillRect(0,0,32,32); graphics.generateTexture('spitter', 32,32);
        graphics.fillStyle(0xffff00, 1); graphics.fillRect(0,0,8,8); graphics.generateTexture('bullet', 8,8);
        graphics.fillStyle(0x00ff00, 1); graphics.fillCircle(6,6,6); graphics.generateTexture('acid', 12,12);
        graphics.fillStyle(0x556B2F, 1); graphics.fillCircle(8,8,8); graphics.generateTexture('grenade', 16,16);
        graphics.fillStyle(0xFFD700, 1); graphics.fillRect(0,0,40,60); graphics.generateTexture('door', 40,60);
        graphics.fillStyle(0x555555, 1); graphics.fillRect(0,0,32,32); graphics.generateTexture('wall', 32,32);
        graphics.fillStyle(0xffffff, 1); graphics.fillRect(0,0,40,40); graphics.generateTexture('slash', 40,40);
        graphics.fillStyle(0x2d5a27, 1); graphics.fillRect(0,0,32,32); graphics.generateTexture('floor_grass', 32,32);
        graphics.clear(); graphics.fillStyle(0x444444, 1); graphics.fillRect(0,0,32,32); graphics.generateTexture('floor_apt', 32,32);
        graphics.clear(); graphics.fillStyle(0x1a1a2e, 1); graphics.fillRect(0,0,32,32); graphics.generateTexture('floor_roof', 32,32);
        graphics.clear(); graphics.fillStyle(0x2a3a2a, 1); graphics.fillRect(0,0,32,32); graphics.generateTexture('floor_sewer', 32,32);
        graphics.clear(); graphics.fillStyle(0xddeedd, 1); graphics.fillRect(0,0,32,32); graphics.generateTexture('floor_hospital', 32,32);
        graphics.clear(); graphics.fillStyle(0xff0000, 1); graphics.fillRect(0,0,20,20); graphics.generateTexture('pickup_hp', 20,20);
        graphics.clear(); graphics.fillStyle(0x0088ff, 1); graphics.fillRect(0,0,20,20); graphics.generateTexture('pickup_stamina', 20,20);
        graphics.clear(); graphics.fillStyle(0x333333, 1); graphics.fillRect(0,0,60,60); graphics.generateTexture('debris', 60,60);
        graphics.clear(); graphics.fillStyle(0x00ff00, 1); graphics.fillRect(0,0,30,30); graphics.generateTexture('switch', 30,30);
        
        // Skull art
        graphics.clear();
        graphics.lineStyle(2, 0x000000, 1);
        graphics.fillStyle(0xEAEAEA, 1);
        graphics.fillCircle(16, 14, 11); graphics.strokeCircle(16, 14, 11);
        graphics.fillRect(10, 20, 12, 8); graphics.strokeRect(10, 20, 12, 8);
        graphics.fillStyle(0x000000, 1);
        graphics.fillCircle(12, 14, 3.5); graphics.fillCircle(20, 14, 3.5);
        graphics.beginPath(); graphics.moveTo(16, 18); graphics.lineTo(14, 21); graphics.lineTo(18, 21); graphics.closePath(); graphics.fill();
        graphics.lineStyle(1, 0x000000);
        graphics.beginPath(); graphics.moveTo(13, 20); graphics.lineTo(13, 28); graphics.moveTo(16, 20); graphics.lineTo(16, 28); graphics.moveTo(19, 20); graphics.lineTo(19, 28); graphics.strokePath();
        graphics.generateTexture('skull', 32, 32);
    }
    
    create(data = {}) {
        // Clean up any lingering handlers from previous scene
        if (this.levelChoiceEnterHandler) {
            this.input.keyboard.off('keydown-ENTER', this.levelChoiceEnterHandler);
            this.levelChoiceEnterHandler = null;
        }
        if (this.levelChoiceEscHandler) {
            this.input.keyboard.off('keydown-ESC', this.levelChoiceEscHandler);
            this.levelChoiceEscHandler = null;
        }
        this.levelChoiceMade = false;
        this.consumableSlotTexts = null;
        
        this.currentLevel = data.level || 1;
        this.playerStats = data.stats ? JSON.parse(JSON.stringify(data.stats)) : JSON.parse(JSON.stringify(DEFAULT_STATS));
        // Ensure magazines exist
        if (!this.playerStats.magazines) {
            this.playerStats.magazines = {
                pistol: CONFIG.WEAPONS.PISTOL.MAG_SIZE,
                shotgun: CONFIG.WEAPONS.SHOTGUN.MAG_SIZE,
                smg: CONFIG.WEAPONS.SMG.MAG_SIZE,
                crossbow: CONFIG.WEAPONS.CROSSBOW.MAG_SIZE,
                rifle: CONFIG.WEAPONS.RIFLE.MAG_SIZE
            };
        }
        // Ensure new weapon magazines exist
        if (this.playerStats.magazines.crossbow === undefined) this.playerStats.magazines.crossbow = CONFIG.WEAPONS.CROSSBOW.MAG_SIZE;
        if (this.playerStats.magazines.rifle === undefined) this.playerStats.magazines.rifle = CONFIG.WEAPONS.RIFLE.MAG_SIZE;
        // Ensure new weapon flags exist
        if (this.playerStats.hasCrossbow === undefined) this.playerStats.hasCrossbow = false;
        if (this.playerStats.hasRifle === undefined) this.playerStats.hasRifle = false;
        // Ensure grenades exist for old saves
        if (this.playerStats.grenades === undefined) {
            this.playerStats.grenades = 0;
        }
        // Ensure new currency fields exist
        if (this.playerStats.credits === undefined) {
            this.playerStats.credits = 0;
        }
        if (this.playerStats.materials === undefined) {
            this.playerStats.materials = 0;
        }
        // Ensure consumables is a valid array (handle null, undefined, or corrupted data)
        if (!this.playerStats.consumables || !Array.isArray(this.playerStats.consumables)) {
            this.playerStats.consumables = [null, null, null];
        }
        // Ensure consumables array has exactly 3 slots
        while (this.playerStats.consumables.length < 3) {
            this.playerStats.consumables.push(null);
        }
        // Ensure highestLevelUnlocked exists
        if (this.playerStats.highestLevelUnlocked === undefined) {
            this.playerStats.highestLevelUnlocked = this.playerStats.nextLevel || 1;
        }
        this.checkpointStats = JSON.parse(JSON.stringify(this.playerStats));

        // State flags
        this.hasKey = false;
        this.hasMolotov = false;
        this.isOpening = false;
        this.isPaused = false;
        this.isPinned = false;
        this.pinnedBy = null;
        this.isMeleeAttacking = false;
        this.debrisBurning = false;
        this.lastFired = 0;
        this.switchDropped = false;
        this.extractionTimer = 15;
        this.extractionActive = false;
        this.isInventoryOpen = false;
        this.nvgOn = false;
        this.speedMultiplier = 1; // For adrenaline consumable
        
        // Persistent stats tracking
        this.persistent = loadPersistent();
        if (this.currentLevel === 1) {
            // New run - reset run stats and increment runs started
            this.persistent = resetRunStats(this.persistent);
            this.persistent.runsStarted++;
            this.levelDamageTaken = 0; // Track damage for untouchable achievement
        }
        this.levelDamageTaken = this.levelDamageTaken || 0;
        this.grenadeKillCount = 0; // For tracking multi-kills
        
        // Dodge roll state
        this.isDodging = false;
        this.dodgeCooldown = 0;
        this.lastDodgeTime = 0;
        
        // Reload state
        this.isReloading = false;
        this.reloadTimer = null;
        
        // Transition state - prevents updates during level change
        this.isTransitioning = false;
        
        // Track active timer events for cleanup
        this.activeTimerEvents = [];

        // Groups
        this.bullets = this.physics.add.group({ classType: Bullet, runChildUpdate: true, maxSize: 50 });
        this.acidProjectiles = this.physics.add.group({ runChildUpdate: true, maxSize: 20 });
        this.grenades = this.physics.add.group({ runChildUpdate: true, maxSize: 10 });
        this.enemies = this.add.group();
        this.pickups = this.physics.add.staticGroup();
        this.crates = this.physics.add.staticGroup();
        this.skulls = this.physics.add.staticGroup();
        this.walls = this.physics.add.staticGroup();
        this.debris = this.physics.add.staticGroup();
        this.switches = this.physics.add.staticGroup();

        // Floating text, particle, and hit indicator pools
        this.floatingText = new FloatingTextPool(this, 20);
        this.particles = new ParticlePool(this, 30);
        this.hitIndicators = new HitIndicatorPool(this, 8);
        
        // Load settings
        this.gameSettings = loadSettings();

        // UI elements needed by spawnLevelEntities (must be created before)
        this.uiGraphics = this.add.graphics().setDepth(100);
        this.uiText = this.add.text(10, 65, '', { font: '16px Arial', fill: '#fff' }).setDepth(100);
        this.bossBar = this.add.graphics().setDepth(150).setVisible(false);
        this.bossText = this.add.text(400, 25, "BOSS", { fontSize: '20px', fill: '#fff' }).setOrigin(0.5).setDepth(200).setVisible(false);

        this.setupMapForLevel(this.currentLevel);
        this.player = this.physics.add.sprite(400, 550, 'player').setCollideWorldBounds(true).setDepth(10);
        this.spawnLevelEntities(this.currentLevel);

        // Colliders
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.player, this.crates);
        this.physics.add.collider(this.player, this.debris);
        this.physics.add.collider(this.enemies, this.walls);
        this.physics.add.collider(this.enemies, this.crates);
        this.physics.add.collider(this.bullets, this.walls, (b) => { b.setActive(false); b.setVisible(false); b.body.enable = false; });
        this.physics.add.collider(this.bullets, this.crates, (b) => { b.setActive(false); b.setVisible(false); b.body.enable = false; });
        this.physics.add.collider(this.bullets, this.debris, (b) => { b.setActive(false); b.setVisible(false); b.body.enable = false; });

        // Overlaps
        this.physics.add.overlap(this.bullets, this.enemies, (obj1, obj2) => {
            const bullet = (obj1.texture.key === 'bullet') ? obj1 : obj2;
            const enemy = (obj1.texture.key === 'bullet') ? obj2 : obj1;
            if (bullet.active && enemy.active) {
                if (bullet.isEnemyBullet) return;
                
                // Track which enemies this bullet has hit (for piercing)
                if (!bullet.hitEnemies) bullet.hitEnemies = new Set();
                if (bullet.hitEnemies.has(enemy)) return; // Already hit this enemy
                bullet.hitEnemies.add(enemy);
                
                // Piercing bullets can hit multiple enemies but have a limit
                if (bullet.isPiercing) {
                    if (!bullet.pierceCount) bullet.pierceCount = 0;
                    bullet.pierceCount++;
                    if (bullet.pierceCount > 2) { // Pierce through 2 enemies max
                        bullet.setActive(false);
                        bullet.setVisible(false);
                        bullet.body.enable = false;
                    }
                } else {
                    // Non-piercing bullets stop on first hit
                    bullet.hasHit = true;
                    bullet.setActive(false);
                    bullet.setVisible(false);
                    bullet.body.enable = false;
                }
                
                // Track hit stats
                this.persistent.runShotsHit++;
                this.persistent.totalShotsHit++;
                // Track if boss was hit with gun (for melee master achievement)
                if (enemy.enemyType === 'boss') {
                    this.persistent.bossHitWithGun = true;
                }
                
                // Calculate damage based on weapon type
                let damage = 1;
                if (bullet.crossbowDamage) {
                    damage = bullet.crossbowDamage; // Crossbow high damage
                } else if (bullet.rifleDamage) {
                    damage = bullet.rifleDamage; // Rifle medium damage
                }
                
                // Apply workbench damage bonus
                if (this.playerStats.hideout.workbenchLvl > 0) {
                    damage = Math.ceil(damage * (1 + CONFIG.HIDEOUT.WORKBENCH_DAMAGE_BONUS));
                }
                if (typeof enemy.takeDamage === 'function') enemy.takeDamage(damage);
            }
        });

        this.physics.add.overlap(this.bullets, this.player, (player, bullet) => {
            if (bullet.active && !bullet.hasHit) {
                if (!bullet.isEnemyBullet) return;
                // Dodge roll grants invincibility
                if (this.isDodging) return;
                bullet.hasHit = true;
                const bx = bullet.x, by = bullet.y;
                bullet.setActive(false);
                bullet.setVisible(false);
                bullet.body.enable = false;
                this.hitPlayer(1, bx, by);
            }
        });

        // Acid projectile hits player
        this.physics.add.overlap(this.acidProjectiles, this.player, (player, acid) => {
            if (acid.active && !acid.hasHit) {
                if (this.isDodging) return;
                acid.hasHit = true;
                const ax = acid.x, ay = acid.y;
                acid.setActive(false);
                acid.setVisible(false);
                acid.body.enable = false;
                this.hitPlayer(CONFIG.ENEMIES.SPITTER.DAMAGE, ax, ay);
                this.showFloatingText(this.player.x, this.player.y - 30, "ACID!", 0x00ff00);
            }
        });

        // Acid hits walls
        this.physics.add.collider(this.acidProjectiles, this.walls, (acid) => { 
            acid.setActive(false); acid.setVisible(false); acid.body.enable = false; 
        });
        this.physics.add.collider(this.acidProjectiles, this.crates, (acid) => { 
            acid.setActive(false); acid.setVisible(false); acid.body.enable = false; 
        });

        this.physics.add.overlap(this.player, this.enemies, (p, e) => {
            if (!e.active) return;
            // Dodge roll grants invincibility
            if (this.isDodging) return;
            if (e.enemyType === 'leaper' && e.state === 'LEAP') this.triggerKnockdown(e);
            else if (e.enemyType === 'bandit' && e.ammo > 0) return;
            else this.hitPlayer(e.damage, e.x, e.y);
        });

        this.physics.add.overlap(this.player, this.pickups, (p, item) => {
            this.applyLoot(item.getData('type'));
            item.destroy();
        });

        // Input
        this.cursors = this.input.keyboard.createCursorKeys();
        this.wasd = this.input.keyboard.addKeys('W,A,S,D,SHIFT');
        this.keys = this.input.keyboard.addKeys({
            interact: Phaser.Input.Keyboard.KeyCodes.F,
            space: Phaser.Input.Keyboard.KeyCodes.SPACE,
            esc: Phaser.Input.Keyboard.KeyCodes.ESC,
            melee: Phaser.Input.Keyboard.KeyCodes.E,
            switch: Phaser.Input.Keyboard.KeyCodes.Q,
            inv: Phaser.Input.Keyboard.KeyCodes.I,
            tab: Phaser.Input.Keyboard.KeyCodes.TAB,
            nvg: Phaser.Input.Keyboard.KeyCodes.N,
            reload: Phaser.Input.Keyboard.KeyCodes.R,
            grenade: Phaser.Input.Keyboard.KeyCodes.G,
            consumable1: Phaser.Input.Keyboard.KeyCodes.ONE,
            consumable2: Phaser.Input.Keyboard.KeyCodes.TWO,
            consumable3: Phaser.Input.Keyboard.KeyCodes.THREE
        });
        this.input.on('pointerdown', (p) => this.fireBullet(p));

        // Level text (UI elements like uiGraphics, bossBar already created above)
        this.levelText = this.add.text(400, 300, `LEVEL ${this.currentLevel}`, { fontSize: '64px', fill: '#fff' }).setOrigin(0.5).setDepth(200);
        this.tweens.add({ targets: this.levelText, alpha: 0, duration: 2000, delay: 1000 });
        
        // Play level start sound
        sfx.levelStart();

        this.createInventoryUI();
        this.pauseText = this.add.text(400, 300, 'PAUSED', { fontSize: '48px', fill: '#fff' }).setOrigin(0.5).setDepth(200).setVisible(false);

        // Lighting & NVG
        this.lightShape = this.make.graphics({ x: 0, y: 0, add: false });
        const mask = this.lightShape.createGeometryMask();
        mask.setInvertAlpha(true);
        this.darkness = this.add.rectangle(400, 300, 800, 600, 0x000000, 0.95).setDepth(90);
        this.darkness.setMask(mask);
        this.nvgLayer = this.add.rectangle(400, 300, 800, 600, 0x00ff00, 0.2).setDepth(95).setVisible(false);
        
        // Low HP Vignette - red edges when health is low
        this.vignetteGraphics = this.add.graphics().setDepth(105);
        
        // Scene shutdown cleanup
        this.events.on('shutdown', this.shutdown, this);
    }
    
    shutdown() {
        // Clean up graphics objects to prevent errors during transition
        if (this.lightShape) {
            this.lightShape.destroy();
            this.lightShape = null;
        }
        if (this.vignetteGraphics) {
            this.vignetteGraphics.destroy();
            this.vignetteGraphics = null;
        }
        if (this.uiGraphics) {
            this.uiGraphics.destroy();
            this.uiGraphics = null;
        }
        this.events.off('shutdown', this.shutdown, this);
    }

    // ==================== DODGE ROLL ====================
    performDodgeRoll() {
        const now = this.time.now;
        const cfg = CONFIG.PLAYER;
        
        // Check cooldown and stamina
        if (now - this.lastDodgeTime < cfg.DODGE_COOLDOWN) return;
        if (this.playerStats.stamina < cfg.DODGE_STAMINA_COST) {
            this.showFloatingText(this.player.x, this.player.y - 40, "NO STAMINA!", 0xff0000);
            return;
        }
        if (this.isDodging || this.isPinned || this.isReloading) return;
        
        // Get movement direction or face direction
        let vx = 0, vy = 0;
        if (this.cursors.left.isDown || this.wasd.A.isDown) vx = -1;
        else if (this.cursors.right.isDown || this.wasd.D.isDown) vx = 1;
        if (this.cursors.up.isDown || this.wasd.W.isDown) vy = -1;
        else if (this.cursors.down.isDown || this.wasd.S.isDown) vy = 1;
        
        // If not moving, dodge toward mouse
        if (vx === 0 && vy === 0) {
            const angle = Phaser.Math.Angle.Between(
                this.player.x, this.player.y,
                this.input.activePointer.x, this.input.activePointer.y
            );
            vx = Math.cos(angle);
            vy = Math.sin(angle);
        } else {
            // Normalize
            const len = Math.sqrt(vx * vx + vy * vy);
            vx /= len;
            vy /= len;
        }
        
        // Consume stamina
        this.playerStats.stamina -= cfg.DODGE_STAMINA_COST;
        this.isDodging = true;
        this.lastDodgeTime = now;
        
        // Visual feedback
        sfx.dodge();
        this.player.setAlpha(0.5);
        this.player.setTint(0x00ffff);
        
        // Apply velocity
        this.player.setVelocity(vx * cfg.DODGE_SPEED, vy * cfg.DODGE_SPEED);
        
        // End dodge after duration
        this.time.delayedCall(cfg.DODGE_DURATION, () => {
            this.isDodging = false;
            this.player.setAlpha(1);
            this.player.clearTint();
        });
    }

    // ==================== RELOAD SYSTEM ====================
    startReload() {
        if (this.isReloading) return;
        
        const weapon = this.playerStats.currentWeapon;
        const wpnConfig = CONFIG.WEAPONS[weapon.toUpperCase()];
        const currentMag = this.playerStats.magazines[weapon];
        
        // Already full
        if (currentMag >= wpnConfig.MAG_SIZE) {
            this.showFloatingText(this.player.x, this.player.y - 40, "MAG FULL", 0xffff00);
            return;
        }
        
        // No reserve ammo
        if (this.playerStats.ammo <= 0) {
            this.showFloatingText(this.player.x, this.player.y - 40, "NO AMMO!", 0xff0000);
            return;
        }
        
        this.isReloading = true;
        sfx.reload();
        this.showFloatingText(this.player.x, this.player.y - 40, "RELOADING...", 0xffff00);
        
        this.reloadTimer = this.time.delayedCall(wpnConfig.RELOAD_TIME, () => {
            const needed = wpnConfig.MAG_SIZE - this.playerStats.magazines[weapon];
            const toLoad = Math.min(needed, this.playerStats.ammo);
            
            this.playerStats.magazines[weapon] += toLoad;
            this.playerStats.ammo -= toLoad;
            
            this.isReloading = false;
            this.reloadTimer = null;
            sfx.reloadFinish();
            this.showFloatingText(this.player.x, this.player.y - 40, "RELOADED!", 0x00ff00);
        });
    }
    
    cancelReload() {
        if (this.reloadTimer) {
            this.reloadTimer.remove();
            this.reloadTimer = null;
        }
        this.isReloading = false;
    }

    // ==================== LOW HP VIGNETTE ====================
    drawVignette() {
        if (!this.vignetteGraphics) return;
        this.vignetteGraphics.clear();
        
        const hpPercent = this.playerStats.hp / this.playerStats.maxHp;
        if (hpPercent > CONFIG.PLAYER.LOW_HP_THRESHOLD) return;
        
        // Intensity increases as HP decreases
        const intensity = 1 - (hpPercent / CONFIG.PLAYER.LOW_HP_THRESHOLD);
        const alpha = 0.3 + intensity * 0.4; // 0.3 to 0.7
        
        // Pulsing effect when very low
        let pulseAlpha = alpha;
        if (hpPercent < 0.15) {
            const pulse = Math.sin(this.time.now / 200) * 0.15;
            pulseAlpha = alpha + pulse;
        }
        
        // Draw red gradient from edges
        const thickness = 60 + intensity * 40; // 60-100px thick
        
        // Top edge
        this.vignetteGraphics.fillGradientStyle(0xff0000, 0xff0000, 0xff0000, 0xff0000, pulseAlpha, pulseAlpha, 0, 0);
        this.vignetteGraphics.fillRect(0, 0, 800, thickness);
        
        // Bottom edge
        this.vignetteGraphics.fillGradientStyle(0xff0000, 0xff0000, 0xff0000, 0xff0000, 0, 0, pulseAlpha, pulseAlpha);
        this.vignetteGraphics.fillRect(0, 600 - thickness, 800, thickness);
        
        // Left edge
        this.vignetteGraphics.fillGradientStyle(0xff0000, 0xff0000, 0xff0000, 0xff0000, pulseAlpha, 0, 0, pulseAlpha);
        this.vignetteGraphics.fillRect(0, 0, thickness, 600);
        
        // Right edge
        this.vignetteGraphics.fillGradientStyle(0xff0000, 0xff0000, 0xff0000, 0xff0000, 0, pulseAlpha, pulseAlpha, 0);
        this.vignetteGraphics.fillRect(800 - thickness, 0, thickness, 600);
    }

    spawnLootSkull(x, y, enemyType, killSource = 'gun') {
        // Track kill stats
        this.persistent.runKills++;
        this.persistent.totalKills++;
        
        if (killSource === 'melee') {
            this.persistent.meleeKills++;
            this.persistent.runMeleeKills++;
        } else if (killSource === 'grenade') {
            this.persistent.totalGrenadeKills++;
            this.persistent.runGrenadeKills++;
        }
        
        if (enemyType === 'boss') {
            this.persistent.bossesKilled++;
        }
        
        // Check achievements after kill
        const newAchievements = checkAchievements(this.persistent, {
            hasAllWeapons: this.playerStats.hasShotgun && this.playerStats.hasSMG
        });
        newAchievements.forEach(a => {
            sfx.achievement();
            this.showFloatingText(400, 200, `${a.icon} ${a.name}!`, 0xffd700);
        });
        
        // NEW: Auto-collect currency based on enemy type
        const dropConfig = CONFIG.ENEMY_DROPS[enemyType.toUpperCase()];
        if (dropConfig) {
            const amount = Phaser.Math.Between(dropConfig.min, dropConfig.max);
            const currency = dropConfig.currency;
            
            // Add currency to player and track in persistent stats
            if (currency === 'scrap') {
                this.playerStats.scrap += amount;
                this.persistent.totalScrapCollected += amount;
            } else if (currency === 'credits') {
                this.playerStats.credits += amount;
                this.persistent.totalCreditsEarned += amount;
            } else if (currency === 'materials') {
                this.playerStats.materials += amount;
                this.persistent.totalMaterialsCollected += amount;
            }
            
            // Show floating text for currency
            const currencyConfig = CONFIG.CURRENCIES[currency.toUpperCase()];
            this.showFloatingText(x, y - 20, `+${amount} ${currencyConfig.icon}`, currencyConfig.color);
            sfx.loot();
            
            // Spawn skull with random item (not currency) if items available
            if (dropConfig.items && dropConfig.items.length > 0) {
                const item = Phaser.Utils.Array.GetRandom(dropConfig.items);
                let s = this.skulls.create(x, y, 'skull').setScale(0.8);
                s.setData('lootID', item);
            }
        }
        
        savePersistent(this.persistent);
    }

    // ==================== ACID SPIT (Spitter Enemy) ====================
    spawnAcidSpit(fromX, fromY, toX, toY) {
        const acid = this.acidProjectiles.create(fromX, fromY, 'acid');
        if (!acid) return;
        
        acid.hasHit = false;
        acid.setDepth(15);
        
        const angle = Phaser.Math.Angle.Between(fromX, fromY, toX, toY);
        this.physics.velocityFromRotation(angle, CONFIG.ENEMIES.SPITTER.SPIT_SPEED, acid.body.velocity);
        
        // Destroy after 3 seconds if not hit
        this.time.delayedCall(3000, () => {
            if (acid.active) {
                acid.setActive(false);
                acid.setVisible(false);
                acid.body.enable = false;
            }
        });
    }

    // ==================== GRENADE SYSTEM ====================
    throwGrenade() {
        if (this.playerStats.grenades <= 0) {
            this.showFloatingText(this.player.x, this.player.y - 40, "NO GRENADES!", 0xff0000);
            return;
        }
        if (this.isDodging || this.isPinned || this.isReloading) return;

        this.playerStats.grenades--;
        sfx.grenadeThrow();

        const grenade = this.grenades.create(this.player.x, this.player.y, 'grenade');
        if (!grenade) return;

        grenade.setDepth(15);
        grenade.hasExploded = false;

        // Throw toward mouse
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            this.input.activePointer.x, this.input.activePointer.y
        );
        this.physics.velocityFromRotation(angle, CONFIG.GRENADE.THROW_SPEED, grenade.body.velocity);
        
        // Slow down over time (drag)
        grenade.body.setDrag(200, 200);

        // Explode after fuse time
        this.time.delayedCall(CONFIG.GRENADE.FUSE_TIME, () => {
            if (grenade.active && !grenade.hasExploded) {
                this.explodeGrenade(grenade.x, grenade.y);
                grenade.hasExploded = true;
                grenade.destroy();
            }
        });
    }
    
    // ==================== CONSUMABLE SYSTEM ====================
    useConsumable(slot) {
        if (this.isPaused || this.isInventoryOpen || this.isDodging || this.isPinned) return;
        
        // Defensive check for corrupted consumables array
        if (!this.playerStats.consumables || !Array.isArray(this.playerStats.consumables)) {
            this.playerStats.consumables = [null, null, null];
        }
        
        const consumable = this.playerStats.consumables[slot];
        if (!consumable) {
            this.showFloatingText(this.player.x, this.player.y - 40, `SLOT ${slot + 1} EMPTY`, 0xff0000);
            return;
        }
        
        const config = CONFIG.CONSUMABLES[consumable];
        if (!config) return;
        
        // Apply effect based on consumable type
        if (config.effect === 'speed') {
            // Adrenaline - speed boost
            this.speedMultiplier = config.multiplier;
            sfx.useConsumable();
            this.showFloatingText(this.player.x, this.player.y - 40, "ADRENALINE!", 0x00ff00);
            
            // Visual feedback - tint player
            this.player.setTint(0x00ff00);
            
            // End effect after duration
            this.time.delayedCall(config.duration, () => {
                this.speedMultiplier = 1;
                if (this.player.active) {
                    this.player.clearTint();
                    this.showFloatingText(this.player.x, this.player.y - 40, "Speed normal", 0xffffff);
                }
            });
        } else if (config.effect === 'repair') {
            // Armor Patch - instant armor repair
            let repaired = false;
            const slots = ['head', 'body', 'arms', 'feet'];
            for (const armorSlot of slots) {
                if (this.playerStats.armor[armorSlot]) {
                    const armor = this.playerStats.armor[armorSlot];
                    if (armor.durability < armor.maxDurability) {
                        armor.durability = Math.min(armor.durability + config.amount, armor.maxDurability);
                        repaired = true;
                    }
                }
            }
            
            if (repaired) {
                sfx.useConsumable();
                this.showFloatingText(this.player.x, this.player.y - 40, "ARMOR PATCHED!", 0x00aaff);
            } else {
                this.showFloatingText(this.player.x, this.player.y - 40, "No armor to repair!", 0xff0000);
                return; // Don't consume if nothing to repair
            }
        }
        
        // Remove consumable from slot
        this.playerStats.consumables[slot] = null;
    }

    explodeGrenade(x, y) {
        sfx.explosion();
        if (this.gameSettings.screenShake) this.cameras.main.shake(200, 0.02);

        // Visual explosion
        const explosion = this.add.circle(x, y, 10, 0xff4500, 1).setDepth(100);
        this.tweens.add({
            targets: explosion,
            radius: CONFIG.GRENADE.EXPLOSION_RADIUS,
            alpha: 0,
            duration: 300,
            onComplete: () => explosion.destroy()
        });

        // Spawn multiple flash particles
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const dist = 30 + Math.random() * 40;
            this.particles.spawnMuzzleFlash(
                x + Math.cos(angle) * dist,
                y + Math.sin(angle) * dist,
                angle, 1.5
            );
        }

        // Damage enemies in radius and track kills for achievement
        let grenadeKillsThisExplosion = 0;
        const enemiesInRange = [];
        
        // First pass: collect enemies and their HP
        this.enemies.getChildren().forEach(enemy => {
            if (!enemy.active) return;
            const dist = Phaser.Math.Distance.Between(x, y, enemy.x, enemy.y);
            if (dist < CONFIG.GRENADE.EXPLOSION_RADIUS) {
                const damageMult = 1 - (dist / CONFIG.GRENADE.EXPLOSION_RADIUS) * 0.5;
                const damage = Math.ceil(CONFIG.GRENADE.DAMAGE * damageMult);
                enemiesInRange.push({ enemy, damage, willDie: enemy.hp <= damage });
            }
        });
        
        // Count kills before applying damage
        grenadeKillsThisExplosion = enemiesInRange.filter(e => e.willDie).length;
        
        // Second pass: apply damage
        enemiesInRange.forEach(({ enemy, damage }) => {
            if (enemy.takeDamage) enemy.takeDamage(damage, 'grenade');
            
            // Knockback (only if enemy still alive and has body)
            if (enemy.active && enemy.body) {
                const knockAngle = Phaser.Math.Angle.Between(x, y, enemy.x, enemy.y);
                this.physics.velocityFromRotation(knockAngle, 300, enemy.body.velocity);
            }
        });
        
        // Check grenadier achievement (3+ kills with one grenade)
        if (grenadeKillsThisExplosion >= 3) {
            const newAchievements = checkAchievements(this.persistent, { grenadeMultiKill: grenadeKillsThisExplosion });
            newAchievements.forEach(a => {
                sfx.achievement();
                this.showFloatingText(400, 200, `${a.icon} ${a.name}!`, 0xffd700);
            });
            savePersistent(this.persistent);
        }

        this.showFloatingText(x, y, "BOOM!", 0xff4500);
    }
    
    exploderExplosion(x, y) {
        const cfg = CONFIG.ENEMIES.EXPLODER;
        sfx.exploderExplode();
        if (this.gameSettings.screenShake) this.cameras.main.shake(150, 0.015);

        // Visual explosion - orange
        const explosion = this.add.circle(x, y, 10, 0xff6600, 1).setDepth(100);
        this.tweens.add({
            targets: explosion,
            radius: cfg.EXPLOSION_RADIUS,
            alpha: 0,
            duration: 250,
            onComplete: () => explosion.destroy()
        });

        // Spawn flash particles
        for (let i = 0; i < 6; i++) {
            const angle = (i / 6) * Math.PI * 2;
            const dist = 20 + Math.random() * 30;
            this.particles.spawnMuzzleFlash(
                x + Math.cos(angle) * dist,
                y + Math.sin(angle) * dist,
                angle, 1.2
            );
        }

        // Damage player if in range
        const playerDist = Phaser.Math.Distance.Between(x, y, this.player.x, this.player.y);
        if (playerDist < cfg.EXPLOSION_RADIUS) {
            this.hitPlayer(cfg.DAMAGE, x, y);
        }

        // Damage other enemies in range (chain reactions!)
        this.enemies.getChildren().forEach(enemy => {
            if (!enemy.active) return;
            const dist = Phaser.Math.Distance.Between(x, y, enemy.x, enemy.y);
            if (dist < cfg.EXPLOSION_RADIUS && dist > 0) { // dist > 0 prevents self-damage
                const damageMult = 1 - (dist / cfg.EXPLOSION_RADIUS) * 0.5;
                const damage = Math.ceil(cfg.ENEMY_DAMAGE * damageMult);
                if (enemy.takeDamage) enemy.takeDamage(damage, 'explosion');
                
                // Knockback
                if (enemy.active && enemy.body) {
                    const knockAngle = Phaser.Math.Angle.Between(x, y, enemy.x, enemy.y);
                    this.physics.velocityFromRotation(knockAngle, 200, enemy.body.velocity);
                }
            }
        });

        this.showFloatingText(x, y, "KABOOM!", 0xff6600);
    }
    
    spawnNecroProjectile(fromX, fromY, toX, toY) {
        const cfg = CONFIG.ENEMIES.NECROMANCER;
        // Create a slow-moving projectile
        const proj = this.acidProjectiles.get(fromX, fromY);
        if (proj) {
            proj.body.reset(fromX, fromY);
            proj.body.enable = true;
            proj.setActive(true);
            proj.setVisible(true);
            proj.hasHit = false;
            proj.setTint(0x8800ff); // Purple for necro
            proj.setScale(1.5);
            
            const angle = Phaser.Math.Angle.Between(fromX, fromY, toX, toY);
            this.physics.velocityFromRotation(angle, cfg.PROJECTILE_SPEED, proj.body.velocity);
            proj.setRotation(angle);
        }
    }

    createInventoryUI() {
        this.invContainer = this.add.container(400, 300).setDepth(300).setVisible(false);
        const bg = this.add.rectangle(0, 0, 600, 400, 0x111111, 0.9).setStrokeStyle(4, 0x444444);
        const title = this.add.text(0, -180, "INVENTORY", { fontSize: '32px', fill: '#fff' }).setOrigin(0.5);
        this.invText = this.add.text(-280, -140, "", { fontSize: '18px', fill: '#ccc', lineSpacing: 10 });
        this.armorSlots = {};
        const slots = [
            { id: 'head', x: 150, y: -100, label: 'HEAD' },
            { id: 'body', x: 150, y: 0, label: 'BODY' },
            { id: 'arms', x: 50, y: 0, label: 'ARMS' },
            { id: 'feet', x: 150, y: 100, label: 'FEET' }
        ];
        slots.forEach(s => {
            let slotBg = this.add.rectangle(s.x, s.y, 80, 80, 0x333333).setStrokeStyle(1, 0x666666);
            let lbl = this.add.text(s.x, s.y - 30, s.label, { fontSize: '12px', fill: '#888' }).setOrigin(0.5);
            let itemTxt = this.add.text(s.x, s.y, "EMPTY", { fontSize: '12px', fill: '#555' }).setOrigin(0.5);
            this.invContainer.add([slotBg, lbl, itemTxt]);
            this.armorSlots[s.id] = itemTxt;
        });
        this.invContainer.add([bg, title, this.invText]);
    }

    updateInventoryUI() {
        const weapon = this.playerStats.currentWeapon;
        const mag = this.playerStats.magazines[weapon];
        const maxMag = CONFIG.WEAPONS[weapon.toUpperCase()].MAG_SIZE;
        
        this.invText.setText(
            `HP: ${this.playerStats.hp}/${this.playerStats.maxHp}\n` +
            `AMMO: ${mag}/${maxMag} (${this.playerStats.ammo} reserve)\n` +
            `GRENADES: ${this.playerStats.grenades}/${CONFIG.GRENADE.MAX_CARRY}\n` +
            `SCRAP: ${this.playerStats.scrap}\n\n` +
            `WEAPON: ${weapon.toUpperCase()}\n` +
            `FLASHLIGHT: ${this.playerStats.hasFlashlight ? "YES" : "NO"}\n` +
            `NVG: ${this.playerStats.hideout.armory.hasNVG ? "EQUIPPED" : "NO"}\n`
        );
        for (const [slot, item] of Object.entries(this.playerStats.armor)) {
            let txtObj = this.armorSlots[slot];
            if (item) {
                txtObj.setText(`${item.name}\n${item.durability}/${item.maxDurability}`);
                txtObj.setColor('#00ff00');
            } else {
                txtObj.setText("EMPTY");
                txtObj.setColor('#555');
            }
        }
    }

    toggleInventory() {
        this.isInventoryOpen = !this.isInventoryOpen;
        if (this.isInventoryOpen) {
            sfx.menuOpen();
            this.updateInventoryUI();
            this.invContainer.setVisible(true);
            this.physics.pause();
            this.isPaused = true;
        } else {
            sfx.menuClose();
            this.invContainer.setVisible(false);
            this.physics.resume();
            this.isPaused = false;
        }
    }

    togglePause() {
        this.isPaused = !this.isPaused;
        if (this.isPaused) {
            sfx.menuOpen();
            this.physics.pause();
            this.pauseText.setVisible(true);
        } else {
            sfx.menuClose();
            this.physics.resume();
            this.pauseText.setVisible(false);
        }
    }

    setupMapForLevel(level) {
        if (level === 1) {
            this.add.tileSprite(400, 300, 800, 600, 'floor_grass');
            this.door = this.physics.add.staticSprite(400, 50, 'door');
            this.walls.create(200, 200, 'wall').setScale(1, 4).refreshBody();
            this.walls.create(600, 200, 'wall').setScale(1, 4).refreshBody();
        } else if (level === 2) {
            this.add.tileSprite(400, 300, 800, 600, 'floor_apt');
            this.door = this.physics.add.staticSprite(400, 50, 'door').setTint(0x0000ff);
            this.debrisBlock = this.debris.create(400, 100, 'debris');
            this.walls.create(250, 300, 'wall').setScale(1, 15).refreshBody();
            this.walls.create(550, 300, 'wall').setScale(1, 15).refreshBody();
        } else if (level === 3) {
            this.add.tileSprite(400, 300, 800, 600, 'floor_roof');
            this.door = this.physics.add.staticSprite(400, 50, 'door').setTint(0x00ff00);
        } else if (level === 4) {
            // SEWERS - Dark, tight corridors with toxic spitters
            this.add.tileSprite(400, 300, 800, 600, 'floor_sewer');
            this.door = this.physics.add.staticSprite(750, 300, 'door').setTint(0x00ffff);
            // Sewer pipe walls - narrow corridor maze
            this.walls.create(200, 150, 'wall').setScale(6, 1).refreshBody();
            this.walls.create(600, 150, 'wall').setScale(3, 1).refreshBody();
            this.walls.create(100, 300, 'wall').setScale(1, 4).refreshBody();
            this.walls.create(400, 300, 'wall').setScale(1, 6).refreshBody();
            this.walls.create(200, 450, 'wall').setScale(6, 1).refreshBody();
            this.walls.create(550, 450, 'wall').setScale(4, 1).refreshBody();
            // Water hazard visual (dark area)
            this.add.rectangle(300, 380, 150, 80, 0x003300, 0.5).setDepth(1);
        } else if (level === 5) {
            // HOSPITAL - Open areas, mini boss
            this.add.tileSprite(400, 300, 800, 600, 'floor_hospital');
            this.door = this.physics.add.staticSprite(400, 50, 'door').setTint(0xff00ff);
            // Hospital layout - rooms and corridors
            this.walls.create(150, 200, 'wall').setScale(1, 8).refreshBody();
            this.walls.create(650, 200, 'wall').setScale(1, 8).refreshBody();
            this.walls.create(300, 100, 'wall').setScale(4, 1).refreshBody();
            this.walls.create(500, 100, 'wall').setScale(4, 1).refreshBody();
            this.walls.create(400, 350, 'wall').setScale(8, 1).refreshBody();
        } else if (level === 6) {
            // MALL - Multi-floor combat with balcony enemies
            this.add.tileSprite(400, 300, 800, 600, 'floor_apt'); // Reuse apartment floor for mall
            this.door = this.physics.add.staticSprite(400, 50, 'door').setTint(0xffff00);
            
            // Mall structure - ground floor with upper balcony
            // Ground floor stores (left and right)
            this.walls.create(100, 450, 'wall').setScale(3, 4).refreshBody();
            this.walls.create(700, 450, 'wall').setScale(3, 4).refreshBody();
            
            // Upper floor balcony walls
            this.walls.create(100, 150, 'wall').setScale(4, 1).refreshBody();
            this.walls.create(700, 150, 'wall').setScale(4, 1).refreshBody();
            
            // Central escalator area (narrow paths)
            this.walls.create(300, 250, 'wall').setScale(1, 3).refreshBody();
            this.walls.create(500, 250, 'wall').setScale(1, 3).refreshBody();
            
            // Cover objects (benches, planters)
            this.crates.create(200, 350, 'crate').setTint(0x8B4513); // Bench
            this.crates.create(600, 350, 'crate').setTint(0x8B4513); // Bench
            this.crates.create(400, 500, 'crate').setTint(0x228B22); // Planter
            
            // Visual: Balcony indicator
            this.add.rectangle(400, 100, 600, 80, 0x333333, 0.3).setDepth(1);
            this.add.text(400, 100, "UPPER FLOOR", { fontSize: '14px', fill: '#666' }).setOrigin(0.5).setDepth(2);
        } else if (level === 7) {
            // CEMETERY - Stealth graveyard leading to church boss arena
            this.add.tileSprite(400, 300, 800, 600, 'floor_grass'); // Dark grass
            this.add.rectangle(400, 300, 800, 600, 0x001100, 0.5).setDepth(0); // Dark overlay
            this.door = this.physics.add.staticSprite(-100, -100, 'door'); // No door - boss extraction level
            
            // Graveyard tombstones (cover for stealth)
            const tombPositions = [
                {x: 150, y: 450}, {x: 250, y: 400}, {x: 350, y: 480},
                {x: 450, y: 420}, {x: 550, y: 460}, {x: 650, y: 400},
                {x: 200, y: 300}, {x: 400, y: 320}, {x: 600, y: 280}
            ];
            tombPositions.forEach(pos => {
                const tomb = this.walls.create(pos.x, pos.y, 'wall');
                tomb.setScale(0.5, 1).refreshBody();
                tomb.setTint(0x555555); // Gray tombstone
            });
            
            // Church entrance walls
            this.walls.create(200, 100, 'wall').setScale(4, 1).refreshBody();
            this.walls.create(600, 100, 'wall').setScale(4, 1).refreshBody();
            this.walls.create(100, 150, 'wall').setScale(1, 3).refreshBody();
            this.walls.create(700, 150, 'wall').setScale(1, 3).refreshBody();
            
            // Church interior visual
            this.add.rectangle(400, 100, 400, 150, 0x222222, 0.5).setDepth(1);
            this.add.text(400, 50, "CHURCH", { fontSize: '18px', fill: '#555' }).setOrigin(0.5).setDepth(2);
            
            // Moonlight patches (detection zones - visual only, stealth handles mechanics)
            this.add.circle(300, 380, 40, 0xffffcc, 0.1).setDepth(1);
            this.add.circle(500, 350, 50, 0xffffcc, 0.1).setDepth(1);
        }
    }

    spawnLevelEntities(level) {
        let loot = [], cratePos = [];
        if (level === 1) {
            loot = ['key', 'flashlight', 'shotgun', 'ammo', 'ammo', 'helmet', 'vest', 'scrap'];
            cratePos = [{x:100,y:100}, {x:700,y:500}, {x:50,y:300}, {x:750,y:300}, {x:400,y:400}, {x:200,y:50}, {x:600,y:50}, {x:400,y:500}];
            this.spawnEnemy('walker', 100, 300);
            this.spawnEnemy('bandit', 700, 300);
            this.spawnEnemy('leaper', 200, 200);
        } else if (level === 2) {
            loot = ['molotov', 'shotgun', 'ammo', 'ammo', 'scrap', 'helmet', 'vest', 'plug'];
            cratePos = [{x:100,y:100}, {x:100,y:500}, {x:700,y:100}, {x:700,y:500}, {x:400,y:300}, {x:50,y:250}, {x:750,y:250}, {x:200,y:550}, {x:400,y:550}, {x:600,y:400}];
            this.spawnEnemy('bandit', 100, 100);
            this.spawnEnemy('bandit', 700, 100);
            this.spawnEnemy('leaper', 400, 450);
            this.spawnEnemy('leaper', 400, 150);
        } else if (level === 3) {
            loot = ['key', 'ammo', 'ammo', 'meds', 'meds', 'scrap', 'grenade'];
            cratePos = [{x:100,y:100}, {x:700,y:100}, {x:100,y:500}, {x:700,y:500}, {x:400,y:300}, {x:50,y:300}, {x:750,y:300}];
            this.spawnEnemy('walker', 400, 100);
            this.spawnEnemy('walker', 200, 300);
            this.spawnEnemy('spitter', 600, 300);
            this.spawnEnemy('bandit', 100, 500);
            this.spawnEnemy('bandit', 700, 500);
        } else if (level === 4) {
            // SEWERS - Spitter-heavy with tight corridors
            loot = ['key', 'smg', 'ammo', 'ammo', 'ammo', 'grenade', 'grenade', 'meds', 'scrap', 'plug'];
            cratePos = [{x:50,y:80}, {x:700,y:80}, {x:50,y:520}, {x:700,y:520}, {x:250,y:220}, {x:550,y:220}, {x:250,y:380}, {x:650,y:380}, {x:500,y:550}, {x:150,y:550}];
            // Spitters in the sewers
            this.spawnEnemy('spitter', 300, 250);
            this.spawnEnemy('spitter', 500, 250);
            this.spawnEnemy('spitter', 200, 500);
            // Walkers emerging from pipes
            this.spawnEnemy('walker', 100, 200);
            this.spawnEnemy('walker', 650, 500);
            this.spawnEnemy('leaper', 400, 200);
        } else if (level === 5) {
            // HOSPITAL - Boss fight
            loot = ['ammo', 'ammo', 'ammo', 'meds', 'meds', 'grenade', 'scrap', 'scrap'];
            cratePos = [{x:100,y:450}, {x:700,y:450}, {x:100,y:550}, {x:700,y:550}, {x:300,y:550}, {x:500,y:550}, {x:250,y:250}, {x:550,y:250}];
            // Hospital Boss
            this.spawnEnemy('boss', 400, 150);
            this.bossBar.setVisible(true);
            this.bossText.setVisible(true);
            this.bossText.setText("PATIENT ZERO");
            this.updateBossBar(CONFIG.ENEMIES.BOSS.HP, CONFIG.ENEMIES.BOSS.HP);
            // Boss entrance roar
            this.time.delayedCall(500, () => sfx.bossRoar());
            // Support enemies
            this.spawnEnemy('spitter', 200, 200);
            this.spawnEnemy('spitter', 600, 200);
            this.spawnEnemy('walker', 100, 400);
            this.spawnEnemy('walker', 700, 400);
        } else if (level === 6) {
            // MALL - Multi-floor combat with exploders
            loot = ['key', 'rifle', 'ammo', 'ammo', 'ammo', 'meds', 'grenade', 'grenade', 'scrap', 'helmet'];
            cratePos = [
                {x:100,y:550}, {x:700,y:550}, {x:100,y:350}, {x:700,y:350},
                {x:250,y:150}, {x:550,y:150}, {x:400,y:450}, {x:150,y:200},
                {x:650,y:200}, {x:400,y:250}
            ];
            
            // Ground floor enemies
            this.spawnEnemy('exploder', 150, 400);
            this.spawnEnemy('exploder', 650, 400);
            this.spawnEnemy('walker', 300, 500);
            this.spawnEnemy('walker', 500, 500);
            
            // Upper floor bandits (shooting down)
            this.spawnEnemy('bandit', 200, 100);
            this.spawnEnemy('bandit', 600, 100);
            
            // Spitters in strategic positions
            this.spawnEnemy('spitter', 400, 200);
            
            // Store spawn waves (delayed)
            this.time.delayedCall(5000, () => {
                if (this.currentLevel === 6) {
                    this.showFloatingText(100, 400, "STORE BREACH!", 0xff0000);
                    this.spawnEnemy('exploder', 80, 450);
                    this.spawnEnemy('walker', 80, 480);
                }
            });
            this.time.delayedCall(10000, () => {
                if (this.currentLevel === 6) {
                    this.showFloatingText(700, 400, "STORE BREACH!", 0xff0000);
                    this.spawnEnemy('exploder', 720, 450);
                    this.spawnEnemy('walker', 720, 480);
                }
            });
        } else if (level === 7) {
            // CEMETERY - Stealth section + Necromancer boss
            loot = ['key', 'crossbow', 'ammo', 'ammo', 'meds', 'meds', 'grenade', 'scrap', 'materials'];
            cratePos = [
                {x:100,y:550}, {x:700,y:550}, {x:200,y:350}, {x:600,y:350},
                {x:150,y:250}, {x:650,y:250}, {x:400,y:400}, {x:300,y:500},
                {x:500,y:500}
            ];
            
            // Initialize stealth system for this level
            this.isStealthLevel = true;
            this.detectionMeter = 0;
            this.maxDetection = 100;
            this.detectionRate = 20; // Per second when spotted
            this.detectionDecay = 10; // Per second when hidden
            this.stealthAlerted = false;
            
            // Create detection UI
            this.detectionBar = this.add.graphics().setDepth(150);
            this.detectionText = this.add.text(400, 40, "STEALTH", { fontSize: '16px', fill: '#fff' }).setOrigin(0.5).setDepth(150);
            
            // Graveyard patrol enemies (stealth section)
            this.patrolEnemies = [];
            const patrol1 = this.spawnPatrolEnemy('walker', 200, 400, [{x:200,y:400}, {x:200,y:300}, {x:300,y:300}, {x:300,y:400}]);
            const patrol2 = this.spawnPatrolEnemy('walker', 500, 350, [{x:500,y:350}, {x:600,y:350}, {x:600,y:450}, {x:500,y:450}]);
            const patrol3 = this.spawnPatrolEnemy('walker', 350, 450, [{x:350,y:450}, {x:450,y:450}]);
            
            // Necromancer boss in church area
            this.spawnEnemy('necromancer', 400, 80);
            this.bossBar.setVisible(true);
            this.bossText.setVisible(true);
            this.bossText.setText("THE NECROMANCER");
            this.updateBossBar(CONFIG.ENEMIES.NECROMANCER.HP, CONFIG.ENEMIES.NECROMANCER.HP);
            // Boss entrance
            this.time.delayedCall(500, () => sfx.necroSummon());
        }
        Phaser.Utils.Array.Shuffle(loot);
        cratePos.forEach((p, i) => {
            if (i < loot.length) this.crates.create(p.x, p.y, 'crate').setData('lootID', loot[i]);
        });
    }

    spawnEnemy(type, x, y) {
        this.enemies.add(new Enemy(this, x, y, this.player, type));
    }
    
    spawnPatrolEnemy(type, x, y, waypoints) {
        const enemy = new Enemy(this, x, y, this.player, type);
        enemy.isPatrol = true;
        enemy.waypoints = waypoints;
        enemy.currentWaypoint = 0;
        enemy.patrolSpeed = 30; // Slower patrol speed
        enemy.visionRange = 150;
        enemy.visionAngle = Math.PI / 3; // 60 degree cone
        this.enemies.add(enemy);
        if (!this.patrolEnemies) this.patrolEnemies = [];
        this.patrolEnemies.push(enemy);
        return enemy;
    }
    
    updatePatrolEnemies(time, delta) {
        if (!this.patrolEnemies) return;
        
        this.patrolEnemies.forEach(enemy => {
            if (!enemy.active || !enemy.isPatrol) return;
            
            // If alerted, chase player instead of patrolling
            if (this.stealthAlerted) {
                enemy.isPatrol = false;
                return;
            }
            
            // Move to current waypoint
            const wp = enemy.waypoints[enemy.currentWaypoint];
            const dist = Phaser.Math.Distance.Between(enemy.x, enemy.y, wp.x, wp.y);
            
            if (dist < 10) {
                // Reached waypoint, move to next
                enemy.currentWaypoint = (enemy.currentWaypoint + 1) % enemy.waypoints.length;
            } else {
                // Move toward waypoint
                this.physics.moveToObject(enemy, wp, enemy.patrolSpeed);
            }
        });
    }
    
    updateStealthMechanics(time, delta) {
        let isDetected = false;
        
        // Check if any patrol enemy can see the player
        if (this.patrolEnemies) {
            this.patrolEnemies.forEach(enemy => {
                if (!enemy.active) return;
                
                const dist = Phaser.Math.Distance.Between(enemy.x, enemy.y, this.player.x, this.player.y);
                if (dist > enemy.visionRange) return;
                
                // Check vision cone
                const angleToPlayer = Phaser.Math.Angle.Between(enemy.x, enemy.y, this.player.x, this.player.y);
                const enemyFacing = Math.atan2(enemy.body.velocity.y, enemy.body.velocity.x);
                let angleDiff = Math.abs(angleToPlayer - enemyFacing);
                if (angleDiff > Math.PI) angleDiff = Math.PI * 2 - angleDiff;
                
                if (angleDiff < enemy.visionAngle) {
                    // Player is in vision cone - check line of sight (simplified)
                    isDetected = true;
                }
            });
        }
        
        // Update detection meter
        const deltaSeconds = delta / 1000;
        if (isDetected) {
            this.detectionMeter += this.detectionRate * deltaSeconds;
            // Play ping sound periodically
            if (Math.floor(this.detectionMeter / 25) !== Math.floor((this.detectionMeter - this.detectionRate * deltaSeconds) / 25)) {
                sfx.detectionPing();
            }
        } else {
            this.detectionMeter -= this.detectionDecay * deltaSeconds;
        }
        this.detectionMeter = Phaser.Math.Clamp(this.detectionMeter, 0, this.maxDetection);
        
        // Update detection UI
        if (this.detectionBar) {
            this.detectionBar.clear();
            // Background
            this.detectionBar.fillStyle(0x333333);
            this.detectionBar.fillRect(300, 55, 200, 15);
            // Fill based on detection
            const fillColor = this.detectionMeter < 50 ? 0x00ff00 : (this.detectionMeter < 80 ? 0xffff00 : 0xff0000);
            this.detectionBar.fillStyle(fillColor);
            this.detectionBar.fillRect(300, 55, 200 * (this.detectionMeter / this.maxDetection), 15);
            // Border
            this.detectionBar.lineStyle(2, 0xffffff);
            this.detectionBar.strokeRect(300, 55, 200, 15);
        }
        
        // Check for full detection
        if (this.detectionMeter >= this.maxDetection && !this.stealthAlerted) {
            this.triggerStealthAlert();
        }
    }
    
    triggerStealthAlert() {
        this.stealthAlerted = true;
        sfx.detectionMax();
        this.showFloatingText(400, 200, "DETECTED!", 0xff0000);
        
        // Update detection text
        if (this.detectionText) {
            this.detectionText.setText("ALERTED!");
            this.detectionText.setColor('#ff0000');
        }
        
        // All patrol enemies become aggressive
        if (this.patrolEnemies) {
            this.patrolEnemies.forEach(enemy => {
                if (enemy.active) {
                    enemy.isPatrol = false;
                }
            });
        }
        
        // Spawn reinforcement horde
        this.showFloatingText(400, 300, "HORDE INCOMING!", 0xff0000);
        this.time.delayedCall(500, () => {
            this.spawnEnemy('walker', 100, 500);
            this.spawnEnemy('walker', 700, 500);
            this.spawnEnemy('walker', 200, 550);
            this.spawnEnemy('walker', 600, 550);
            this.spawnEnemy('leaper', 400, 580);
        });
    }
    
    // Check if player is in shadow (behind tombstone/cover)
    isPlayerInShadow() {
        // Simplified: player is "in shadow" if near a wall/tombstone
        let inShadow = false;
        this.walls.getChildren().forEach(wall => {
            const dist = Phaser.Math.Distance.Between(this.player.x, this.player.y, wall.x, wall.y);
            if (dist < 50) inShadow = true;
        });
        return inShadow;
    }

    spawnSwitch(x, y) {
        this.switches.create(x, y, 'switch');
        this.showFloatingText(x, y, "BOSS DEAD! HIT THE SWITCH!", 0x00ff00);
        this.switchDropped = true;
        this.bossBar.setVisible(false);
        this.bossText.setVisible(false);
    }

    activateExtraction() {
        if (this.extractionActive) return;
        this.extractionActive = true;
        sfx.extractionStart();
        this.tweens.add({ targets: this.darkness, alpha: 0.2, duration: 500, yoyo: true, repeat: -1 });
        this.showFloatingText(400, 300, "BEACON ONLINE! SURVIVE 15s!", 0xff0000);
        this.spawnEnemy('bandit', 100, 100);
        this.spawnEnemy('bandit', 700, 100);
        this.spawnEnemy('leaper', 400, 500);
        this.spawnEnemy('leaper', 100, 500);
        this.extractionTimerEvent = this.time.addEvent({
            delay: 1000,
            callback: () => {
                this.extractionTimer--;
                sfx.extractionTick();
                if (this.extractionTimer <= 0) this.winGame();
            },
            repeat: 14
        });
        this.activeTimerEvents.push(this.extractionTimerEvent);
    }

    cleanupTimerEvents() {
        this.activeTimerEvents.forEach(event => {
            if (event) this.time.removeEvent(event);
        });
        this.activeTimerEvents = [];
        if (this.extractionTimerEvent) {
            this.time.removeEvent(this.extractionTimerEvent);
            this.extractionTimerEvent = null;
        }
        this.cancelReload();
    }

    update(time, delta) {
        // Skip all updates during level transitions
        if (this.isTransitioning) return;
        
        // Input handling (works even when paused for menu/inventory)
        if (Phaser.Input.Keyboard.JustDown(this.keys.tab) || Phaser.Input.Keyboard.JustDown(this.keys.inv)) {
            this.toggleInventory();
        }
        if (Phaser.Input.Keyboard.JustDown(this.keys.esc)) {
            if (this.isInventoryOpen) this.toggleInventory();
            else this.togglePause();
        }

        if (Phaser.Input.Keyboard.JustDown(this.keys.nvg)) {
            if (this.playerStats.hideout.armory.hasNVG) {
                sfx.toggleNVG();
                this.nvgOn = !this.nvgOn;
                if (this.nvgOn) {
                    this.darkness.setVisible(false);
                    this.nvgLayer.setVisible(true);
                    this.cameras.main.setBackgroundColor(0x002200);
                } else {
                    this.darkness.setVisible(true);
                    this.nvgLayer.setVisible(false);
                    this.cameras.main.setBackgroundColor(0x000000);
                }
            } else {
                this.showFloatingText(this.player.x, this.player.y - 40, "NO NVG EQUIPPED", 0xffffff);
            }
        }

        if (this.isPaused) return;

        this.drawUI();
        this.drawVignette();
        this.enemies.getChildren().forEach(e => e.update(time, delta));
        
        // Update stealth mechanics for Cemetery level
        if (this.isStealthLevel && !this.stealthAlerted) {
            this.updateStealthMechanics(time, delta);
        }
        
        // Update patrol enemies
        if (this.patrolEnemies) {
            this.updatePatrolEnemies(time, delta);
        }

        // Update lighting (with safety check for scene transitions)
        if (this.lightShape && this.lightShape.scene) {
            this.lightShape.clear();
            this.lightShape.fillCircle(this.player.x, this.player.y, CONFIG.PLAYER.LIGHT_RADIUS);
            if (this.playerStats.hasFlashlight) {
                const angle = Phaser.Math.Angle.Between(this.player.x, this.player.y, this.input.activePointer.x, this.input.activePointer.y);
                this.lightShape.fillStyle(0xffffff);
                this.lightShape.slice(this.player.x, this.player.y, CONFIG.PLAYER.FLASHLIGHT_RANGE, angle - CONFIG.PLAYER.FLASHLIGHT_ANGLE, angle + CONFIG.PLAYER.FLASHLIGHT_ANGLE);
                this.lightShape.fill();
            }
        }

        // Auto-recover if pinned enemy dies
        if (this.isPinned) {
            if (!this.pinnedBy || !this.pinnedBy.active) {
                this.recoverFromKnockdown();
            } else {
                this.pinnedBy.setPosition(this.player.x, this.player.y);
                if (Phaser.Input.Keyboard.JustDown(this.keys.space)) this.recoverFromKnockdown();
            }
            return;
        }

        // Dodge roll (SPACE when not pinned)
        if (Phaser.Input.Keyboard.JustDown(this.keys.space) && !this.isDodging) {
            this.performDodgeRoll();
        }
        
        // Reload (R key)
        if (Phaser.Input.Keyboard.JustDown(this.keys.reload)) {
            this.startReload();
        }
        
        // Grenade (G key)
        if (Phaser.Input.Keyboard.JustDown(this.keys.grenade)) {
            this.throwGrenade();
        }
        
        // Consumables (1, 2, 3 keys)
        if (Phaser.Input.Keyboard.JustDown(this.keys.consumable1)) {
            this.useConsumable(0);
        }
        if (Phaser.Input.Keyboard.JustDown(this.keys.consumable2)) {
            this.useConsumable(1);
        }
        if (Phaser.Input.Keyboard.JustDown(this.keys.consumable3)) {
            this.useConsumable(2);
        }

        if (!this.isOpening && !this.debrisBurning && !this.isDodging) {
            this.player.setVelocity(0);
            let speed = CONFIG.PLAYER.WALK_SPEED * this.speedMultiplier;

            if ((this.cursors.shift.isDown || this.wasd.SHIFT.isDown) && this.playerStats.stamina > 0) {
                speed = CONFIG.PLAYER.SPRINT_SPEED * this.speedMultiplier;
                this.playerStats.stamina -= CONFIG.PLAYER.STAMINA_DRAIN;
            } else if (this.playerStats.stamina < this.playerStats.maxStamina) {
                this.playerStats.stamina += CONFIG.PLAYER.STAMINA_REGEN;
            }

            let vx = 0, vy = 0;
            if (this.cursors.left.isDown || this.wasd.A.isDown) vx = -1;
            else if (this.cursors.right.isDown || this.wasd.D.isDown) vx = 1;
            if (this.cursors.up.isDown || this.wasd.W.isDown) vy = -1;
            else if (this.cursors.down.isDown || this.wasd.S.isDown) vy = 1;

            if (vx !== 0 || vy !== 0) {
                const len = Math.sqrt(vx * vx + vy * vy);
                this.player.setVelocity((vx / len) * speed, (vy / len) * speed);
                // Footstep sounds
                sfx.footstep(this.time.now, speed === CONFIG.PLAYER.SPRINT_SPEED);
            }

            if (Phaser.Input.Keyboard.JustDown(this.keys.melee)) this.meleeAttack();
            if (Phaser.Input.Keyboard.JustDown(this.keys.switch)) this.switchWeapon();
            if (Phaser.Input.Keyboard.JustDown(this.keys.interact)) {
                if (this.currentLevel === 2 && this.checkDebris()) return;
                if ((this.currentLevel === 5 || this.currentLevel === 7) && this.checkSwitch()) return;
                if (this.checkDoor()) return;
                this.tryInteract();
            }
        } else if (!this.isDodging) {
            this.player.setVelocity(0);
            if (this.openTimerEvent) {
                const p = this.openTimerEvent.getProgress();
                this.uiGraphics.fillStyle(this.debrisBurning ? 0xff4500 : 0xffff00, 1);
                this.uiGraphics.fillRect(this.player.x - 20, this.player.y - 30, 40 * p, 6);
            }
        }
    }

    switchWeapon() {
        this.cancelReload(); // Cancel reload when switching
        
        const weapons = ['pistol'];
        if (this.playerStats.hasShotgun) weapons.push('shotgun');
        if (this.playerStats.hasSMG) weapons.push('smg');
        if (this.playerStats.hasCrossbow) weapons.push('crossbow');
        if (this.playerStats.hasRifle) weapons.push('rifle');
        
        if (weapons.length === 1) return;
        
        const currentIdx = weapons.indexOf(this.playerStats.currentWeapon);
        const nextIdx = (currentIdx + 1) % weapons.length;
        this.playerStats.currentWeapon = weapons[nextIdx];
        
        this.showFloatingText(this.player.x, this.player.y - 40, this.playerStats.currentWeapon.toUpperCase(), 0xffffff);
        sfx.reload();
    }

    meleeAttack() {
        if (this.isMeleeAttacking) return;
        this.isMeleeAttacking = true;
        this.cancelReload();
        sfx.melee();

        const slash = this.add.sprite(this.player.x, this.player.y, 'slash').setTint(0xffffff).setDepth(20);
        const angle = Phaser.Math.Angle.Between(this.player.x, this.player.y, this.input.activePointer.x, this.input.activePointer.y);
        slash.setRotation(angle);
        const vec = this.physics.velocityFromRotation(angle, 40);
        slash.setPosition(this.player.x + vec.x, this.player.y + vec.y);

        this.tweens.add({ targets: slash, alpha: 0, duration: 200, onComplete: () => slash.destroy() });

        this.enemies.getChildren().forEach(e => {
            if (e.active && Phaser.Math.Distance.Between(slash.x, slash.y, e.x, e.y) < CONFIG.PLAYER.MELEE_RANGE) {
                if (e.enemyType === 'boss') {
                    if (!e.isInvulnerable) e.takeDamage(CONFIG.PLAYER.MELEE_DAMAGE, 'melee');
                } else if (e.takeDamage) {
                    e.takeDamage(CONFIG.PLAYER.MELEE_DAMAGE, 'melee');
                }
            }
        });

        this.time.delayedCall(CONFIG.PLAYER.MELEE_COOLDOWN, () => { this.isMeleeAttacking = false; });
    }

    fireBullet(pointer) {
        if (this.isOpening || this.isPaused || this.isInventoryOpen || this.isReloading || this.isDodging) return;

        const weapon = this.playerStats.currentWeapon;
        const wpnConfig = CONFIG.WEAPONS[weapon.toUpperCase()];
        const currentMag = this.playerStats.magazines[weapon];
        
        // Check magazine
        if (currentMag <= 0) {
            sfx.empty();
            // Auto-reload when empty
            this.startReload();
            return;
        }
        
        // Check ammo cost
        if (weapon === 'shotgun' && currentMag < wpnConfig.AMMO_COST) {
            sfx.empty();
            this.startReload();
            return;
        }

        const now = this.time.now;
        const angle = Phaser.Math.Angle.Between(this.player.x, this.player.y, pointer.x, pointer.y);

        if (weapon === 'shotgun') {
            if (now - this.lastFired < wpnConfig.FIRE_RATE) return;

            sfx.shootShotgun();
            this.particles.spawnMuzzleFlash(this.player.x, this.player.y, angle, 1.5);
            
            let pelletsShot = 0;
            for (let i = -10; i <= 10; i += wpnConfig.SPREAD_STEP) {
                const b = this.bullets.get(this.player.x, this.player.y);
                if (b) { b.fire(this.player.x, this.player.y, pointer.x, pointer.y, i, false); pelletsShot++; }
            }
            this.playerStats.magazines[weapon] -= wpnConfig.AMMO_COST;
            this.lastFired = now;
            if (this.gameSettings.screenShake) this.cameras.main.shake(100, 0.005);
            // Track shots (count as 1 shot for shotgun, not per pellet)
            this.persistent.runShotsFired++;
            this.persistent.totalShotsFired++;
        } else if (weapon === 'smg') {
            if (now - this.lastFired < wpnConfig.FIRE_RATE) return;

            sfx.shootSMG();
            this.particles.spawnMuzzleFlash(this.player.x, this.player.y, angle, 0.6);
            
            const spread = Phaser.Math.Between(-wpnConfig.SPREAD, wpnConfig.SPREAD);
            const b = this.bullets.get(this.player.x, this.player.y);
            if (b) b.fire(this.player.x, this.player.y, pointer.x, pointer.y, spread, false);
            this.playerStats.magazines[weapon] -= wpnConfig.AMMO_COST;
            this.lastFired = now;
            // Track shots
            this.persistent.runShotsFired++;
            this.persistent.totalShotsFired++;
        } else if (weapon === 'crossbow') {
            // Crossbow - Silent, piercing, high damage
            if (now - this.lastFired < wpnConfig.FIRE_RATE) return;

            sfx.shootCrossbow();
            // No muzzle flash for crossbow - it's silent
            
            const b = this.bullets.get(this.player.x, this.player.y);
            if (b) {
                b.fire(this.player.x, this.player.y, pointer.x, pointer.y, 0, false);
                b.setTint(0x8B4513); // Brown bolt color
                b.isPiercing = true; // Mark as piercing
                b.isSilent = true;   // Mark as silent (won't aggro enemies)
                b.crossbowDamage = wpnConfig.DAMAGE; // Store crossbow's high damage
            }
            this.playerStats.magazines[weapon] -= wpnConfig.AMMO_COST;
            this.lastFired = now;
            // Track shots
            this.persistent.runShotsFired++;
            this.persistent.totalShotsFired++;
            // Auto-reload since mag size is 1
            this.startReload();
        } else if (weapon === 'rifle') {
            // Assault Rifle - Accurate, medium fire rate
            if (now - this.lastFired < wpnConfig.FIRE_RATE) return;

            sfx.shootRifle();
            this.particles.spawnMuzzleFlash(this.player.x, this.player.y, angle, 1.2);
            
            // First shot accuracy bonus when stationary
            let spread = Phaser.Math.Between(-wpnConfig.SPREAD, wpnConfig.SPREAD);
            if (wpnConfig.FIRST_SHOT_BONUS && this.player.body.velocity.length() < 10) {
                spread = 0; // Perfect accuracy when stationary
            }
            
            const b = this.bullets.get(this.player.x, this.player.y);
            if (b) {
                b.fire(this.player.x, this.player.y, pointer.x, pointer.y, spread, false);
                b.rifleDamage = wpnConfig.DAMAGE; // Store rifle's damage multiplier
            }
            this.playerStats.magazines[weapon] -= wpnConfig.AMMO_COST;
            this.lastFired = now;
            // Track shots
            this.persistent.runShotsFired++;
            this.persistent.totalShotsFired++;
        } else {
            // Pistol
            if (now - this.lastFired < wpnConfig.FIRE_RATE) return;

            sfx.shootPistol();
            this.particles.spawnMuzzleFlash(this.player.x, this.player.y, angle, 1);
            
            const b = this.bullets.get(this.player.x, this.player.y);
            if (b) b.fire(this.player.x, this.player.y, pointer.x, pointer.y, wpnConfig.SPREAD, false);
            this.playerStats.magazines[weapon] -= wpnConfig.AMMO_COST;
            this.lastFired = now;
            // Track shots
            this.persistent.runShotsFired++;
            this.persistent.totalShotsFired++;
        }
    }

    hitPlayer(damage, fromX = null, fromY = null) {
        if (this.player.alpha < 1 || this.isPinned || this.isDodging) return;

        // Track damage for stats
        this.persistent.runDamageTaken += damage;
        this.levelDamageTaken += damage;
        
        // Show hit direction indicator if we have source position
        if (fromX !== null && fromY !== null) {
            this.hitIndicators.showHit(fromX, fromY, this.player.x, this.player.y);
        }

        let mitigated = false;
        const slots = ['body', 'head', 'arms', 'feet'];

        for (let slot of slots) {
            if (this.playerStats.armor[slot] && this.playerStats.armor[slot].durability > 0) {
                this.playerStats.armor[slot].durability--;
                this.showFloatingText(this.player.x, this.player.y - 20, "BLOCKED!", 0x00ffff);
                if (this.playerStats.armor[slot].durability <= 0) {
                    this.playerStats.armor[slot] = null;
                    this.showFloatingText(this.player.x, this.player.y - 40, "ARMOR BROKE!", 0xff0000);
                }
                mitigated = true;
                break;
            }
        }

        if (!mitigated) {
            sfx.playerHurt();
            this.playerStats.hp -= damage;
            if (this.gameSettings.screenShake) {
                this.cameras.main.shake(100, 0.01);
            }
            this.player.setAlpha(0.5);
            this.player.setTint(0xff0000);
            this.time.delayedCall(100, () => { if (this.player.active) this.player.clearTint(); });
            this.time.delayedCall(CONFIG.PLAYER.INVULN_TIME, () => this.player.setAlpha(1));
        }

        if (this.playerStats.hp <= 0) {
            this.handlePlayerDeath();
        }
    }

    handlePlayerDeath() {
        if (this.isTransitioning) return;
        this.isTransitioning = true;
        this.cleanupTimerEvents();
        
        // Track death
        this.persistent.totalDeaths++;
        savePersistent(this.persistent);
        
        sfx.playerDeath();
        this.showFloatingText(400, 300, "YOU DIED", 0xff0000);
        this.physics.pause();
        
        this.time.delayedCall(CONFIG.TIMINGS.DEATH_RESTART, () => {
            this.scene.restart({ level: this.currentLevel, stats: this.checkpointStats });
        });
    }

    triggerKnockdown(leaper) {
        if (this.isPinned || this.isDodging) return;
        this.isPinned = true;
        this.pinnedBy = leaper;
        this.player.setVelocity(0);
        leaper.setVelocity(0);
        leaper.state = 'PINNING';
        this.player.setTint(0x0000ff);
        this.showFloatingText(this.player.x, this.player.y - 50, "PRESS SPACE!", 0xff0000);
        this.cancelReload();
    }

    recoverFromKnockdown() {
        this.isPinned = false;
        this.player.clearTint();
        if (this.pinnedBy && this.pinnedBy.active && this.pinnedBy.body) {
            this.pinnedBy.knockBack();
        }
        this.pinnedBy = null;
    }

    checkDebris() {
        if (this.debrisBlock && this.debrisBlock.active &&
            Phaser.Math.Distance.Between(this.player.x, this.player.y, this.debrisBlock.x, this.debrisBlock.y) < CONFIG.DISTANCES.DEBRIS) {
            if (this.hasMolotov) this.startBurningDebris();
            else this.showFloatingText(this.debrisBlock.x, this.debrisBlock.y, "Need Molotov!", 0xffffff);
            return true;
        }
        return false;
    }

    startBurningDebris() {
        this.debrisBurning = true;
        this.showFloatingText(this.debrisBlock.x, this.debrisBlock.y, "BURNING!", 0xff4500);
        this.debrisBlock.setTint(0xff4500);
        this.openTimerEvent = this.time.addEvent({
            delay: CONFIG.TIMINGS.DEBRIS_BURN,
            callback: () => {
                this.debrisBurning = false;
                if (this.debrisBlock) this.debrisBlock.destroy();
                this.showFloatingText(this.player.x, this.player.y, "CLEARED!", 0x00ff00);
            }
        });
    }

    checkSwitch() {
        // Extraction switches on boss levels (5 and 7)
        if (this.currentLevel !== 5 && this.currentLevel !== 7) return false;
        const s = this.switches.getFirstAlive();
        if (s && Phaser.Math.Distance.Between(this.player.x, this.player.y, s.x, s.y) < CONFIG.DISTANCES.INTERACT) {
            this.activateExtraction();
            s.destroy();
            return true;
        }
        return false;
    }

    checkDoor() {
        if (this.currentLevel === 7) return false; // Cemetery is extraction-only (final level)
        if (Phaser.Math.Distance.Between(this.player.x, this.player.y, this.door.x, this.door.y) < CONFIG.DISTANCES.DOOR) {
            if (this.currentLevel === 1) {
                if (this.hasKey) this.nextLevel();
                else this.showFloatingText(this.door.x, this.door.y - 40, "Need Key!", 0xffffff);
            } else if (this.currentLevel === 2) {
                this.nextLevel();
            } else if (this.currentLevel === 3) {
                if (this.hasKey) this.nextLevel();
                else this.showFloatingText(this.door.x, this.door.y - 40, "Need Key!", 0xffffff);
            } else if (this.currentLevel === 4) {
                if (this.hasKey) this.nextLevel();
                else this.showFloatingText(this.door.x, this.door.y - 40, "Need Key!", 0xffffff);
            } else if (this.currentLevel === 5) {
                // Hospital - need to defeat boss first (switch drops)
                if (this.switchDropped) {
                    this.showFloatingText(this.door.x, this.door.y - 40, "Use switch first!", 0xffffff);
                } else {
                    if (this.hasKey) this.nextLevel();
                    else this.showFloatingText(this.door.x, this.door.y - 40, "Need Key!", 0xffffff);
                }
            } else if (this.currentLevel === 6) {
                // Mall - key required
                if (this.hasKey) this.nextLevel();
                else this.showFloatingText(this.door.x, this.door.y - 40, "Need Key!", 0xffffff);
            }
            return true;
        }
        return false;
    }

    nextLevel() {
        if (this.isTransitioning) return;
        this.isTransitioning = true;
        this.cleanupTimerEvents();
        this.physics.pause();
        
        sfx.levelComplete();
        sfx.doorOpen();
        
        // Check untouchable achievement (no damage this level)
        if (this.levelDamageTaken === 0) {
            const newAchievements = checkAchievements(this.persistent, { levelCompletedNoDamage: true });
            newAchievements.forEach(a => {
                sfx.achievement();
                this.showFloatingText(400, 200, `${a.icon} ${a.name}!`, 0xffd700);
            });
        }
        
        // Unlock the next level
        if (this.playerStats.highestLevelUnlocked < this.currentLevel + 1) {
            this.playerStats.highestLevelUnlocked = this.currentLevel + 1;
        }
        this.playerStats.nextLevel = this.currentLevel + 1;
        
        savePersistent(this.persistent);
        localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.playerStats));
        
        // Show level complete choice screen
        this.showLevelCompleteChoice();
    }
    
    showLevelCompleteChoice() {
        const LEVEL_NAMES = ['', 'Street', 'Apartment', 'Rooftop', 'Sewers', 'Hospital', 'Mall', 'Cemetery'];
        const currentName = LEVEL_NAMES[this.currentLevel];
        const nextName = LEVEL_NAMES[this.currentLevel + 1] || 'Unknown';
        
        // Flag to prevent double-triggering
        this.levelChoiceMade = false;
        
        const doTransition = (toHideout) => {
            if (this.levelChoiceMade) return;
            this.levelChoiceMade = true;
            sfx.click();
            this.cameras.main.fade(CONFIG.TIMINGS.LEVEL_TRANSITION, 0, 0, 0);
            this.time.delayedCall(CONFIG.TIMINGS.LEVEL_TRANSITION, () => {
                if (toHideout) {
                    this.scene.start('HideoutScene', { stats: this.playerStats });
                } else {
                    this.scene.restart({ level: this.currentLevel + 1, stats: this.playerStats, levelDamageTaken: 0 });
                }
            });
        };
        
        // Create overlay
        const overlay = this.add.rectangle(400, 300, 800, 600, 0x000000, 0.85).setDepth(500);
        
        // Title
        const title = this.add.text(400, 180, 'LEVEL COMPLETE!', { 
            fontSize: '48px', fill: '#00ff00', fontStyle: 'bold' 
        }).setOrigin(0.5).setDepth(501);
        
        // Level transition text
        const transitionText = this.add.text(400, 250, `${currentName} -> ${nextName}`, { 
            fontSize: '24px', fill: '#ffffff' 
        }).setOrigin(0.5).setDepth(501);
        
        // Stats summary
        const statsText = this.add.text(400, 300, 
            `HP: ${this.playerStats.hp}/${this.playerStats.maxHp}  |  Ammo: ${this.playerStats.ammo}  |  Scrap: ${this.playerStats.scrap}`, 
            { fontSize: '16px', fill: '#888888' }
        ).setOrigin(0.5).setDepth(501);
        
        // Continue button
        const continueBtn = this.add.rectangle(300, 400, 200, 60, 0x008800).setInteractive().setDepth(501);
        const continueTxt = this.add.text(300, 400, 'CONTINUE', { 
            fontSize: '24px', fill: '#ffffff' 
        }).setOrigin(0.5).setDepth(502);
        
        continueBtn.on('pointerover', () => { if (!this.levelChoiceMade) continueBtn.setFillStyle(0x00aa00); });
        continueBtn.on('pointerout', () => { if (!this.levelChoiceMade) continueBtn.setFillStyle(0x008800); });
        continueBtn.on('pointerdown', () => doTransition(false));
        
        // Return to hideout button
        const hideoutBtn = this.add.rectangle(500, 400, 200, 60, 0x444488).setInteractive().setDepth(501);
        const hideoutTxt = this.add.text(500, 400, 'HIDEOUT', { 
            fontSize: '24px', fill: '#ffffff' 
        }).setOrigin(0.5).setDepth(502);
        
        hideoutBtn.on('pointerover', () => { if (!this.levelChoiceMade) hideoutBtn.setFillStyle(0x5555aa); });
        hideoutBtn.on('pointerout', () => { if (!this.levelChoiceMade) hideoutBtn.setFillStyle(0x444488); });
        hideoutBtn.on('pointerdown', () => doTransition(true));
        
        // Keyboard shortcuts - use existing keys system instead of adding new ones
        this.levelChoiceEnterHandler = () => doTransition(false);
        this.levelChoiceEscHandler = () => doTransition(true);
        
        this.input.keyboard.on('keydown-ENTER', this.levelChoiceEnterHandler);
        this.input.keyboard.on('keydown-ESC', this.levelChoiceEscHandler);
        
        // Hint text
        const hintText = this.add.text(400, 480, 'ENTER = Continue  |  ESC = Hideout', { 
            fontSize: '14px', fill: '#666666' 
        }).setOrigin(0.5).setDepth(501);
    }

    winGame() {
        if (this.isTransitioning) return;
        this.isTransitioning = true;
        this.cleanupTimerEvents();
        this.extractionActive = false;
        this.physics.pause();
        this.levelText.setText("EXTRACTED!").setAlpha(1);
        if (this.uiGraphics) this.uiGraphics.clear();
        
        sfx.levelComplete();
        sfx.success();
        
        // Track run completion
        this.persistent.runsCompleted++;
        
        // Update next level for progression (after level 5 go to 6, after level 7 reset to 1)
        if (this.currentLevel === 7) {
            this.playerStats.nextLevel = 1; // Game complete, reset
            this.playerStats.highestLevelUnlocked = 7; // All levels stay unlocked
            this.showFloatingText(400, 200, "GAME COMPLETE!", 0x00ff00);
        } else {
            this.playerStats.nextLevel = this.currentLevel + 1;
            // Unlock the next level if not already unlocked
            if (this.playerStats.highestLevelUnlocked < this.currentLevel + 1) {
                this.playerStats.highestLevelUnlocked = this.currentLevel + 1;
            }
        }
        
        // Check achievements
        const newAchievements = checkAchievements(this.persistent, {
            hasAllWeapons: this.playerStats.hasShotgun && this.playerStats.hasSMG
        });
        newAchievements.forEach(a => {
            sfx.achievement();
            this.showFloatingText(400, 250, `${a.icon} ${a.name}!`, 0xffd700);
        });
        savePersistent(this.persistent);
        
        localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(this.playerStats));
        this.time.delayedCall(CONFIG.TIMINGS.DEATH_RESTART, () => {
            this.scene.start('HideoutScene', { stats: this.playerStats });
        });
    }

    tryInteract() {
        const crates = this.crates.getChildren();
        let closest = null;
        let minDst = CONFIG.DISTANCES.INTERACT;

        crates.forEach(c => {
            const d = Phaser.Math.Distance.Between(this.player.x, this.player.y, c.x, c.y);
            if (c.active && d < minDst) { closest = c; minDst = d; }
        });
        if (closest) { this.openCrate(closest); return; }

        const skulls = this.skulls.getChildren();
        closest = null;
        minDst = CONFIG.DISTANCES.INTERACT;

        skulls.forEach(s => {
            const d = Phaser.Math.Distance.Between(this.player.x, this.player.y, s.x, s.y);
            if (s.active && d < minDst) { closest = s; minDst = d; }
        });
        if (closest) {
            const itemID = closest.getData('lootID');
            closest.destroy();
            this.applyLoot(itemID);
        }
    }

    openCrate(crate) {
        const itemID = crate.getData('lootID');
        this.isOpening = true;
        this.openTimerEvent = this.time.addEvent({
            delay: CONFIG.TIMINGS.CRATE_OPEN,
            callback: () => {
                this.isOpening = false;
                sfx.crateOpen();
                crate.destroy();
                this.applyLoot(itemID);
            }
        });
    }

    applyLoot(id) {
        let txt = "", col = 0xffffff;

        switch (id) {
            case 'meds':
                sfx.lootHealth();
                this.playerStats.hp = Math.min(this.playerStats.hp + 5, this.playerStats.maxHp);
                txt = "+5 HP"; col = 0xff0000;
                break;
            case 'ammo':
                sfx.lootAmmo();
                this.playerStats.ammo += 5;
                txt = "+5 Ammo"; col = 0xffff00;
                break;
            case 'key':
                sfx.lootKey();
                this.hasKey = true;
                txt = "KEY FOUND!"; col = 0xffd700;
                break;
            case 'flashlight':
                sfx.lootWeapon();
                this.playerStats.hasFlashlight = true;
                txt = "FLASHLIGHT!"; col = 0xffffff;
                break;
            case 'molotov':
                sfx.loot();
                this.hasMolotov = true;
                txt = "MOLOTOV!"; col = 0xff4500;
                break;
            case 'shotgun':
                sfx.lootWeapon();
                this.playerStats.hasShotgun = true;
                txt = "SHOTGUN!"; col = 0xff00ff;
                break;
            case 'smg':
                sfx.lootWeapon();
                this.playerStats.hasSMG = true;
                txt = "SMG!"; col = 0x00ffff;
                break;
            case 'crossbow':
                sfx.lootWeapon();
                this.playerStats.hasCrossbow = true;
                txt = "CROSSBOW!"; col = 0x8B4513;
                break;
            case 'rifle':
                sfx.lootWeapon();
                this.playerStats.hasRifle = true;
                txt = "ASSAULT RIFLE!"; col = 0x556B2F;
                break;
            case 'scrap':
                sfx.loot();
                this.playerStats.scrap += 5;
                this.persistent.totalScrapCollected += 5;
                // Check scavenger achievement
                const scrapAchievements = checkAchievements(this.persistent, {});
                scrapAchievements.forEach(a => {
                    sfx.achievement();
                    this.showFloatingText(400, 200, `${a.icon} ${a.name}!`, 0xffd700);
                });
                savePersistent(this.persistent);
                txt = "+5 SCRAP"; col = 0xaaaaaa;
                break;
            case 'plug':
                sfx.lootKey();
                this.playerStats.hideout.hasSparkPlug = true;
                txt = "SPARK PLUG!"; col = 0x00ffff;
                break;
            case 'helmet':
                sfx.loot();
                this.playerStats.armor.head = { name: 'HELMET', durability: 3, maxDurability: 3 };
                txt = "HELMET EQUIPPED"; col = 0x00ff00;
                break;
            case 'vest':
                sfx.loot();
                this.playerStats.armor.body = { name: 'VEST', durability: 5, maxDurability: 5 };
                txt = "VEST EQUIPPED"; col = 0x00ff00;
                break;
            case 'grenade':
                if (this.playerStats.grenades < CONFIG.GRENADE.MAX_CARRY) {
                    sfx.loot();
                    this.playerStats.grenades++;
                    txt = "+1 GRENADE"; col = 0x556B2F;
                } else {
                    sfx.error();
                    txt = "GRENADES FULL"; col = 0x888888;
                }
                break;
        }

        this.showFloatingText(this.player.x, this.player.y - 30, txt, col);
    }

    showFloatingText(x, y, msg, color) {
        this.floatingText.spawn(x, y, msg, color);
    }

    updateBossBar(hp, max) {
        this.bossBar.clear();
        this.bossBar.fillStyle(0x000000, 1);
        this.bossBar.fillRect(200, 50, 400, 20);
        this.bossBar.fillStyle(0xff0000, 1);
        this.bossBar.fillRect(202, 52, 396 * (hp / max), 16);
    }

    drawUI() {
        if (!this.uiGraphics) return;
        const ui = CONFIG.UI;
        this.uiGraphics.clear();

        // HP Bar
        this.uiGraphics.fillStyle(0x000000, 0.5);
        this.uiGraphics.fillRect(10, 10, ui.HP_BAR_WIDTH + 4, ui.HP_BAR_HEIGHT + 4);
        this.uiGraphics.fillStyle(0xff0000, 1);
        this.uiGraphics.fillRect(12, 12, ui.HP_BAR_WIDTH * (this.playerStats.hp / this.playerStats.maxHp), ui.HP_BAR_HEIGHT);

        // Stamina Bar
        this.uiGraphics.fillStyle(0x000000, 0.5);
        this.uiGraphics.fillRect(10, 40, ui.STAMINA_BAR_WIDTH + 4, ui.STAMINA_BAR_HEIGHT + 4);
        this.uiGraphics.fillStyle(0x0088ff, 1);
        this.uiGraphics.fillRect(12, 42, ui.STAMINA_BAR_WIDTH * (this.playerStats.stamina / this.playerStats.maxStamina), ui.STAMINA_BAR_HEIGHT);

        // Ammo display with magazine
        const weapon = this.playerStats.currentWeapon;
        const mag = this.playerStats.magazines[weapon];
        const maxMag = CONFIG.WEAPONS[weapon.toUpperCase()].MAG_SIZE;
        
        let reloadText = this.isReloading ? " [RELOADING]" : "";
        let timerText = this.extractionActive ? ` | BEACON: ${this.extractionTimer}s` : "";
        if (this.extractionActive) this.levelText.setText(this.extractionTimer).setAlpha(1).setTint(0xff0000);
        
        // Main status line with all currencies
        this.uiText.setText(`${weapon.toUpperCase()}: ${mag}/${maxMag} (${this.playerStats.ammo})${reloadText} | GREN: ${this.playerStats.grenades} | üîß${this.playerStats.scrap} üí∞${this.playerStats.credits} ‚öôÔ∏è${this.playerStats.materials}${timerText}`);

        // Icons
        let iconX = 300;
        if (this.hasKey) {
            this.uiGraphics.fillStyle(0xFFD700, 1);
            this.uiGraphics.fillCircle(iconX, 22, ui.ICON_RADIUS);
            iconX += ui.ICON_SPACING;
        }
        if (this.playerStats.hasFlashlight) {
            this.uiGraphics.fillStyle(0xffffff, 1);
            this.uiGraphics.fillCircle(iconX, 22, ui.ICON_RADIUS);
            iconX += ui.ICON_SPACING;
        }
        if (this.hasMolotov) {
            this.uiGraphics.fillStyle(0xff4500, 1);
            this.uiGraphics.fillCircle(iconX, 22, ui.ICON_RADIUS);
            iconX += ui.ICON_SPACING;
        }
        if (this.playerStats.hideout.hasSparkPlug) {
            this.uiGraphics.fillStyle(0x00ffff, 1);
            this.uiGraphics.fillCircle(iconX, 22, ui.ICON_RADIUS);
            iconX += ui.ICON_SPACING;
        }
        if (this.playerStats.hideout.armory.hasNVG) {
            this.uiGraphics.fillStyle(0x00ff00, 1);
            this.uiGraphics.fillCircle(iconX, 22, ui.ICON_RADIUS);
            iconX += ui.ICON_SPACING;
        }
        if (this.playerStats.grenades > 0) {
            this.uiGraphics.fillStyle(0x556B2F, 1);
            this.uiGraphics.fillCircle(iconX, 22, ui.ICON_RADIUS);
            // Show count
            this.uiGraphics.fillStyle(0xffffff, 1);
        }
        
        // Dodge cooldown indicator
        const dodgeCooldownRemaining = CONFIG.PLAYER.DODGE_COOLDOWN - (this.time.now - this.lastDodgeTime);
        if (dodgeCooldownRemaining > 0) {
            const cooldownPercent = dodgeCooldownRemaining / CONFIG.PLAYER.DODGE_COOLDOWN;
            this.uiGraphics.fillStyle(0x444444, 0.8);
            this.uiGraphics.fillRect(10, 56, 50, 8);
            this.uiGraphics.fillStyle(0x00ffff, 1);
            this.uiGraphics.fillRect(10, 56, 50 * (1 - cooldownPercent), 8);
        }
        
        // Consumable slots (bottom-left)
        const slotSize = 35;
        const slotSpacing = 5;
        const slotY = 560;
        // Defensive check for consumables array
        if (!this.playerStats.consumables || !Array.isArray(this.playerStats.consumables)) {
            this.playerStats.consumables = [null, null, null];
        }
        
        for (let i = 0; i < 3; i++) {
            const slotX = 15 + i * (slotSize + slotSpacing);
            const consumable = this.playerStats.consumables[i];
            
            // Slot background
            this.uiGraphics.fillStyle(0x222222, 0.8);
            this.uiGraphics.fillRect(slotX, slotY, slotSize, slotSize);
            this.uiGraphics.lineStyle(2, consumable ? 0x00ff00 : 0x444444);
            this.uiGraphics.strokeRect(slotX, slotY, slotSize, slotSize);
            
            // Slot number
            if (!this.consumableSlotTexts) {
                this.consumableSlotTexts = [];
                for (let j = 0; j < 3; j++) {
                    const numText = this.add.text(20 + j * (slotSize + slotSpacing), slotY + slotSize + 2, `${j + 1}`, 
                        { fontSize: '12px', fill: '#888' }).setDepth(101);
                    this.consumableSlotTexts.push(numText);
                    
                    const iconText = this.add.text(20 + j * (slotSize + slotSpacing) + slotSize/2 - 8, slotY + 8, '', 
                        { fontSize: '18px' }).setDepth(101);
                    this.consumableSlotTexts.push(iconText);
                }
            }
            
            // Update slot icon
            const iconTextIdx = i * 2 + 1;
            if (this.consumableSlotTexts && this.consumableSlotTexts[iconTextIdx]) {
                if (consumable && CONFIG.CONSUMABLES[consumable]) {
                    this.consumableSlotTexts[iconTextIdx].setText(CONFIG.CONSUMABLES[consumable].icon);
                } else {
                    this.consumableSlotTexts[iconTextIdx].setText('');
                }
            }
        }
    }
    
    shutdown() {
        // Clean up keyboard handlers from level complete choice
        if (this.levelChoiceEnterHandler) {
            this.input.keyboard.off('keydown-ENTER', this.levelChoiceEnterHandler);
            this.levelChoiceEnterHandler = null;
        }
        if (this.levelChoiceEscHandler) {
            this.input.keyboard.off('keydown-ESC', this.levelChoiceEscHandler);
            this.levelChoiceEscHandler = null;
        }
        
        // Clean up timer events
        this.cleanupTimerEvents();
        
        // Clear consumable slot texts reference
        this.consumableSlotTexts = null;
    }
}

// =============================================================================
// GAME CONFIGURATION
// =============================================================================
const config = {
    type: Phaser.AUTO,
    width: 800,
    height: 600,
    backgroundColor: '#000000',
    parent: 'game-container',
    physics: {
        default: 'arcade',
        arcade: { gravity: { y: 0 } }
    },
    scene: [MainMenuScene, GameScene, HideoutScene],
    scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH
    }
};

const game = new Phaser.Game(config);
</script>
</body>
</html>
