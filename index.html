<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Zombies - Build 9.2 (Mobile Controls)</title>
    <style>
        body { margin: 0; padding: 0; background-color: #000000; overflow: hidden; touch-action: none; }
        canvas { display: block; margin: 0 auto; }
        #instructions {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            color: #444; font-family: sans-serif; pointer-events: none; opacity: 0.5;
            width: 100%; text-align: center; font-size: 12px;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>
<body>
<div id="instructions">PC: WASD Move | Mouse Aim | F Interact | Q Switch | N NVG | TAB Inv<br>MOBILE: Use On-Screen Controls</div>
<script>

// --- CONSTANTS ---
const SAVE_KEY = 'zombie_save_v9';
const DEFAULT_STATS = { 
    hp: 10, maxHp: 10, stamina: 100, maxStamina: 100, ammo: 10, scrap: 0,
    hasFlashlight: false, hasShotgun: false, currentWeapon: 'pistol',
    armor: { head: null, body: null, arms: null, feet: null },
    hideout: { 
        restAreaLvl: 0, 
        generatorLvl: 0, 
        hasSparkPlug: false,
        armory: { crafting: null, hasNVG: false } 
    }
};

// --- AUDIO MANAGER ---
class SoundManager {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.3; 
        this.masterGain.connect(this.ctx.destination);
    }
    resume() { if (this.ctx.state === 'suspended') this.ctx.resume(); }
    playTone(freq, type, duration, vol = 1) {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type; osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain); gain.connect(this.masterGain);
        osc.start(); osc.stop(this.ctx.currentTime + duration);
    }
    playNoise(duration, vol = 1) {
        const bufferSize = this.ctx.sampleRate * duration;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        noise.connect(gain); gain.connect(this.masterGain); noise.start();
    }
    shootPistol() { this.playTone(600, 'sawtooth', 0.1, 0.5); this.playNoise(0.1, 0.3); }
    shootShotgun() { this.playTone(200, 'square', 0.3, 0.6); this.playNoise(0.3, 0.6); }
    enemyHit() { this.playTone(100, 'sawtooth', 0.1, 0.5); }
    playerHurt() { this.playTone(50, 'sawtooth', 0.3, 0.8); }
    click() { this.playTone(800, 'sine', 0.05, 0.3); }
    loot() { this.playTone(1200, 'square', 0.1, 0.2); this.playTone(1600, 'square', 0.1, 0.2); }
    toggleNVG() { this.playTone(2000, 'sine', 0.2, 0.1); }
    reload() { this.playTone(400, 'triangle', 0.2, 0.4); }
}
const sfx = new SoundManager();

// --- 1. MAIN MENU SCENE ---
class MainMenuScene extends Phaser.Scene {
    constructor() { super('MainMenuScene'); }
    create() {
        this.input.on('pointerdown', () => sfx.resume());
        this.add.rectangle(400, 300, 800, 600, 0x111111);
        this.add.grid(400, 300, 800, 600, 64, 64, 0x222222).setAlpha(0.2);
        this.add.text(400, 100, "ZOMBIE EXTRACTION", { fontSize: '64px', fill: '#00ff00', fontStyle: 'bold' }).setOrigin(0.5);
        this.add.text(400, 160, "BUILD 9.2 (MOBILE CONTROLS)", { fontSize: '24px', fill: '#555' }).setOrigin(0.5);

        this.createButton(400, 250, "NEW RUN", 0x880000, () => {
            if(confirm("Start a new run?")) {
                localStorage.removeItem(SAVE_KEY);
                this.scene.start('GameScene', { level: 1, stats: JSON.parse(JSON.stringify(DEFAULT_STATS)) });
            }
        });

        this.createButton(400, 320, "CONTINUE", 0x004488, () => {
            let saved = localStorage.getItem(SAVE_KEY);
            if (saved) {
                this.scene.start('HideoutScene', { stats: JSON.parse(saved) });
            } else { alert("No save found!"); }
        });

        this.createButton(400, 420, "EXPORT SAVE", 0x444444, () => {
            let saved = localStorage.getItem(SAVE_KEY);
            if (!saved) return;
            const blob = new Blob([saved], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = `zombie_save.json`;
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
        });

        this.createButton(400, 490, "IMPORT SAVE", 0x444444, () => {
            const input = document.createElement('input');
            input.type = 'file'; input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const json = JSON.parse(event.target.result);
                        if (json.hp !== undefined) {
                            localStorage.setItem(SAVE_KEY, JSON.stringify(json));
                            alert("Imported!");
                        }
                    } catch (err) {}
                };
                reader.readAsText(file);
            };
            input.click();
        });
        
        // Cheat
        this.add.text(10, 570, "[ CHEAT CODE ]", { fontSize: '16px', fill: '#444' }).setInteractive().on('pointerdown', () => {
            sfx.click();
            if (prompt("CODE:") === 'god mode') {
                const god = JSON.parse(JSON.stringify(DEFAULT_STATS));
                god.hp=20; god.maxHp=20; god.ammo=999; god.scrap=999; god.hasShotgun=true; god.hasFlashlight=true; god.hideout.armory.hasNVG=true;
                localStorage.setItem(SAVE_KEY, JSON.stringify(god));
                this.scene.start('HideoutScene', { stats: god });
            }
        });
    }
    createButton(x, y, text, color, callback) {
        let btn = this.add.rectangle(x, y, 350, 50, color).setInteractive();
        this.add.text(x, y, text, { fontSize: '24px', fill: '#fff' }).setOrigin(0.5);
        btn.on('pointerdown', () => { sfx.click(); callback(); });
    }
}

// --- 2. GAME CLASSES ---
class Bullet extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y) { super(scene, x, y, 'bullet'); }
    fire(x, y, targetX, targetY, spreadAngle = 0, isEnemy = false) {
        this.body.reset(x, y); this.body.enable = true; 
        this.setActive(true); this.setVisible(true);
        this.hasHit = false; this.isEnemyBullet = isEnemy; 
        this.setTint(isEnemy ? 0xff0000 : 0xffff00);
        if(!isEnemy) { /* Player sound handled by input */ } else { sfx.shootPistol(); }
        let baseAngle = Phaser.Math.Angle.Between(x, y, targetX, targetY);
        let finalAngle = baseAngle + Phaser.Math.DegToRad(spreadAngle);
        this.scene.physics.velocityFromRotation(finalAngle, 500, this.body.velocity);
        this.setRotation(finalAngle);
    }
    preUpdate(time, delta) {
        super.preUpdate(time, delta);
        if (this.y < -50 || this.y > 650 || this.x < -50 || this.x > 850) { this.destroy(); }
    }
}

class Enemy extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y, target, type) {
        super(scene, x, y, type === 'leaper' ? 'leaper' : (type === 'bandit' ? 'bandit' : 'zombie'));
        scene.add.existing(this); scene.physics.add.existing(this);
        this.target = target; this.enemyType = type; this.canTakeDamage = true; this.lastFired = 0;
        this.healthBar = scene.add.graphics().setDepth(100).setVisible(false);
        if (type === 'boss') { this.setScale(3); this.setTint(0xff0000); this.hp=5; this.maxHp=5; this.speed=85; this.damage=10; }
        else if (type === 'leaper') { this.hp=1; this.maxHp=1; this.speed=110; this.damage=2; this.state='CHASE'; this.leapTimer=0; }
        else if (type === 'bandit') { this.hp=3; this.maxHp=3; this.speed=90; this.damage=1; this.ammo=10; this.state='CHASE'; }
        else { this.hp=2; this.maxHp=2; this.speed=60; this.damage=2; }
    }
    takeDamage(amount) {
        if (!this.active || !this.canTakeDamage) return;
        this.hp -= amount; sfx.enemyHit(); this.setTint(0xffffff);
        this.scene.time.delayedCall(50, () => { if (this.active) this.clearTint(); });
        this.updateHealthBar();
        if (this.enemyType === 'boss') { this.scene.updateBossBar(this.hp, this.maxHp); this.canTakeDamage = false; this.scene.time.delayedCall(500, ()=>{if(this.active)this.canTakeDamage=true;}); }
        if (this.hp <= 0) {
            if (this.enemyType === 'boss') this.scene.spawnSwitch(this.x, this.y);
            this.scene.spawnLootSkull(this.x, this.y, this.enemyType);
            this.destroy();
        }
    }
    updateHealthBar() {
        if (this.hp <= 0) { this.healthBar.setVisible(false); return; }
        this.healthBar.setVisible(true); this.healthBar.clear();
        this.healthBar.fillStyle(0xff0000); this.healthBar.fillRect(this.x-20, this.y-40, 40, 6);
        this.healthBar.fillStyle(0x00ff00); this.healthBar.fillRect(this.x-20, this.y-40, 40 * (this.hp / this.maxHp), 6);
    }
    knockBack() {
        if(this.enemyType==='leaper'){this.state='COOLDOWN'; this.leapTimer=2000;}
        const angle = Phaser.Math.Angle.Between(this.target.x, this.target.y, this.x, this.y);
        this.scene.physics.velocityFromRotation(angle, this.enemyType==='leaper'?250:100, this.body.velocity);
    }
    update(time, delta) {
        if (!this.active) return;
        if (this.healthBar) this.healthBar.setPosition(0,0); // Handled in draw
        
        if (this.enemyType === 'bandit') {
            const dist = Phaser.Math.Distance.Between(this.x, this.y, this.target.x, this.target.y);
            if (this.ammo > 0) {
                if (dist < 350) {
                    this.setVelocity(0);
                    if (time - this.lastFired > 2000) {
                        const b = this.scene.bullets.get(this.x, this.y);
                        if(b) { b.fire(this.x, this.y, this.target.x, this.target.y, Phaser.Math.Between(-5,5), true); this.ammo--; this.lastFired=time; }
                    }
                } else { this.scene.physics.moveToObject(this, this.target, this.speed); }
            } else { this.scene.physics.moveToObject(this, this.target, 120); }
            return;
        }
        if (this.enemyType === 'leaper') {
            const dist = Phaser.Math.Distance.Between(this.x, this.y, this.target.x, this.target.y);
            if(this.state==='CHASE'){ this.scene.physics.moveToObject(this, this.target, 110); if(dist<180){this.state='PREPARE'; this.setVelocity(0); this.setTint(0xffaa00); this.leapTimer=500;} }
            else if(this.state==='PREPARE'){ this.leapTimer-=delta; if(this.leapTimer<=0){this.state='LEAP'; this.clearTint(); this.scene.physics.moveToObject(this, this.target, 450); this.leapTimer=600;} }
            else if(this.state==='LEAP'){ this.leapTimer-=delta; if(this.leapTimer<=0){this.state='COOLDOWN'; this.setVelocity(0); this.leapTimer=1500;} }
            else if(this.state==='COOLDOWN'){ this.leapTimer-=delta; if(this.leapTimer<=0) this.state='CHASE'; }
            return;
        }
        this.scene.physics.moveToObject(this, this.target, this.speed);
    }
    destroy(fromScene) { if (this.healthBar) this.healthBar.destroy(); super.destroy(fromScene); }
}

// --- 3. HIDEOUT SCENE ---
class HideoutScene extends Phaser.Scene {
    constructor() { super('HideoutScene'); }
    create(data) {
        this.stats = data.stats;
        localStorage.setItem(SAVE_KEY, JSON.stringify(this.stats));
        this.add.rectangle(400, 300, 800, 600, 0x1a1a1a);
        this.add.grid(400, 300, 800, 600, 32, 32, 0x222222).setAlpha(0.5);
        this.add.text(40, 40, "THE HIDEOUT", { fontSize: '48px', fill: '#00ff00', fontStyle: 'bold' });
        this.statText = this.add.text(40, 100, "", { fontSize: '18px', fill: '#cccccc' });
        this.updateStatText();
        
        // Cards
        this.createUpgradeCard(40, 200, "REST AREA", () => `LVL: ${this.stats.hideout.restAreaLvl}`, () => {
            if(this.stats.scrap >= (this.stats.hideout.restAreaLvl+1)*5) {
                this.stats.scrap -= (this.stats.hideout.restAreaLvl+1)*5; this.stats.hideout.restAreaLvl++;
                if(this.stats.hideout.restAreaLvl>0) this.stats.hp=this.stats.maxHp;
                if(this.stats.hideout.restAreaLvl>1) this.stats.maxHp+=2;
                this.updateStatText(); return true;
            } return false;
        }, () => `UPGRADE (${(this.stats.hideout.restAreaLvl+1)*5} S)`);

        this.createUpgradeCard(270, 200, "GENERATOR", () => this.stats.hideout.generatorLvl===0?"Offline":"Online", () => {
            if(this.stats.hideout.generatorLvl===0 && this.stats.scrap>=10 && this.stats.hideout.hasSparkPlug) {
                this.stats.scrap-=10; this.stats.hideout.generatorLvl=1; this.stats.hideout.hasSparkPlug=false; this.stats.hasFlashlight=true;
                this.updateStatText(); return true;
            } return false;
        }, () => this.stats.hideout.generatorLvl===0?"BUILD (10 S + PLUG)":"MAX");

        // Armory Logic
        const ax = 500, ay = 200;
        this.add.rectangle(ax+100, ay+75, 220, 160, 0x333333).setStrokeStyle(2, 0x555555);
        this.add.text(ax+10, ay+10, "ARMORY", {fontSize:'20px', fill:'#ff00ff'});
        this.armoryDesc = this.add.text(ax+10, ay+40, "", {fontSize:'14px', fill:'#aaa'});
        this.armoryBtn = this.add.rectangle(ax+100, ay+130, 200, 30, 0x555555).setInteractive();
        this.armoryBtnText = this.add.text(ax+100, ay+130, "", {fontSize:'14px', fill:'#fff'}).setOrigin(0.5);
        this.updateArmoryUI();
        
        this.armoryBtn.on('pointerdown', () => {
            sfx.click();
            if(this.stats.hideout.armory.hasNVG) return;
            if(this.stats.hideout.armory.crafting && Date.now() >= this.stats.hideout.armory.crafting.finishTime) {
                this.stats.hideout.armory.hasNVG=true; this.stats.hideout.armory.crafting=null; this.updateArmoryUI();
            } else if(!this.stats.hideout.armory.crafting && this.stats.scrap >= 3) {
                this.stats.scrap-=3; this.stats.hideout.armory.crafting={finishTime: Date.now()+90000}; this.updateStatText(); this.updateArmoryUI();
            }
        });

        // Deploy
        this.add.rectangle(650, 500, 200, 60, 0x008800).setInteractive().on('pointerdown', () => {
            sfx.click();
            if(this.stats.hideout.restAreaLvl>0) this.stats.hp = Math.min(this.stats.hp + (this.stats.hideout.restAreaLvl>=2?this.stats.maxHp:5), this.stats.maxHp);
            this.scene.start('GameScene', {level:1, stats:this.stats});
        });
        
        // Menu
        this.add.rectangle(100, 550, 150, 40, 0x444444).setInteractive().on('pointerdown', () => {
            sfx.click(); this.scene.start('MainMenuScene');
        });
    }
    update() {
        if(this.stats.hideout.armory.crafting && !this.stats.hideout.armory.hasNVG) {
            let rem = this.stats.hideout.armory.crafting.finishTime - Date.now();
            if(rem <= 0) { this.armoryDesc.setText("FINISHED!"); this.armoryBtnText.setText("CLAIM NVG"); }
            else { this.armoryDesc.setText(`Crafting... ${Math.ceil(rem/1000)}s`); this.armoryBtnText.setText("WAIT"); }
        }
    }
    updateArmoryUI() {
        if(this.stats.hideout.armory.hasNVG) { this.armoryDesc.setText("NVG UNLOCKED"); this.armoryBtnText.setText("EQUIPPED"); }
        else if(!this.stats.hideout.armory.crafting) { this.armoryDesc.setText("Craft NVG (3 Scrap)"); this.armoryBtnText.setText("CRAFT"); }
    }
    updateStatText() { this.statText.setText(`HP:${this.stats.hp}/${this.stats.maxHp} AMMO:${this.stats.ammo} SCRAP:${this.stats.scrap}`); }
    createUpgradeCard(x, y, title, descFn, actionFn, costFn) {
        this.add.rectangle(x+100, y+75, 220, 160, 0x333333).setStrokeStyle(2, 0x555555);
        this.add.text(x+10, y+10, title, {fontSize:'20px', fill:'#ffff00'});
        let d = this.add.text(x+10, y+40, descFn(), {fontSize:'14px', fill:'#aaa'});
        let b = this.add.rectangle(x+100, y+130, 200, 30, 0x555555).setInteractive();
        let bt = this.add.text(x+100, y+130, costFn(), {fontSize:'14px', fill:'#fff'}).setOrigin(0.5);
        b.on('pointerdown', () => { if(actionFn()) { sfx.click(); d.setText(descFn()); bt.setText(costFn()); } });
    }
}

// --- 4. GAME SCENE (WITH MOBILE CONTROLS) ---
class GameScene extends Phaser.Scene {
    constructor() { super('GameScene'); }
    preload() {
        const g = this.make.graphics({x:0, y:0, add:false});
        const gen = (c, w, h, k) => { g.clear(); g.fillStyle(c,1); g.fillRect(0,0,w,h); g.generateTexture(k,w,h); };
        gen(0x00ff00,32,32,'player'); gen(0x8B4513,32,32,'crate'); gen(0x663399,32,32,'zombie');
        gen(0xFF4500,32,32,'leaper'); gen(0x0000FF,32,32,'bandit'); gen(0xffff00,8,8,'bullet');
        gen(0xFFD700,40,60,'door'); gen(0x555555,32,32,'wall'); gen(0x333333,60,60,'debris'); gen(0x00ff00,30,30,'switch');
        
        g.clear(); g.fillStyle(0xEAEAEA, 1); g.fillCircle(16,14,11); g.fillRect(10,20,12,8); g.fillStyle(0,1); g.fillCircle(12,14,3.5); g.fillCircle(20,14,3.5); g.generateTexture('skull',32,32);
        
        this.input.addPointer(2); // Enable Multi-Touch
    }
    create(data) {
        this.currentLevel = data.level || 1;
        this.playerStats = data.stats || JSON.parse(JSON.stringify(DEFAULT_STATS));
        this.checkpointStats = JSON.parse(JSON.stringify(this.playerStats));
        this.hasKey = false; this.hasMolotov = false; this.isPaused = false; this.isInventoryOpen = false; this.nvgOn = false;
        this.extractionTimer = 15; this.extractionActive = false; this.mobileInput = { x: 0, y: 0 };

        // Groups
        this.bullets = this.physics.add.group({ classType: Bullet, runChildUpdate: true });
        this.enemies = this.add.group();
        this.pickups = this.physics.add.staticGroup();
        this.crates = this.physics.add.staticGroup();
        this.walls = this.physics.add.staticGroup();
        this.debris = this.physics.add.staticGroup();
        this.skulls = this.physics.add.staticGroup();
        this.switches = this.physics.add.staticGroup();

        // Level Setup
        this.add.tileSprite(400, 300, 800, 600, this.currentLevel===1?'floor_grass':(this.currentLevel===2?'floor_apt':'floor_roof')); // Placeholder texture handling
        if(this.currentLevel===1) {
            this.door = this.physics.add.staticSprite(400, 50, 'door');
            this.walls.create(200, 200, 'wall').setScale(1, 4).refreshBody();
            this.walls.create(600, 200, 'wall').setScale(1, 4).refreshBody();
            this.spawnEnemy('walker', 100, 300); this.spawnEnemy('bandit', 700, 300); this.spawnEnemy('leaper', 200, 200);
            this.spawnCrates(['key','flashlight','shotgun','ammo','scrap']);
        } else if(this.currentLevel===2) {
            this.door = this.physics.add.staticSprite(400, 50, 'door').setTint(0x0000ff);
            this.debrisBlock = this.debris.create(400, 100, 'debris');
            this.walls.create(250, 300, 'wall').setScale(1, 15).refreshBody();
            this.walls.create(550, 300, 'wall').setScale(1, 15).refreshBody();
            this.spawnEnemy('bandit', 100, 100); this.spawnEnemy('bandit', 700, 100); this.spawnEnemy('leaper', 400, 450);
            this.spawnCrates(['molotov','ammo','meds','scrap','plug']);
        } else {
            this.spawnEnemy('boss', 400, 100); this.spawnEnemy('bandit', 100, 500); this.spawnEnemy('bandit', 700, 500);
            this.spawnCrates(['ammo','meds','scrap']);
        }

        this.player = this.physics.add.sprite(400, 550, 'player').setCollideWorldBounds(true).setDepth(10);
        
        // Collisions
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.player, this.crates);
        this.physics.add.collider(this.player, this.debris);
        this.physics.add.collider(this.enemies, this.walls);
        this.physics.add.collider(this.enemies, this.crates);
        this.physics.add.collider(this.bullets, this.walls, (b) => b.destroy());
        this.physics.add.collider(this.bullets, this.crates, (b) => b.destroy());
        this.physics.add.overlap(this.bullets, this.enemies, (b, e) => {
            if(b.active && e.active && !b.isEnemyBullet) { b.destroy(); e.takeDamage(1); }
        });
        this.physics.add.overlap(this.bullets, this.player, (p, b) => {
            if(b.active && b.isEnemyBullet) { b.destroy(); this.hitPlayer(1); }
        });
        this.physics.add.overlap(this.player, this.enemies, (p, e) => {
            if(!e.active) return;
            if(e.enemyType==='leaper' && e.state==='LEAP') this.triggerKnockdown(e);
            else if(e.enemyType!=='bandit') this.hitPlayer(e.damage);
        });
        
        // Input
        this.cursors = this.input.keyboard.createCursorKeys();
        this.keys = this.input.keyboard.addKeys({ interact:70, space:32, esc:27, switch:81, inv: 73, tab: 9, nvg: 78 });
        
        // Lighting
        this.lightShape = this.make.graphics({ x: 0, y: 0, add: false });
        this.darkness = this.add.rectangle(400, 300, 800, 600, 0x000000, 0.95).setDepth(90);
        this.darkness.setMask(this.lightShape.createGeometryMask().setInvertAlpha(true));
        this.nvgLayer = this.add.rectangle(400, 300, 800, 600, 0x00ff00, 0.2).setDepth(95).setVisible(false);
        
        // UI
        this.createMobileControls();
        this.createInventoryUI();
        this.uiText = this.add.text(10, 10, '', { font: '16px Arial', fill: '#fff' }).setDepth(100);
        this.levelText = this.add.text(400, 300, `LEVEL ${this.currentLevel}`, {fontSize:'64px', fill:'#fff'}).setOrigin(0.5).setDepth(100).setAlpha(0);
        this.tweens.add({targets:this.levelText, alpha:1, yoyo:true, duration:2000});
        this.bossBar = this.add.graphics().setDepth(100);
    }

    createMobileControls() {
        const w = 800, h = 600;
        // Joystick (Left)
        this.joyBase = this.add.circle(100, 500, 60, 0x333333).setAlpha(0.5).setDepth(200).setInteractive();
        this.joyStick = this.add.circle(100, 500, 30, 0x888888).setAlpha(0.8).setDepth(200);
        this.input.setDraggable(this.joyBase);
        this.input.on('drag', (pointer, obj, dragX, dragY) => {
            if(obj !== this.joyBase) return;
            const dist = Phaser.Math.Distance.Between(100, 500, dragX, dragY);
            const angle = Phaser.Math.Angle.Between(100, 500, dragX, dragY);
            const clampDist = Math.min(dist, 60);
            this.joyStick.x = 100 + Math.cos(angle) * clampDist;
            this.joyStick.y = 500 + Math.sin(angle) * clampDist;
            this.mobileInput.x = (this.joyStick.x - 100) / 60;
            this.mobileInput.y = (this.joyStick.y - 500) / 60;
        });
        this.input.on('dragend', (pointer, obj) => {
            if(obj === this.joyBase) { this.joyStick.setPosition(100, 500); this.mobileInput = {x:0, y:0}; }
        });

        // Buttons (Right)
        const makeBtn = (x, y, txt, col, fn) => {
            let b = this.add.circle(x, y, 30, col).setAlpha(0.6).setDepth(200).setInteractive();
            this.add.text(x, y, txt, {fontSize:'16px'}).setOrigin(0.5).setDepth(201);
            b.on('pointerdown', () => { sfx.click(); fn(); });
        };
        
        makeBtn(720, 520, "FIRE", 0xff0000, () => this.fireBullet(this.input.activePointer)); // Fire Center
        makeBtn(650, 520, "INT", 0x0000ff, () => this.tryInteract()); // Interact Left
        makeBtn(790, 450, "SW", 0xaaaaaa, () => this.switchWeapon()); // Switch Top Right
        makeBtn(720, 450, "NVG", 0x00ff00, () => this.toggleNVG()); // NVG Top
        makeBtn(750, 30, "INV", 0x555555, () => this.toggleInventory()); // Inv Top Right Corner
    }

    createInventoryUI() {
        this.invContainer = this.add.container(400, 300).setDepth(300).setVisible(false);
        this.invContainer.add(this.add.rectangle(0,0,600,400,0x111111,0.9).setStrokeStyle(4,0x444444));
        this.invText = this.add.text(-280,-180,"INVENTORY", {fontSize:'24px'});
        this.invContainer.add(this.invText);
    }
    toggleInventory() {
        this.isInventoryOpen = !this.isInventoryOpen;
        this.invContainer.setVisible(this.isInventoryOpen);
        if(this.isInventoryOpen) {
            this.physics.pause();
            let txt = `HP: ${this.playerStats.hp}\nAMMO: ${this.playerStats.ammo}\nSCRAP: ${this.playerStats.scrap}\nWEAPON: ${this.playerStats.currentWeapon}`;
            this.invText.setText(txt);
        } else { this.physics.resume(); }
    }

    update(time, delta) {
        if(this.isPaused || this.isInventoryOpen) return;
        
        // Input Handling (Keyboard + Mobile)
        let vx = 0, vy = 0;
        if(this.cursors.left.isDown || this.mobileInput.x < -0.2) vx = -1;
        if(this.cursors.right.isDown || this.mobileInput.x > 0.2) vx = 1;
        if(this.cursors.up.isDown || this.mobileInput.y < -0.2) vy = -1;
        if(this.cursors.down.isDown || this.mobileInput.y > 0.2) vy = 1;
        
        let speed = (this.cursors.shift.isDown || (Math.abs(this.mobileInput.x)>0.8 || Math.abs(this.mobileInput.y)>0.8)) ? 280 : 160;
        if(vx!==0 || vy!==0) {
            const mag = Math.sqrt(vx*vx + vy*vy);
            this.player.setVelocity((vx/mag)*speed, (vy/mag)*speed);
        } else { this.player.setVelocity(0); }
        
        // Keyboard Triggers
        if(Phaser.Input.Keyboard.JustDown(this.keys.interact)) this.tryInteract();
        if(Phaser.Input.Keyboard.JustDown(this.keys.switch)) this.switchWeapon();
        if(Phaser.Input.Keyboard.JustDown(this.keys.nvg)) this.toggleNVG();
        if(Phaser.Input.Keyboard.JustDown(this.keys.tab)) this.toggleInventory();
        if(this.input.activePointer.isDown && !this.isMobileTouch(this.input.activePointer)) this.fireBullet(this.input.activePointer);

        // Entities
        this.enemies.getChildren().forEach(e => e.update(time, delta));
        
        // UI
        this.uiText.setText(`HP: ${this.playerStats.hp} | AMMO: ${this.playerStats.ammo} | ${this.playerStats.currentWeapon}`);
        
        // Light
        this.lightShape.clear(); this.lightShape.fillCircle(this.player.x, this.player.y, 60);
        if(this.playerStats.hasFlashlight) {
            const a = Phaser.Math.Angle.Between(this.player.x, this.player.y, this.input.activePointer.x, this.input.activePointer.y);
            this.lightShape.fillStyle(0xffffff); this.lightShape.slice(this.player.x, this.player.y, 300, a-0.5, a+0.5); this.lightShape.fill();
        }
    }
    
    isMobileTouch(pointer) { return pointer.y > 400; } // Prevent firing when using joystick/buttons

    spawnCrates(loot) {
        loot.forEach(l => {
            let x=Phaser.Math.Between(50,750), y=Phaser.Math.Between(50,550);
            this.crates.create(x, y, 'crate').setData('lootID', l);
        });
    }
    spawnEnemy(type, x, y) { this.enemies.add(new Enemy(this, x, y, this.player, type)); }
    spawnSwitch(x, y) { this.switches.create(x, y, 'switch'); this.switchDropped=true; }
    spawnLootSkull(x, y, type) { this.skulls.create(x, y, 'skull').setData('lootID', 'scrap'); }
    
    fireBullet(pointer) {
        if(this.playerStats.ammo<=0 || this.time.now - this.lastFired < (this.playerStats.currentWeapon==='shotgun'?1000:300)) return;
        this.lastFired = this.time.now; this.playerStats.ammo -= (this.playerStats.currentWeapon==='shotgun'?2:1);
        sfx[this.playerStats.currentWeapon==='shotgun'?'shootShotgun':'shootPistol']();
        const b = this.bullets.get(this.player.x, this.player.y);
        if(b) b.fire(this.player.x, this.player.y, pointer.x, pointer.y);
        this.cameras.main.shake(100, 0.005);
    }
    
    switchWeapon() { 
        if(this.playerStats.hasShotgun) { 
            this.playerStats.currentWeapon = this.playerStats.currentWeapon==='pistol'?'shotgun':'pistol'; 
            sfx.reload();
        } 
    }
    toggleNVG() {
        if(this.playerStats.hideout.armory.hasNVG) {
            this.nvgOn = !this.nvgOn; sfx.toggleNVG();
            this.nvgLayer.setVisible(this.nvgOn); this.darkness.setVisible(!this.nvgOn);
        }
    }
    tryInteract() {
        if(this.currentLevel===2 && this.checkDebris()) return;
        if(this.currentLevel===3 && this.switchDropped && Phaser.Math.Distance.Between(this.player.x,this.player.y,this.switches.getFirstAlive().x,this.switches.getFirstAlive().y)<60) { this.winGame(); return; }
        if(Phaser.Math.Distance.Between(this.player.x, this.player.y, this.door.x, this.door.y)<60) { this.nextLevel(); return; }
        // Loot
        let item = null, minDst = 60;
        this.crates.getChildren().concat(this.skulls.getChildren()).forEach(i => {
            let d = Phaser.Math.Distance.Between(this.player.x, this.player.y, i.x, i.y);
            if(i.active && d < minDst) { item=i; minDst=d; }
        });
        if(item) {
            sfx.loot(); this.applyLoot(item.getData('lootID')); item.destroy();
        }
    }
    checkDebris() {
        if(this.debrisBlock && this.debrisBlock.active && Phaser.Math.Distance.Between(this.player.x, this.player.y, this.debrisBlock.x, this.debrisBlock.y)<80) {
            if(this.hasMolotov) { this.debrisBlock.destroy(); return true; }
        } return false;
    }
    applyLoot(id) {
        if(id==='meds') this.playerStats.hp = Math.min(this.playerStats.hp+5, this.playerStats.maxHp);
        else if(id==='ammo') this.playerStats.ammo += 5;
        else if(id==='scrap') this.playerStats.scrap += 5;
        else if(id==='molotov') this.hasMolotov = true;
        else if(id==='shotgun') this.playerStats.hasShotgun = true;
        else if(id==='plug') this.playerStats.hideout.hasSparkPlug = true;
        this.add.text(this.player.x, this.player.y-50, id.toUpperCase(), {fontSize:'16px', color:'#00ff00'}).setDepth(200).setOrigin(0.5);
    }
    hitPlayer(damage) {
        this.playerStats.hp -= damage; sfx.playerHurt(); this.cameras.main.shake(100,0.01);
        if(this.playerStats.hp<=0) this.scene.restart({level:this.currentLevel, stats:this.checkpointStats});
    }
    nextLevel() { this.scene.restart({level:this.currentLevel+1, stats:this.playerStats}); }
    winGame() { this.scene.start('HideoutScene', {stats:this.playerStats}); }
}

const config = { type: Phaser.AUTO, width: 800, height: 600, backgroundColor: '#000000', parent: 'game-container', 
physics: { default: 'arcade', arcade: { gravity: { y: 0 } } }, scene: [MainMenuScene, GameScene, HideoutScene], 
scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH } };
const game = new Phaser.Game(config);
</script>
</body>
</html>
